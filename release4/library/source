C
      SUBROUTINE ASFUL(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
     *                 DOFEL,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Assembles full real system matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented     6 Feb 1980 (KR)
C
C ARGUMENTS in
C      SYSK    contains system matrix prior to addition of
C              current elemnt matrix contribution
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL)
C      JELK    second dimension of ELK (.GE. DOFEL)
C      STEER   contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTEER  dimension of STEER (.GE. DOFEL)
C      DOFEL   maximum number of degrees of freedom associated
C              with element type
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE ASFUL(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
C    *                 DOFEL,ITEST)
C***********************************************************************
C
      INTEGER DOFEL,ERRMES,I,IELK,IERROR,ISTEER,ISYSK,ITEST,J,JELK,
     *        JSYSK,JTEST,STEER,STEERI,STEERJ
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STEER(ISTEER),SYSK(ISYSK,JSYSK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'ASFUL'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 3
         IF (IELK.LT.DOFEL .OR. JELK.LT.DOFEL) IERROR = 2
         IF (DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1010 I = 1,DOFEL
         STEERI = STEER(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL
               STEERJ = STEER(J)
               IF (STEERJ.GT.0) THEN
C
C     Range checking on STEERI and STEERJ
C
                  IF (JTEST.NE.-1) THEN
                     IERROR = 0
                     IF (ISYSK.LT.STEERI .OR.
     *                   JSYSK.LT.STEERJ) IERROR = 4
                     ITEST = ERRMES(JTEST,IERROR,SRNAME)
                     IF (ITEST.NE.0) RETURN
                  END IF
C
                  SYSK(STEERI,STEERJ) = SYSK(STEERI,STEERJ) + ELK(I,J)
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE ASFULG(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STR1,ISTR1,STR2,
     *                  ISTR2,DOFEL1,DOFEL2,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Perform the general assembly of an element matrix
C      into a full system matrix
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Jun 1984 (CG)
C
C ARGUMENTS in
C      SYSK    contains system matrix prior to addition of
C              current elemnt matrix contribution
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL1)
C      JELK    second dimension of ELK (.GE. DOFEL1)
C      STR1    contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTR2   dimension of STR1 (.GE. DOFEL1)
C      STR1    contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTR2   dimension of STR2 (.GE. DOFEL2)
C      DOFEL1  maximum number of degrees of freedom
C      DOFEL2  maximum number of degrees of freedom
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE ASFULG(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STR1,ISTR1,STR2,
C    *                  ISTR2,DOFEL1,DOFEL2,ITEST)
C***********************************************************************
C
      INTEGER DOFEL1,DOFEL2,ERRMES,I,IELK,IERROR,ISTR1,ISTR2,ISYSK,
     *        ITEST,J,JELK,JSYSK,JTEST,STEERI,STEERJ,STR1,STR2
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STR1(ISTR1),STR2(ISTR2),SYSK(ISYSK,JSYSK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'ASFULG'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTR1.LT.DOFEL1 .OR. ISTR2.LT.DOFEL2) IERROR = 3
         IF (IELK.LT.DOFEL1 .OR. JELK.LT.DOFEL2) IERROR = 2
         IF (DOFEL1.LE.0 .OR. DOFEL2.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Assembly loops
C
      DO 1010 I = 1,DOFEL1
         STEERI = STR1(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL2
               STEERJ = STR2(J)
               IF (STEERJ.GT.0) THEN
C
C     Range checking on STEERI and STEERJ
C
                  IF (JTEST.NE.-1) THEN
                     IERROR = 0
                     IF (ISYSK.LT.STEERI .OR.
     *                   JSYSK.LT.STEERJ) IERROR = 4
                     ITEST = ERRMES(JTEST,IERROR,SRNAME)
                     IF (ITEST.NE.0) RETURN
                  END IF
C
                  SYSK(STEERI,STEERJ) = SYSK(STEERI,STEERJ) + ELK(I,J)
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE ASLMS(SYSM,ISYSM,ELM,IELM,JELM,STEER,ISTEER,DOFEL,
     *                 DOFNOD,SIZE,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Assembles the contribution from an element to the
C      (diagonal) system matrix which is stored as a vector.
C      The 'lumped mass' approximation is assumed, the diagonal
C      elements of the element 'consistent mass' matrix being
C      used, suitably biassed to conserve the relevant quantity
C      (eg mass) on the element.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    31 Oct 1980 (KR)
C
C ARGUMENTS in
C      ISYSM   dimension of vector SYSM (.GE. total number of
C              unconstrained freedoms)
C      ELM     element mass matrix of dimension (IELEM,JELEM).
C              on entry, ELM(I,J) should contain the consistent
C              mass approximations for the element for
C              I=1(1)DOFEL
C      IELM    first dimension of ELM (.GE. DOFEL)
C      JELM    second dimension of ELM (.GE. DOFEL)
C      STEER   integer vector of length ISTEER containing
C              freedom numbers associating element matrix
C              contributions to system freedom numbers
C      ISTEER  length of vector STEER (.GE. DOFEL)
C      DOFEL   maximum number of degrees of freedom associated
C              with the element type
C      DOFNOD  number of degrees of freedom per node on the
C              element
C      SIZE    in two dimensions, area of the element
C              in thre dimensions, volume of the element
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSM    vector of length ISYSM containing the diagonal
C              elements of the (diagonal) system matrix
C      ELM     element 'mass' matrix, of dimension (IELM,JELM).
C              on exit, ELM(i,j) contains ZERO if I .NE. J, and
C              the calculated 'lumped mass' values if I=J
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE ASLMS(SYSM,ISYSM,ELM,IELM,JELM,STEER,ISTEER,DOFEL,
C    *                 DOFNOD,SIZE,ITEST)
C
C***********************************************************************
C
      INTEGER DOFEL,DOFNOD,ERRMES,I,IELM,IERROR,ISTEER,ISYSM,ITEST,J,
     *        JELM,JTEST,STEER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELM,SIZE,SYSM,X,ZERO
      DIMENSION ELM(IELM,JELM),STEER(ISTEER),SYSM(ISYSM)
C
      EXTERNAL ERRMES
C
      DATA ZERO /0.0D00/
      DATA SRNAME/'ASLMS'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IELM.LT.DOFEL .OR. JELM.LT.DOFEL) IERROR = 2
         IF (ISTEER.LT.DOFEL) IERROR = 3
         IF (DOFEL.EQ.0 .OR. DOFNOD.EQ.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      X = 0.0D0
      DO 1000 I = 1,DOFEL
         X = X + ELM(I,I)
 1000 CONTINUE
      X = SIZE/X* ((((DBLE(FLOAT(DOFNOD))))))
      DO 1020 I = 1,DOFEL
         DO 1010 J = 1,DOFEL
            IF (I.EQ.J) THEN
               ELM(I,J) = ELM(I,J)*X
            ELSE
               ELM(I,J) = ZERO
            END IF
 1010    CONTINUE
 1020 CONTINUE
      DO 1030 I = 1,DOFEL
         J = STEER(I)
         IF (J.NE.0) THEN
C
C     Range checking on I and J
C
            IF (JTEST.NE.-1) THEN
               IERROR = 0
               IF (ISYSM.LT.J) IERROR = 4
               ITEST = ERRMES(JTEST,IERROR,SRNAME)
               IF (ITEST.NE.0) RETURN
            END IF
C
            SYSM(J) = SYSM(J) + ELM(I,I)
         END IF
 1030 CONTINUE
C
      END
C
      SUBROUTINE ASRHS(RHS,IRHS,VALUE,IVALUE,STEER,ISTEER,DOFEL,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      The routine adds into the right-hand side of a system
C      the values contianed in an element vector, thus
C      forming the right-hand side.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0   1 Jul 1981 (CG)
C      Commented     1 Jul 1981 (CG)
C
C ARGUMENTS in
C      RHS     the right-hand side of the system
C      IRHS    dimension of array RHS
C      VALUE   the element vector of the current element to
C              be added into the right-hand side
C      ivale   dimension of array VALUE
C      STEER   the steering vector containing the freedom
C              numbers of the freedoms associated with the
C              current element in the local order
C      ISTEER  dimension of array STEER
C      DOFEL   the maximum number of degrees of freedom on
C              an element of the current type
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C
C
C     SUBROUTINE ASRHS(RHS,IRHS,VALUE,IVALUE,STEER,ISTEER,DOFEL,ITEST)
C***********************************************************************
C
      INTEGER DOFEL,ERRMES,IERROR,IRHS,ISTEER,ITEST,IVALUE,JTEST,K,
     *        STEER,STEERI
      CHARACTER*6 SRNAME
      DOUBLE PRECISION RHS,VALUE
      DIMENSION RHS(IRHS),STEER(ISTEER),VALUE(IVALUE)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'ASRHS'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 3
         IF (IVALUE.LT.DOFEL) IERROR = 2
         IF (DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
      END IF
C
C     Main loops
C
      IF (ITEST.EQ.0) THEN
         DO 1000 K = 1,DOFEL
            STEERI = STEER(K)
            IF (STEERI.GT.0) THEN
C
C     Range checking on STEERI
C
               IF (JTEST.NE.-1) THEN
                  IERROR = 0
                  IF (STEERI.GT.IRHS) IERROR = 4
                  ITEST = ERRMES(JTEST,IERROR,SRNAME)
                  IF (ITEST.NE.0) RETURN
               END IF
C
               RHS(STEERI) = RHS(STEERI) + VALUE(K)
            END IF
 1000    CONTINUE
C
      END IF
      END
C
      SUBROUTINE ASSYM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
     *                 HBAND,DOFEL,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      For real symmetric system matrix, adds the contribution
C      from an element matrix.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented     7 Feb 1980 (KR)
C
C ARGUMENTS in
C      SYSK    contains system matrix prior to addition of
C              current element matrix contribution
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. HBAND)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL)
C      JELK    second dimension of ELK (.GE. DOFEL)
C      STEER   contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTEER  first dimension of STEER (.GE. DOFEL)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL   maximum degrees of freedom associated with
C              element type
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE ASSYM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
C    *                 HBAND,DOFEL,ITEST)
C
C***********************************************************************
C
      INTEGER DOFEL,ERRMES,HBAND,I,IELK,IERROR,ISTEER,ISYSK,ITEST,J,
     *        JELK,JSYSK,JTEST,OFFSET,STEER,STEERI,STEERJ
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STEER(ISTEER),SYSK(ISYSK,JSYSK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'ASSYM'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 4
         IF (IELK.LT.DOFEL .OR. JELK.LT.DOFEL) IERROR = 3
         IF (JSYSK.LT.HBAND) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1010 I = 1,DOFEL
         STEERI = STEER(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL
               STEERJ = STEER(J)
               IF (STEERJ.GT.0) THEN
                  OFFSET = STEERJ - STEERI + HBAND
                  IF (OFFSET.LE.HBAND) THEN
C
C     Range checking on STEERI
C
                     IF (JTEST.NE.-1) THEN
                        IERROR = 0
                        IF (ISYSK.LT.STEERI) IERROR = 4
                        ITEST = ERRMES(JTEST,IERROR,SRNAME)
                        IF (ITEST.NE.0) RETURN
                     END IF
C
                     SYSK(STEERI,OFFSET) = SYSK(STEERI,OFFSET) +
     *                                     ELK(I,J)
                  END IF
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE ASSYMG(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STR1,ISTR1,STR2,
     *                  ISTR2,HBAND,DOFEL1,DOFEL2,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      For real symmetric system matrix, adds the contribution
C      from an general element matrix.
C
C HISTORY
C
C      Copyright (C) 1983 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  27 Mar 1983 (CG)
C
C ARGUMENTS in
C      SYSK    contains system matrix prior to addition of
C              current element matrix contribution
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. HBAND)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL1)
C      JELK    second dimension of ELK (.GE. DOFEL2)
C      STR1    contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTR1   first dimension of STR1 (.GE. DOFEL1)
C      STR2    contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTR2   first dimension of STR2 (.GE. DOFEL2)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL1  maximum degrees of freedom 1
C      DOFEL2  maximum degrees of freedom 2
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE ASSYMG(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STR1,ISTR1,STR2,
C    *                  ISTR2,HBAND,DOFEL1,DOFEL2,ITEST)
C***********************************************************************
C
      INTEGER DOFEL1,DOFEL2,ERRMES,HBAND,I,IELK,IERROR,ISTR1,ISTR2,
     *        ISYSK,ITEST,J,JELK,JSYSK,JTEST,OFFSET,STEERI,STEERJ,STR1,
     *        STR2
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STR1(ISTR1),STR2(ISTR2),SYSK(ISYSK,JSYSK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'ASSYMG'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTR1.LT.DOFEL1 .OR. ISTR2.LT.DOFEL2) IERROR = 4
         IF (IELK.LT.DOFEL1 .OR. JELK.LT.DOFEL2) IERROR = 3
         IF (JSYSK.LT.HBAND) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL1.LE.0 .OR. DOFEL2.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Assembly loops
C
      DO 1010 I = 1,DOFEL1
         STEERI = STR1(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL2
               STEERJ = STR2(J)
               IF (STEERJ.GT.0) THEN
                  OFFSET = STEERJ - STEERI + HBAND
                  IF (OFFSET.LE.HBAND) THEN
C
C     Range checking
C
                     IF (JTEST.NE.-1) THEN
                        IERROR = 0
                        IF (ISYSK.LT.STEERI) IERROR = 5
                        ITEST = ERRMES(JTEST,IERROR,SRNAME)
                        IF (ITEST.NE.0) RETURN
                     END IF
C
                     SYSK(STEERI,OFFSET) = SYSK(STEERI,OFFSET) +
     *                                     ELK(I,J)
                  END IF
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE ASUSM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
     *                 HBAND,DOFEL,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      For real unsymmetric system matrix, assembles
C      contribution from element matrix into system matrix.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented     7 Feb 1980 (KR)
C
C ARGUMENTS in
C      SYSK    contains system matrix into which contributions
C              from current element matrix are to be assembled
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. 2*HBAND-1)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL)
C      JELK    second dimension of ELK (.GE. DOFEL)
C      STEER   contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTEER  first dimension of STEER (.GE. DOFEL)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL   maximum number of degrees of freedom associated
C              with this element type
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE ASUSM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
C    *                 HBAND,DOFEL,ITEST)
C
C***********************************************************************
C
      INTEGER DOFEL,ERRMES,HBAND,I,IELK,IERROR,ISTEER,ISYSK,ITEST,J,
     *        JELK,JSYSK,JTEST,OFFSET,STEER,STEERI,STEERJ
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STEER(ISTEER),SYSK(ISYSK,JSYSK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'ASUSM'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 4
         IF (IELK.LT.DOFEL .OR. JELK.LT.DOFEL) IERROR = 3
         IF (JSYSK.LT.2*HBAND-1) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1010 I = 1,DOFEL
         STEERI = STEER(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL
               STEERJ = STEER(J)
               IF (STEERJ.GT.0) THEN
                  OFFSET = STEERJ - STEERI + HBAND
C
C     Range checking on STEERI and STEERJ
C
                  IF (ITEST.NE.-1) THEN
                     IERROR = 0
                     IF (ISYSK.LT.STEERI .OR.
     *                   JSYSK.LT.OFFSET) IERROR = 5
                     ITEST = ERRMES(JTEST,IERROR,SRNAME)
                     IF (ITEST.NE.0) RETURN
                  END IF
C
                  SYSK(STEERI,OFFSET) = SYSK(STEERI,OFFSET) + ELK(I,J)
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE ASUSMG(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STR1,ISTR1,STR2,
     *                  ISTR2,HBAND,DOFEL1,DOFEL2,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      For real unsymmetric system matrix, adds the contribution
C      from an general element matrix.
C
C HISTORY
C
C      Copyright (C) 1983 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  27 Mar 1983 (CG)
C
C ARGUMENTS in
C      SYSK    contains system matrix prior to addition of
C              current element matrix contribution
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. HBAND)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL1)
C      JELK    second dimension of ELK (.GE. DOFEL2)
C      STR1    contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTR1   first dimension of STR1 (.GE. DOFEL1)
C      STR2    contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTR2   first dimension of STR2 (.GE. DOFEL2)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL1  maximum degrees of freedom 1
C      DOFEL2  maximum degrees of freedom 2
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE ASUSMG(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STR1,ISTR1,STR2,
C    *                  ISTR2,HBAND,DOFEL1,DOFEL2,ITEST)
C***********************************************************************
C
      INTEGER DOFEL1,DOFEL2,ERRMES,HBAND,I,IELK,IERROR,ISTR1,ISTR2,
     *        ISYSK,ITEST,J,JELK,JSYSK,JTEST,OFFSET,STEERI,STEERJ,STR1,
     *        STR2
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STR1(ISTR1),STR2(ISTR2),SYSK(ISYSK,JSYSK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'ASUSMG'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTR1.LT.DOFEL1 .OR. ISTR2.LT.DOFEL2) IERROR = 4
         IF (IELK.LT.DOFEL1 .OR. JELK.LT.DOFEL2) IERROR = 3
         IF (JSYSK.LT.2*HBAND-1) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL1.LE.0 .OR. DOFEL2.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Assembly loops
C
      DO 1010 I = 1,DOFEL1
         STEERI = STR1(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL2
               STEERJ = STR2(J)
               IF (STEERJ.GT.0) THEN
                  OFFSET = STEERJ - STEERI + HBAND
C
C     Range checking
C
                  IF (JTEST.NE.-1) THEN
                     IERROR = 0
                     IF (ISYSK.LT.STEERI .OR.
     *                   JSYSK.LT.OFFSET) IERROR = 5
                     ITEST = ERRMES(ITEST,IERROR,SRNAME)
                     IF (ITEST.NE.0) RETURN
                  END IF
C
                  SYSK(STEERI,OFFSET) = SYSK(STEERI,OFFSET) + ELK(I,J)
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE B2C2(B,IB,JB,DER,IDER,JDER,NODEL,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Forms the strain-displacement matrix for 2d plane
C      elasticity.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (IMS)
C      Commented    12 Feb 1980 (KR)
C
C ARGUMENTS in
C      IB      first dimension of array B (.GE. 3)
C      JB      second dimension of B (.GE. 2*NODEL)
C      DER     DER(I,J) contains the derivative of the J'th
C              shape function with respect to the I'th global
C              coordinate
C      IDER    first dimension of DER (.GE. 2)
C      JDER    second dimension of DER (.GE. NODEL)
C      NODEL   number of nodes on the element
C      ITEST   error checking option
C
C ARGUMENTS out
C      B       contains the values of the strain-displacement
C              matrix
C
C ROUTINES called
C      MATNUL  ERRMES
C
C     SUBROUTINE B2C2(B,IB,JB,DER,IDER,JDER,NODEL,ITEST)
C
C***********************************************************************
C
      INTEGER ERRMES,IB,IDER,IERROR,ITEST,JB,JDER,K,L,M,NODEL
      CHARACTER*6 SRNAME
      DOUBLE PRECISION B,DER
      DIMENSION B(IB,JB),DER(IDER,JDER)
C
      EXTERNAL ERRMES, MATNUL
C
      DATA SRNAME/'B2C2'/
C
C     Intialisation
C
      K = 3
      L = 2*NODEL
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IDER.LT.2 .OR. JDER.LT.NODEL) IERROR = 3
         IF (IB.LT.3 .OR. JB.LT.L) IERROR = 2
         IF (NODEL.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Initialise matrix
C
      CALL MATNUL(B,IB,JB,K,L,ITEST)
C
      DO 1000 M = 1,NODEL
         K = 2*M
         L = K - 1
         B(1,L) = DER(1,M)
         B(3,K) = DER(1,M)
         B(2,K) = DER(2,M)
         B(3,L) = DER(2,M)
 1000 CONTINUE
C
      END
C
      SUBROUTINE B2P2(B,IB,JB,DER,IDER,JDER,FUN,IFUN,COORD,ICOORD,
     *                JCOORD,NODEL,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Forms the strain-displacement matrix for axisymmetric
C      elasticity.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (IMS)
C      Commented    12 Feb 1980 (KR)
C
C ARGUMENTS in
C      IB      first dimension of array B (.GE. 3)
C      JB      second dimension of B (.GE. 2*NODEL)
C      DER     DER(I,J) contains the derivative of the J'th
C              shape function with respect to the I'th global
C              coordinate
C      IDER    first dimension of DER (.GE. 2)
C      JDER    second dimension of DER (.GE. NODEL)
C      FUN     FUN(I) conatins the value of the I'th shape
C              function at the point under consideration
C      IFUN    first dimension of FUN (.GE. 4)
C      COORD   COORD(I,J) contains the J'th global coordinate
C              of the I'th node
C      ICOORD  first dimension of COORD (.GE. number of nodes
C              in the mesh)
C      JCOORD  second dimension of COORD (.GE. dimensionality
C              of problem)
C      NODEL   number of nodes on element
C      ITEST   error checking option
C
C ARGUMENTS out
C      B       conatins values of strain-displacement matrix
C
C ROUTINES called
C      MATNUL  ERRMES  VTOL
C
C     SUBROUTINE B2P2(B,IB,JB,DER,IDER,JDER,FUN,IFUN,COORD,ICOORD,
C    *                JCOORD,NODEL,ITEST)
C
C***********************************************************************
C
      INTEGER ERRMES,IB,ICOORD,IDER,IERROR,IFUN,ITEST,JB,JCOORD,JDER,
     *        JTEST,K,L,M,NODEL
      CHARACTER*6 SRNAME
      DOUBLE PRECISION B,COORD,DER,FUN,SUM,TOL,VTOL,X
      DIMENSION B(IB,JB),COORD(ICOORD,JCOORD),DER(IDER,JDER),FUN(IFUN)
C
      EXTERNAL ERRMES, MATNUL, VTOL
C
      DATA SRNAME/'B2P2'/
C
C     Intialisation
C
      K = 4
      L = 2*NODEL
      TOL = VTOL(X)
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IDER.LT.2 .OR. JDER.LT.NODEL) IERROR = 3
         IF (IB.LT.3 .OR. JB.LT.L) IERROR = 2
         IF (NODEL.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      CALL MATNUL(B,IB,JB,K,L,ITEST)
C
C     Calculate average radius
C
      SUM = 0.0D0
      DO 1000 K = 1,NODEL
         SUM = SUM + FUN(K)*COORD(K,1)
 1000 CONTINUE
C
C     Check value of SUM rbar
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (DABS(SUM).LT.TOL) IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      DO 1010 M = 1,NODEL
         K = 2*M
         L = K - 1
         B(1,L) = DER(1,M)
         B(3,K) = DER(1,M)
         B(2,K) = DER(2,M)
         B(3,L) = DER(2,M)
         B(4,L) = FUN(M)/SUM
 1010 CONTINUE
C
      END
C
      SUBROUTINE B3C3(B,IB,JB,DER,IDER,JDER,NODEL,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Forms strain-displacement matrix for 3d elasticity.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (IMS)
C      Commented    12 Feb 1980 (KR)
C
C ARGUMENTS in
C      IB      first dimension of array B (.GE. 6)
C      JB      second dimension of B (.GE. 3*NODEL)
C      DER     DER(I,J) contains the derivative of the J'th
C              shape function with respect to the I'th global
C              coordinate
C      IDER    first dimension of DER (.GE. 3)
C      JDER    second dimension of DER (.GE. NODEL)
C      NODEL   number of nodes on element
C      ITEST   error checking option
C
C ARGUMENTS out
C      B       contains values of strain-displacement matrix
C
C ROUTINES called
C      MATNUL  ERRMES
C
C     SUBROUTINE B3C3(B,IB,JB,DER,IDER,JDER,NODEL,ITEST)
C
C***********************************************************************
C
      INTEGER ERRMES,IB,IDER,IERROR,ITEST,JB,JDER,K,L,M,N,NODEL
      CHARACTER*6 SRNAME
      DOUBLE PRECISION B,DER
      DIMENSION B(IB,JB),DER(IDER,JDER)
C
      EXTERNAL ERRMES, MATNUL
C
      DATA SRNAME/'B3C3'/
C
C     Intialisation
C
      K = 6
      L = 3*NODEL
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IDER.LT.3 .OR. JDER.LT.NODEL) IERROR = 3
         IF (IB.LT.K .OR. JB.LT.L) IERROR = 2
         IF (NODEL.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      CALL MATNUL(B,IB,JB,K,L,ITEST)
C
      DO 1000 M = 1,NODEL
         N = 3*M
         K = N - 1
         L = K - 1
         B(1,L) = DER(1,M)
         B(4,K) = DER(1,M)
         B(6,N) = DER(1,M)
         B(2,K) = DER(2,M)
         B(4,L) = DER(2,M)
         B(5,N) = DER(2,M)
         B(3,N) = DER(3,M)
         B(5,K) = DER(3,M)
         B(6,L) = DER(3,M)
 1000 CONTINUE
C
      END
C
      SUBROUTINE BNDWTH(ELTOP,IELTOP,JELTOP,NF,INF,JNF,DOFNOD,TOTELS,
     *                  HBAND,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Calculates the maximum freedom number difference over
C      all the elements in the mesh.
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1984 (CG)
C
C ARGUMENTS in
C      ELTOP   ELTOP(I,1) = element type of element I
C              ELTOP(I,2) = number of nodes on element I
C              ELTOP(I,J+2), J=1(1)number of nodes on element,
C              contains the nodes associated with element I
C      IELTOP  first dimension of array ELTOP (.GE. TOTELS)
C      JELTOP  second dimension of ELTOP (.GE. number of nodes
C              on element)
C      NF      NF(I,J) contains the freedom numbers associated
C              with node I
C      INF     first dimension of NF (.GE. maximum node number
C              on element)
C      JNF     second dimension of NF (.GE. DOFNOD)
C      DOFNOD  number of degrees of freedom per node on the
C              element
C      TOTELS  number of elements in the mesh
C      ITEST   error checking option
C
C ARGUMENTS out
C      HBAND   semi bandwidth
C
C ROUTINES called
C      ERRMES    MAXINT
C
C     SUBROUTINE BNDWTH(ELTOP,IELTOP,JELTOP,NF,INF,JNF,DOFNOD,TOTELS,
C    *                  HBAND,ITEST)
C*********************************************************
C
      INTEGER DOFNOD,ELTOP,ERRMES,HBAND,I,IDEG,IELE,IELTOP,IERROR,INF,
     *        INOD,ITEST,J,JELTOP,JNF,JTEST,MAX,MAXINT,MIN,NF,NODEL,
     *        TOTELS
      CHARACTER*6 SRNAME
      DIMENSION ELTOP(IELTOP,JELTOP),NF(INF,JNF)
C
      EXTERNAL ERRMES, MAXINT
C
      DATA SRNAME/'BNDWTH'/
C
C     Initialisation
C
      HBAND = 0
      JTEST = ITEST
C
C     Parameter checking
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (DOFNOD.LE.0) IERROR = 1
         IF (JNF.LT.DOFNOD) IERROR = 2
         IF (TOTELS.GT.IELTOP) IERROR = 3
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main scanning loops
C
      DO 1020 IELE = 1,TOTELS
         MAX = 0
         MIN = MAXINT(MAX)
         NODEL = ELTOP(IELE,2)
C
C     Range checking on NODEL
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF (JELTOP.LT.NODEL+2) IERROR = 4
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
C     Loop over nodes
C
         DO 1010 I = 1,NODEL
            INOD = ELTOP(IELE,I+2)
C
C     Range checking on INOD
C
            IF (JTEST.NE.-1) THEN
               IERROR = 0
               IF (INF.LT.INOD) IERROR = 5
               ITEST = ERRMES(JTEST,IERROR,SRNAME)
               IF (ITEST.NE.0) RETURN
            END IF
C
C     Loop over freedoms
C
            DO 1000 J = 1,DOFNOD
               IDEG = NF(INOD,J)
               IF (IDEG.NE.0) THEN
                  MAX = MAX0(IDEG,MAX)
                  MIN = MIN0(IDEG,MIN)
               END IF
 1000       CONTINUE
 1010    CONTINUE
C
C     Maximum freedom number difference
C
         HBAND = MAX0(HBAND,MAX-MIN)
 1020 CONTINUE
C
C     Semi band width
C
      HBAND = HBAND + 1
C
      END
C
      SUBROUTINE BQBRK(ABSS,IABSS,JABSS,WORK,IWORK,JWORK,NQP,FACNUM,
     *                 COEF,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Forms an equivalent two-dimensional quadrature rule of
C      a given three-dimensional rule for integration over the
C      specified face of a brick element.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1 Feb 1981 (CG)
C      Commented   24 Jun 1981 (CG)
C
C ARGUMENTS in
C      ABSS    array holding the abscissae of the three-
C              dimensional quadrature rule to be used
C      IABSS   first dimension of array ABSS
C      JABSS   second dimension of array ABSS
C      IWORK   first dimension of array WORK
C      JWORK   second dimension of array WORK
C      NQP     number of quadrature points in the rule
C      FACNUM  the face number for which the two-
C              dimensional rule is required
C      ITEST   error checking option
C
C ARGUMENTS out
C      WORK    array containing the abscissae of the
C              equivalent one-dimensional rule
C      COEF    a multiplier of the rule
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE BQBRK(ABSS,IABSS,JABSS,WORK,IWORK,JWORK,NQP,FACNUM,
C    *                 COEF,ITEST)
C
C***********************************************************************
C
      INTEGER ERRMES,FACNUM,I,IABSS,IERROR,ITEST,IWORK,J,JABSS,JWORK,K,
     *        L,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,COEF,VAL,WORK
      DIMENSION ABSS(IABSS,JABSS),WORK(IWORK,JWORK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'BQBRK'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (NQP.EQ.0) IERROR = 1
         IF (FACNUM.LE.0 .OR. FACNUM.GT.6) IERROR = 2
         IF (IWORK.LT.2 .OR. JWORK.LT.NQP) IERROR = 3
         IF (IABSS.LT.3 .OR. JABSS.LT.NQP) IERROR = 4
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      GO TO (1000,1010,1020,1030,1040,1050) FACNUM
      GO TO 1020
C
C     Face number 1 : zeta = -1
C
 1000 CONTINUE
      I = 3
      J = 1
      K = 2
      VAL = -1.0D0
      COEF = 1.0D0
      GO TO 1060
C
C     Face number 2 : zeta = +1
C
 1010 CONTINUE
      I = 3
      J = 1
      K = 2
      VAL = 1.0D0
      COEF = 1.0D0
      GO TO 1060
C
C     Face number 3 : xi = -1
C
 1020 CONTINUE
      I = 1
      J = 2
      K = 3
      VAL = -1.0D0
      COEF = 1.0D0
      GO TO 1060
C
C     Face number 4 : eta = +1
C
 1030 CONTINUE
      I = 2
      J = 1
      K = 3
      VAL = 1.0D0
      COEF = 1.0D0
      GO TO 1060
C
C     Face number 5 : xi = +1
C
 1040 CONTINUE
      I = 1
      J = 2
      K = 3
      VAL = 1.0D0
      COEF = 1.0D0
      GO TO 1060
C
C     Face number 6 : eta = -1
C
 1050 CONTINUE
      I = 2
      J = 1
      K = 3
      VAL = -1.0D0
      COEF = 1.0D0
C
 1060 CONTINUE
      DO 1070 L = 1,NQP
         ABSS(I,L) = VAL
         ABSS(J,L) = WORK(1,L)
         ABSS(K,L) = WORK(2,L)
 1070 CONTINUE
C
      END
C
      SUBROUTINE BQQUA(ABSS,IABSS,JABSS,WORK,IWORK,NQP,SIDNUM,COEF,
     *                 ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Forms an equivalent one-dimensional quadrature rule of
C      a given two-dimensional rule for integration along the
C      specified side of a rectangular element.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1 Feb 1981 (CG)
C      Commented   24 Jun 1981 (CG)
C
C ARGUMENTS in
C      ABSS    array holding the abscissae of the two-
C              dimensional quadrature rule to be used
C      IABSS   first dimension of array ABSS
C      JABSS   second dimension of array ABSS
C      IWORK   dimension of array WORK
C      NQP     number of quadrature points in the rule
C      SIDNUM  the side number for which the one-
C              dimensional rule is required
C      ITEST   error checking option
C
C ARGUMENTS out
C      WORK    array containing the abscissae of the
C              equivalent one-dimensional rule
C      COEF    a multiplier of the rule
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE BQQUA(ABSS,IABSS,JABSS,WORK,IWORK,NQP,SIDNUM,COEF,
C    *                 ITEST)
C
C***********************************************************************
C
      INTEGER ERRMES,I,IABSS,IERROR,ITEST,IWORK,J,JABSS,K,NQP,SIDNUM
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,COEF,VAL,WORK
      DIMENSION ABSS(IABSS,JABSS),WORK(IWORK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'BQQUA'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IABSS.LT.2 .OR. JABSS.LT.NQP) IERROR = 4
         IF (IWORK.LT.NQP) IERROR = 3
         IF (SIDNUM.LE.0 .OR. SIDNUM.GT.4) IERROR = 2
         IF (NQP.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      COEF = 1.0D0
      GO TO (1000,1010,1020,1030) SIDNUM
C
C     Side number 1 : xi = -1
C
 1000 CONTINUE
      I = 1
      J = 2
      VAL = -1.0D0
      GO TO 1040
C
C     Side number 2 : xi = +1
C
 1010 CONTINUE
      I = 2
      J = 1
      VAL = 1.0D0
      GO TO 1040
C
C     Side number 3 : eta = -1
C
 1020 CONTINUE
      I = 1
      J = 2
      VAL = 1.0D0
      GO TO 1040
C
C     Side number 4 : eta = +1
C
 1030 CONTINUE
      I = 2
      J = 1
      VAL = -1.0D0
C
 1040 CONTINUE
      DO 1050 K = 1,NQP
         ABSS(I,K) = VAL
         ABSS(J,K) = WORK(K)
 1050 CONTINUE
C
      END
C
      SUBROUTINE BQTRI(ABSS,IABSS,JABSS,WORK,IWORK,NQP,SIDNUM,COEF,
     *                 ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Forms an equivalent one-dimensional quadrature rule of
C      a given two-dimensional rule for integration along the
C      specified side of a triangular element.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1 Feb 1981 (CG)
C      Commented   24 Jun 1981 (CG)
C
C ARGUMENTS in
C      ABSS    array holding the abscissae of the two-
C              dimensional quadrature rule to be used
C      IABSS   first dimension of array ABSS
C      JABSS   second dimension of array ABSS
C      IWORK   dimension of array WORK
C      NQP     number of quadrature points in the rule
C      SIDNUM  the side number for which the one-
C              dimensional rule is required
C      ITEST   error checking option
C
C ARGUMENTS out
C      WORK    array containing the abscissae of the
C              equivalent one-dimensional rule
C      COEF    a multiplier of the rule
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE BQTRI(ABSS,IABSS,JABSS,WORK,IWORK,NQP,SIDNUM,COEF,
C    *                 ITEST)
C***********************************************************************
C
      INTEGER ERRMES,I,IABSS,IERROR,ITEST,IWORK,JABSS,NQP,SIDNUM
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,COEF,ETA,L1,L2,L3,LL1,LL2,LL3,WORK,XI
      DIMENSION ABSS(IABSS,JABSS),WORK(IWORK)
C
      EXTERNAL ERRMES
C
      DATA SRNAME/'BQTRI'/
C
C     Statement functions
C
      XI(LL1,LL2,LL3) = 1.0D0 - 3.0D0/2.0D0* (LL2+LL3)
      ETA(LL1,LL2,LL3) = DSQRT(3.0D0)/2.0D0* (LL3-LL2)
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IABSS.LE.2 .OR. JABSS.LE.NQP) IERROR = 4
         IF (IWORK.LE.NQP) IERROR = 3
         IF (SIDNUM.LE.0 .OR. SIDNUM.GT.3) IERROR = 2
         IF (NQP.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      COEF = 0.5D0
      GO TO (1000,1020,1040) SIDNUM
C
C     Side number 1 : L3 = 0
C
 1000 CONTINUE
      L3 = 0.0D0
      DO 1010 I = 1,NQP
         L1 = 0.5D0* (1.D0+WORK(I))
         L2 = 1.0D0 - L1
         ABSS(1,I) = XI(L1,L2,L3)
         ABSS(2,I) = ETA(L1,L2,L3)
 1010 CONTINUE
      RETURN
C
C     Side number 2 : L1 = 0
C
 1020 CONTINUE
      L1 = 0.0D0
      DO 1030 I = 1,NQP
         L2 = 0.5D0* (1.D0+WORK(I))
         L3 = 1.0D0 - L2
         ABSS(1,I) = XI(L1,L2,L3)
         ABSS(2,I) = ETA(L1,L2,L3)
 1030 CONTINUE
      RETURN
C
C     Side number 3 : L2 = 0
C
 1040 CONTINUE
      L2 = 0.0D0
      DO 1050 I = 1,NQP
         L3 = 0.5D0* (1.D0+WORK(I))
         L1 = 1.0D0 - L3
         ABSS(1,I) = XI(L1,L2,L3)
         ABSS(2,I) = ETA(L1,L2,L3)
 1050 CONTINUE
      END
C
      SUBROUTINE BRK20(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
C-----------------------------------------------------------------------
C PURPOSE
C      Calculates shape functions and derivatives at a
C      specified point for 20-noded brick element.  Function
C      continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.GE. 20)
C      IDER    first dimension of real array DER (.GE. 3)
C      JDER    second dimension of real array DER (.GE. 20)
C      XI      value of first local coordinate
C      ETA     value of second local coordinate
C      ZETA    value of third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of shape function values.  FUN(I)
C              contains the value of the I'th shape function at
C              (XI,ETA,ZETA)
C      DER     array of shape function derivative values.
C              DER(I,J) contains the value of the derivative of
C              the J'th shape function with respect to the I'th
C              coordinate at (XI,ETA,ZETA)
C
C ROUTINES called
C      ERRMES    VEPS
C
C     SUBROUTINE BRK20(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
C***********************************************************************
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DNCX,DNCY,DNCZ,DNSXX,DNSXY,DNSXZ,DNSYX,DNSYY,
     *                 DNSYZ,DNSZX,DNSZY,DNSZZ,DUMMY,ETA,FUN,M1,NC,NSX,
     *                 NSY,NSZ,P1,VAL,VEPS,X,XI,Y,Z,ZETA
      DIMENSION DER(IDER,JDER),FUN(IFUN)
C
      EXTERNAL ERRMES, VEPS
C
      DATA M1/-1.D0/,P1/1.D0/
      DATA SRNAME/' BRK20  '/
C
C     Statement functions
C
      NC(X,Y,Z) = 1.D0/8.D0* (1.D0+XI*X)* (1.D0+ETA*Y)* (1.D0+ZETA*Z)*
     *            (XI*X+ETA*Y+ZETA*Z-2.D0)
      NSX(Y,Z) = 1.D0/4.D0* (1.D0-XI*XI)* (1.D0+ETA*Y)* (1.D0+ZETA*Z)
      NSY(X,Z) = 1.D0/4.D0* (1.D0+XI*X)* (1.D0-ETA*ETA)* (1.D0+ZETA*Z)
      NSZ(X,Y) = 1.D0/4.D0* (1.D0+XI*X)* (1.D0+ETA*Y)* (1.D0-ZETA*ZETA)
      DNCX(X,Y,Z) = 1.D0/8.D0*X* (1.D0+ETA*Y)* (1.D0+ZETA*Z)*
     *              (2.D0*XI*X+ETA*Y+ZETA*Z-1.D0)
      DNCY(X,Y,Z) = 1.D0/8.D0*Y* (1.D0+XI*X)* (1.D0+ZETA*Z)*
     *              (XI*X+2.D0*ETA*Y+ZETA*Z-1.D0)
      DNCZ(X,Y,Z) = 1.D0/8.D0*Z* (1.D0+XI*X)* (1.D0+ETA*Y)*
     *              (XI*X+ETA*Y+2.D0*ZETA*Z-1.D0)
      DNSXX(Y,Z) = -1.D0/2.D0*XI* (1.D0+ETA*Y)* (1.D0+ZETA*Z)
      DNSXY(Y,Z) = 1.D0/4.D0*Y* (1.D0-XI*XI)* (1.D0+ZETA*Z)
      DNSXZ(Y,Z) = 1.D0/4.D0*Z* (1.D0-XI*XI)* (1.D0+ETA*Y)
      DNSYX(X,Z) = 1.D0/4.D0*X* (1.D0-ETA*ETA)* (1.D0+ZETA*Z)
      DNSYY(X,Z) = -1.D0/2.D0*ETA* (1.D0+XI*X)* (1.D0+ZETA*Z)
      DNSYZ(X,Z) = 1.D0/4.D0*Z* (1.D0-ETA*ETA)* (1.D0+XI*X)
      DNSZX(X,Y) = 1.D0/4.D0*X* (1.D0+ETA*Y)* (1.D0-ZETA*ZETA)
      DNSZY(X,Y) = 1.D0/4.D0*Y* (1.D0+XI*X)* (1.D0-ZETA*ZETA)
      DNSZZ(X,Y) = -1.D0/2.D0*ZETA* (1.D0+XI*X)* (1.D0+ETA*Y)
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.20) IERROR = 1
         IF (IDER.LT.3 .OR. JDER.LT.20) IERROR = 2
         VAL = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.VAL .OR. DABS(ETA).GT.VAL .OR.
     *       DABS(ZETA).GT.VAL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Set shape functions
C
      FUN(1) = NC(M1,M1,M1)
      FUN(2) = NSY(M1,M1)
      FUN(3) = NC(M1,P1,M1)
      FUN(4) = NSX(P1,M1)
      FUN(5) = NC(P1,P1,M1)
      FUN(6) = NSY(P1,M1)
      FUN(7) = NC(P1,M1,M1)
      FUN(8) = NSX(M1,M1)
      FUN(9) = NSZ(M1,M1)
      FUN(10) = NSZ(M1,P1)
      FUN(11) = NSZ(P1,P1)
      FUN(12) = NSZ(P1,M1)
      FUN(13) = NC(M1,M1,P1)
      FUN(14) = NSY(M1,P1)
      FUN(15) = NC(M1,P1,P1)
      FUN(16) = NSX(P1,P1)
      FUN(17) = NC(P1,P1,P1)
      FUN(18) = NSY(P1,P1)
      FUN(19) = NC(P1,M1,P1)
      FUN(20) = NSX(M1,P1)
C
C     Set derivatives
C
      DER(1,1) = DNCX(M1,M1,M1)
      DER(2,1) = DNCY(M1,M1,M1)
      DER(3,1) = DNCZ(M1,M1,M1)
      DER(1,2) = DNSYX(M1,M1)
      DER(2,2) = DNSYY(M1,M1)
      DER(3,2) = DNSYZ(M1,M1)
      DER(1,3) = DNCX(M1,P1,M1)
      DER(2,3) = DNCY(M1,P1,M1)
      DER(3,3) = DNCZ(M1,P1,M1)
      DER(1,4) = DNSXX(P1,M1)
      DER(2,4) = DNSXY(P1,M1)
      DER(3,4) = DNSXZ(P1,M1)
      DER(1,5) = DNCX(P1,P1,M1)
      DER(2,5) = DNCY(P1,P1,M1)
      DER(3,5) = DNCZ(P1,P1,M1)
      DER(1,6) = DNSYX(P1,M1)
      DER(2,6) = DNSYY(P1,M1)
      DER(3,6) = DNSYZ(P1,M1)
      DER(1,7) = DNCX(P1,M1,M1)
      DER(2,7) = DNCY(P1,M1,M1)
      DER(3,7) = DNCZ(P1,M1,M1)
      DER(1,8) = DNSXX(M1,M1)
      DER(2,8) = DNSXY(M1,M1)
      DER(3,8) = DNSXZ(M1,M1)
      DER(1,9) = DNSZX(M1,M1)
      DER(2,9) = DNSZY(M1,M1)
      DER(3,9) = DNSZZ(M1,M1)
      DER(1,10) = DNSZX(M1,P1)
      DER(2,10) = DNSZY(M1,P1)
      DER(3,10) = DNSZZ(M1,P1)
      DER(1,11) = DNSZX(P1,P1)
      DER(2,11) = DNSZY(P1,P1)
      DER(3,11) = DNSZZ(P1,P1)
      DER(1,12) = DNSZX(P1,M1)
      DER(2,12) = DNSZY(P1,M1)
      DER(3,12) = DNSZZ(P1,M1)
      DER(1,13) = DNCX(M1,M1,P1)
      DER(2,13) = DNCY(M1,M1,P1)
      DER(3,13) = DNCZ(M1,M1,P1)
      DER(1,14) = DNSYX(M1,P1)
      DER(2,14) = DNSYY(M1,P1)
      DER(3,14) = DNSYZ(M1,P1)
      DER(1,15) = DNCX(M1,P1,P1)
      DER(2,15) = DNCY(M1,P1,P1)
      DER(3,15) = DNCZ(M1,P1,P1)
      DER(1,16) = DNSXX(P1,P1)
      DER(2,16) = DNSXY(P1,P1)
      DER(3,16) = DNSXZ(P1,P1)
      DER(1,17) = DNCX(P1,P1,P1)
      DER(2,17) = DNCY(P1,P1,P1)
      DER(3,17) = DNCZ(P1,P1,P1)
      DER(1,18) = DNSYX(P1,P1)
      DER(2,18) = DNSYY(P1,P1)
      DER(3,18) = DNSYZ(P1,P1)
      DER(1,19) = DNCX(P1,M1,P1)
      DER(2,19) = DNCY(P1,M1,P1)
      DER(3,19) = DNCZ(P1,M1,P1)
      DER(1,20) = DNSXX(M1,P1)
      DER(2,20) = DNSXY(M1,P1)
      DER(3,20) = DNSXZ(M1,P1)
C
      END
C
      SUBROUTINE BRK32(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates the values of the shape functions and their
C      derivatives at a point for a 32-noded brick element.
C      function continuous across element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.32)
C      IDER    first dimension of array DER (.ge.3)
C      JDER    second dimension of array DER (.ge.32)
C      XI      first local coordinate
C      ETA     second local coordinate
C      ZETA    third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector containing shape functions.  fun(i)
C              contains the value of the i'th shape function at
C              (xi,eta,zeta)
C      DER     array containing the derivatives of the shape
C              functions.  der(i,j) contains the value of the
C              derivative of the j'th shape function with
C              respect to the i'th coordinate at (xi,eta,zeta)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE brk32(fun, IFUN, DER, IDER, JDER, XI, ETA, ZETA,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DNCX,DNCY,DNCZ,DNSXX,DNSXY,DNSXZ,DNSYX,DNSYY,
     *                 DNSYZ,DNSZX,DNSZY,DNSZZ,DUMMY,ETA,FUN,M1,MTHRD,
     *                 NC,NSX,NSY,NSZ,P1,PTHRD,VAL,VEPS,X,XI,Y,Z,ZETA
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'BRK32'/
C
C     Statement functions
C
      NC(X,Y,Z) = 1.D0/64.D0* (1.D0+XI*X)* (1.D0+ETA*Y)* (1.D0+ZETA*Z)*
     *             (9.D0* (XI*XI+ETA*ETA+ZETA*ZETA)-19.D0)
      NSX(X,Y,Z) = 9.D0/64.D0* (1.D0-XI*XI)* (1.D0+9.D0*XI*X)*
     *             (1.D0+ETA*Y)* (1.D0+ZETA*Z)
      NSY(X,Y,Z) = 9.D0/64.D0* (1.D0-ETA*ETA)* (1.D0+9.D0*ETA*Y)*
     *             (1.D0+XI*X)* (1.D0+ZETA*Z)
      NSZ(X,Y,Z) = 9.D0/64.D0* (1.D0-ZETA*ZETA)* (1.D0+9.D0*ZETA*Z)*
     *             (1.D0+XI*X)* (1.D0+ETA*Y)
      DNCX(X,Y,Z) = 1.D0/64.D0* (1.D0+ETA*Y)* (1.D0+ZETA*Z)*
     *              (X* (9.D0* (XI*XI+ETA*ETA+ZETA*ZETA)-19.D0)+
     *              18.D0*XI* (1.D0+XI*X))
      DNCY(X,Y,Z) = 1.D0/64.D0* (1.D0+XI*X)* (1.D0+ZETA*Z)*
     *              (Y* (9.D0* (XI*XI+ETA*ETA+ZETA*ZETA)-19.D0)+
     *              18.D0*ETA* (1.D0+ETA*Y))
      DNCZ(X,Y,Z) = 1.D0/64.D0* (1.D0+XI*X)* (1.D0+ETA*Y)*
     *              (Z* (9.D0* (XI*XI+ETA*ETA+ZETA*ZETA)-19.D0)+
     *              18.D0*ZETA* (1.D0+ZETA*Z))
      DNSXX(X,Y,Z) = 9.D0/64.D0* (1.D0+ETA*Y)* (1.D0+ZETA*Z)*
     *               (9.D0*X* (1.D0-XI*XI)-2.D0*XI* (1.D0+9.D0*XI*X))
      DNSXY(X,Y,Z) = 9.D0/64.D0*Y* (1.D0-XI*XI)* (1.D0+9.D0*XI*X)*
     *               (1.D0+ZETA*Z)
      DNSXZ(X,Y,Z) = 9.D0/64.D0*Z* (1.D0-XI*XI)* (1.D0+9.D0*XI*X)*
     *               (1.D0+ETA*Y)
      DNSYX(X,Y,Z) = 9.D0/64.D0*X* (1.D0-ETA*ETA)* (1.D0+9.D0*ETA*Y)*
     *               (1.D0+ZETA*Z)
      DNSYY(X,Y,Z) = 9.D0/64.D0* (1.D0+XI*X)* (1.D0+ZETA*Z)*
     *               (9.D0*Y* (1.D0-ETA*ETA)-2.D0*ETA*
     *               (1.D0+9.D0*ETA*Y))
      DNSYZ(X,Y,Z) = 9.D0/64.D0*Z* (1.D0-ETA*ETA)* (1.D0+9.D0*ETA*Y)*
     *               (1.D0+XI*X)
      DNSZX(X,Y,Z) = 9.D0/64.D0*X* (1.D0-ZETA*ZETA)* (1.D0+9.D0*ZETA*Z)*
     *                (1.D0+ETA*Y)
      DNSZY(X,Y,Z) = 9.D0/64.D0*Y* (1.D0-ZETA*ZETA)* (1.D0+9.D0*ZETA*Z)*
     *                (1.D0+XI*X)
      DNSZZ(X,Y,Z) = 9.D0/64.D0* (1.D0+XI*X)* (1.D0+ETA*Y)*
     *               (9.D0*Z* (1.D0-ZETA*ZETA)-
     *               2.D0*ZETA* (1.D0+9.D0*ZETA*Z))
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.32) IERROR = 1
         IF (IDER.LT.3 .OR. JDER.LT.32) IERROR = 2
         VAL = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.VAL .OR. DABS(ETA).GT.VAL .OR.
     *       DABS(ZETA).GT.VAL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Body of code
C
      P1 = 1.D0
      M1 = -1.D0
      PTHRD = 1.D0/3.D0
      MTHRD = -1.D0/3.D0
C
C     Set shape functions
C
      FUN(1) = NC(M1,M1,M1)
      FUN(2) = NSY(M1,MTHRD,M1)
      FUN(3) = NSY(M1,PTHRD,M1)
      FUN(4) = NC(M1,P1,M1)
      FUN(5) = NSX(MTHRD,P1,M1)
      FUN(6) = NSX(PTHRD,P1,M1)
      FUN(7) = NC(P1,P1,M1)
      FUN(8) = NSY(P1,PTHRD,M1)
      FUN(9) = NSY(P1,MTHRD,M1)
      FUN(10) = NC(P1,M1,M1)
      FUN(11) = NSX(PTHRD,M1,M1)
      FUN(12) = NSX(MTHRD,M1,M1)
      FUN(13) = NSZ(M1,M1,MTHRD)
      FUN(14) = NSZ(M1,P1,MTHRD)
      FUN(15) = NSZ(P1,P1,MTHRD)
      FUN(16) = NSZ(P1,M1,MTHRD)
      FUN(17) = NSZ(M1,M1,PTHRD)
      FUN(18) = NSZ(M1,P1,PTHRD)
      FUN(19) = NSZ(P1,P1,PTHRD)
      FUN(20) = NSZ(P1,M1,PTHRD)
      FUN(21) = NC(M1,M1,P1)
      FUN(22) = NSY(M1,MTHRD,P1)
      FUN(23) = NSY(M1,PTHRD,P1)
      FUN(24) = NC(M1,P1,P1)
      FUN(25) = NSX(MTHRD,P1,P1)
      FUN(26) = NSX(PTHRD,P1,P1)
      FUN(27) = NC(P1,P1,P1)
      FUN(28) = NSY(P1,PTHRD,P1)
      FUN(29) = NSY(P1,MTHRD,P1)
      FUN(30) = NC(P1,M1,P1)
      FUN(31) = NSX(PTHRD,M1,P1)
      FUN(32) = NSX(MTHRD,M1,P1)
C
C     Set derivatives
C
      DER(1,1) = DNCX(M1,M1,M1)
      DER(2,1) = DNCY(M1,M1,M1)
      DER(3,1) = DNCZ(M1,M1,M1)
      DER(1,2) = DNSYX(M1,MTHRD,M1)
      DER(2,2) = DNSYY(M1,MTHRD,M1)
      DER(3,2) = DNSYZ(M1,MTHRD,M1)
      DER(1,3) = DNSYX(M1,PTHRD,M1)
      DER(2,3) = DNSYY(M1,PTHRD,M1)
      DER(3,3) = DNSYZ(M1,PTHRD,M1)
      DER(1,4) = DNCX(M1,P1,M1)
      DER(2,4) = DNCY(M1,P1,M1)
      DER(3,4) = DNCZ(M1,P1,M1)
      DER(1,5) = DNSXX(MTHRD,P1,M1)
      DER(2,5) = DNSXY(MTHRD,P1,M1)
      DER(3,5) = DNSXZ(MTHRD,P1,M1)
      DER(1,6) = DNSXX(PTHRD,P1,M1)
      DER(2,6) = DNSXY(PTHRD,P1,M1)
      DER(3,6) = DNSXZ(PTHRD,P1,M1)
      DER(1,7) = DNCX(P1,P1,M1)
      DER(2,7) = DNCY(P1,P1,M1)
      DER(3,7) = DNCZ(P1,P1,M1)
      DER(1,8) = DNSYX(P1,PTHRD,M1)
      DER(2,8) = DNSYY(P1,PTHRD,M1)
      DER(3,8) = DNSYZ(P1,PTHRD,M1)
      DER(1,9) = DNSYX(P1,MTHRD,M1)
      DER(2,9) = DNSYY(P1,MTHRD,M1)
      DER(3,9) = DNSYZ(P1,MTHRD,M1)
      DER(1,10) = DNCX(P1,M1,M1)
      DER(2,10) = DNCY(P1,M1,M1)
      DER(3,10) = DNCZ(P1,M1,M1)
      DER(1,11) = DNSXX(PTHRD,M1,M1)
      DER(2,11) = DNSXY(PTHRD,M1,M1)
      DER(3,11) = DNSXZ(PTHRD,M1,M1)
      DER(1,12) = DNSXX(MTHRD,M1,M1)
      DER(2,12) = DNSXY(MTHRD,M1,M1)
      DER(3,12) = DNSXZ(MTHRD,M1,M1)
      DER(1,13) = DNSZX(M1,M1,MTHRD)
      DER(2,13) = DNSZY(M1,M1,MTHRD)
      DER(3,13) = DNSZZ(M1,M1,MTHRD)
      DER(1,14) = DNSZX(M1,P1,MTHRD)
      DER(2,14) = DNSZY(M1,P1,MTHRD)
      DER(3,14) = DNSZZ(M1,P1,MTHRD)
      DER(1,15) = DNSZX(P1,P1,MTHRD)
      DER(2,15) = DNSZY(P1,P1,MTHRD)
      DER(3,15) = DNSZZ(P1,P1,MTHRD)
      DER(1,16) = DNSZX(P1,M1,MTHRD)
      DER(2,16) = DNSZY(P1,M1,MTHRD)
      DER(3,16) = DNSZZ(P1,M1,MTHRD)
      DER(1,17) = DNSZX(M1,M1,PTHRD)
      DER(2,17) = DNSZY(M1,M1,PTHRD)
      DER(3,17) = DNSZZ(M1,M1,PTHRD)
      DER(1,18) = DNSZX(M1,P1,PTHRD)
      DER(2,18) = DNSZY(M1,P1,PTHRD)
      DER(3,18) = DNSZZ(M1,P1,PTHRD)
      DER(1,19) = DNSZX(P1,P1,PTHRD)
      DER(2,19) = DNSZY(P1,P1,PTHRD)
      DER(3,19) = DNSZZ(P1,P1,PTHRD)
      DER(1,20) = DNSZX(P1,M1,PTHRD)
      DER(2,20) = DNSZY(P1,M1,PTHRD)
      DER(3,20) = DNSZZ(P1,M1,PTHRD)
      DER(1,21) = DNCX(M1,M1,P1)
      DER(2,21) = DNCY(M1,M1,P1)
      DER(3,21) = DNCZ(M1,M1,P1)
      DER(1,22) = DNSYX(M1,MTHRD,P1)
      DER(2,22) = DNSYY(M1,MTHRD,P1)
      DER(3,22) = DNSYZ(M1,MTHRD,P1)
      DER(1,23) = DNSYX(M1,PTHRD,P1)
      DER(2,23) = DNSYY(M1,PTHRD,P1)
      DER(3,23) = DNSYZ(M1,PTHRD,P1)
      DER(1,24) = DNCX(M1,P1,P1)
      DER(2,24) = DNCY(M1,P1,P1)
      DER(3,24) = DNCZ(M1,P1,P1)
      DER(1,25) = DNSXX(MTHRD,P1,P1)
      DER(2,25) = DNSXY(MTHRD,P1,P1)
      DER(3,25) = DNSXZ(MTHRD,P1,P1)
      DER(1,26) = DNSXX(PTHRD,P1,P1)
      DER(2,26) = DNSXY(PTHRD,P1,P1)
      DER(3,26) = DNSXZ(PTHRD,P1,P1)
      DER(1,27) = DNCX(P1,P1,P1)
      DER(2,27) = DNCY(P1,P1,P1)
      DER(3,27) = DNCZ(P1,P1,P1)
      DER(1,28) = DNSYX(P1,PTHRD,P1)
      DER(2,28) = DNSYY(P1,PTHRD,P1)
      DER(3,28) = DNSYZ(P1,PTHRD,P1)
      DER(1,29) = DNSYX(P1,MTHRD,P1)
      DER(2,29) = DNSYY(P1,MTHRD,P1)
      DER(3,29) = DNSYZ(P1,MTHRD,P1)
      DER(1,30) = DNCX(P1,M1,P1)
      DER(2,30) = DNCY(P1,M1,P1)
      DER(3,30) = DNCZ(P1,M1,P1)
      DER(1,31) = DNSXX(PTHRD,M1,P1)
      DER(2,31) = DNSXY(PTHRD,M1,P1)
      DER(3,31) = DNSXZ(PTHRD,M1,P1)
      DER(1,32) = DNSXX(MTHRD,M1,P1)
      DER(2,32) = DNSXY(MTHRD,M1,P1)
      DER(3,32) = DNSXZ(MTHRD,M1,P1)
C
      END
C
      SUBROUTINE BRK8(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and derivatives
C      at a specified point for an 8-noded brick element.  the
C      function is continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.8)
C      IDER    first dimension of array DER (.ge.3)
C      JDER    second dimension of array DER (.ge.8)
C      XI      value of local coordinate at which function and
C              derivative values required
C      ETA     value of second local coordinate
C      ZETA    value of third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     real vector of dimension ifun.  fun(i) contains
C              value of i'th shape function at (xi,eta,zeta)
C      DER     real array of dimensions (ider,jder).  der(i,j)
C              contains the derivative of the j'th shape
C              function with respect to the i'th coordinate at
C              the point (xi,eta,zeta)
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE brk8(fun, IFUN, DER, IDER, JDER, XI, ETA, ZETA,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,ETA,ETAM,ETAP,FUN,HALF,VAL,VEPS,XI,XIM,
     *                 XIP,ZETA,ZETAM,ZETAP
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'BRK8'/, HALF/0.5D0/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.8) IERROR = 1
         IF (IDER.LT.3 .OR. JDER.LT.8) IERROR = 2
         VAL = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.VAL .OR. DABS(ETA).GT.VAL .OR.
     *       DABS(ZETA).GT.VAL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main code
C
      ETAM = (1.0D0-ETA)*HALF
      ETAP = (1.0D0+ETA)*HALF
      XIM = (1.0D0-XI)*HALF
      XIP = (1.0D0+XI)*HALF
      ZETAM = (1.0D0-ZETA)*HALF
      ZETAP = (1.0D0+ZETA)*HALF
C
C     Set shape functions
C
      FUN(1) = XIM*ETAM*ZETAM
      FUN(2) = XIM*ETAP*ZETAM
      FUN(3) = XIP*ETAP*ZETAM
      FUN(4) = XIP*ETAM*ZETAM
      FUN(5) = XIM*ETAM*ZETAP
      FUN(6) = XIM*ETAP*ZETAP
      FUN(7) = XIP*ETAP*ZETAP
      FUN(8) = XIP*ETAM*ZETAP
C
C     Set derivatves of shape functions
C
      DER(1,1) = -ETAM*ZETAM*HALF
      DER(1,2) = -ETAP*ZETAM*HALF
      DER(1,3) = ETAP*ZETAM*HALF
      DER(1,4) = ETAM*ZETAM*HALF
      DER(1,5) = -ETAM*ZETAP*HALF
      DER(1,6) = -ETAP*ZETAP*HALF
      DER(1,7) = ETAP*ZETAP*HALF
      DER(1,8) = ETAM*ZETAP*HALF
      DER(2,1) = -XIM*ZETAM*HALF
      DER(2,2) = XIM*ZETAM*HALF
      DER(2,3) = XIP*ZETAM*HALF
      DER(2,4) = -XIP*ZETAM*HALF
      DER(2,5) = -XIM*ZETAP*HALF
      DER(2,6) = XIM*ZETAP*HALF
      DER(2,7) = XIP*ZETAP*HALF
      DER(2,8) = -XIP*ZETAP*HALF
      DER(3,1) = -XIM*ETAM*HALF
      DER(3,2) = -XIM*ETAP*HALF
      DER(3,3) = -XIP*ETAP*HALF
      DER(3,4) = -XIP*ETAM*HALF
      DER(3,5) = XIM*ETAM*HALF
      DER(3,6) = XIM*ETAP*HALF
      DER(3,7) = XIP*ETAP*HALF
      DER(3,8) = XIP*ETAM*HALF
C
      END
C
      SUBROUTINE CHOBAK(A,IA,JA,R,IR,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      performs bakward substitution on A matrix processed by
C      chordn and chofwd
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja).  contains the
C              elements of the lower half of the positive
C              definite band matrix of order N and with semi-
C              bandwidth HBAND, reduced by chordn or chosol
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.hband)
C      R       on entry, contains elements of N rhs's after
C              processing by chofwd
C      IR      dimension of vector R (.ge.n)
C      N       order of matrix A
C      HBAND   semi-bandwidth of matrix A
C      ITEST   error checking option
C
C ARGUMENTS out
C      R       on exit, contains solution vector
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE chobak(a, IA, JA, R, IR, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IERROR,IJ,IR,ITEST,J,JA,L,M,N,W
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,R,X
      DIMENSION A(IA,JA),R(IR)
      DATA SRNAME/'CHOBAK'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IR.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = HBAND - 1
      R(N) = R(N)/A(N,W+1)
      I = N - 1
 1000 CONTINUE
      X = 0.0D0
      L = I + W
      IF (I.GT.N-W) L = N
      M = I + 1
      DO 1010 J = M,L
         IJ = W + I - J + 1
         X = X + A(J,IJ)*R(J)
 1010 CONTINUE
      R(I) = (R(I)-X)/A(I,W+1)
      I = I - 1
      IF (I.NE.0) GO TO 1000
C
      END
C
      SUBROUTINE CHOFWD(A,IA,JA,R,IR,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      performs forward substitution on A matrix reduced by
C      chordn
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja).  contains the
C              elements of the lower half of the positive
C              definite symmetric band matrix of order N and
C              semi-bandwidth hband.  A should previously have
C              been reduced using chordn or chosol
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.hband)
C      R       on entry, contains the vector of rhs's
C      IR      dimension of R (.ge.n)
C      N       order of matrix A
C      HBAND   semi-bandwidth of A
C      ITEST   error checking option
C
C ARGUMENTS out
C      R       on exit, contains the reduced vector of rhs's
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE chofwd(a, IA, JA, R, IR, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IERROR,IJ,IR,ITEST,J,JA,K,N,W
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,R,X
      DIMENSION A(IA,JA),R(IR)
      DATA SRNAME/'CHOFWD'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IR.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = HBAND - 1
      R(1) = R(1)/A(1,W+1)
      DO 1010 I = 2,N
         X = 0.0D0
         K = 1
         IF (I.LE.W+1) K = W - I + 2
         DO 1000 J = K,W
            IJ = I + J - W - 1
            X = X + A(I,J)*R(IJ)
 1000    CONTINUE
         R(I) = (R(I)-X)/A(I,W+1)
 1010 CONTINUE
C
      END
C
      SUBROUTINE CHORDN(A,IA,JA,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      performs choleski reduction on A real symmetric positive
C      definite banded matrix.  only the lower band and
C      diagonal are stored in A rectangular array A
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1    29 Oct 1979 (ims)
C      Commented      12 Feb 1980 (CG)
C      checking added 12 Feb 1980 (KR)
C
C ARGUMENTS in
C      A       on entry, contains lower band and diagonal of
C              pd real symmetric matrix
C      IA      first dimension of A (.GE. N)
C      JA      second dimension of A (.GE. HBAND)
C      N       order of matrix A
C      HBAND   semi-bandwidth of A (including diagonal)
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       reduced matrix L, where the input matrix A has
C              been reduced to triangular matrices L and lt
C              where a=l lt
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE chordn(a, IA, JA, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IERROR,IK,ITEST,J,JA,JTEST,K,L,LA,LB,LK,
     *        N,W
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,X
      DIMENSION A(IA,JA)
      DATA SRNAME/'CHORDN'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = HBAND - 1
      DO 1030 I = 1,N
         X = 0.0D0
         DO 1000 J = 1,W
            X = X + A(I,J)*A(I,J)
 1000    CONTINUE
C
C     Check on value of a(i,j)
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF ((A(I,W+1)-X).LE.0.0D0) IERROR = 3
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
         A(I,W+1) = DSQRT(A(I,W+1)-X)
C
         DO 1020 K = 1,W
            X = 0.0D0
            IF (I+K.LE.N) THEN
               IF (K.NE.W) THEN
                  L = W - K
 1010             CONTINUE
                  IK = I + K
                  LK = L + K
                  X = X + A(IK,L)*A(I,LK)
                  L = L - 1
                  IF (L.NE.0) GO TO 1010
               END IF
               LA = I + K
               LB = W - K + 1
               A(LA,LB) = (A(LA,LB)-X)/A(I,W+1)
            END IF
 1020    CONTINUE
 1030 CONTINUE
C
      END
C
      SUBROUTINE CHOSOL(A,IA,JA,R,IR,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      solves A set of real symmetric positive definite banded
C      equations with A single right hand side by choleski
C      decomposition.  only the lower band and diagonal are
C      stored in A rectangular array A
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    12 Feb 1980 (KR)
C
C ARGUMENTS in
C      A       on entry contains lower half of pd symmetric
C              band matrix stored as A rectangular array
C      IA      first dimension of A (.GE. N)
C      JA      second dimension of A (.GE. HBAND)
C      R       contains elements of right hand side
C      IR      dimension of R (.GE. N)
C      N       order of matrix A
C      HBAND   semi-bandwidth of A (includes diagonal)
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       on exit, contains lower triangular reduced
C      R       matrix solution vector
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE chosol(a, IA, JA, R, IR, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IERROR,IJ,IK,IR,ITEST,J,JA,JTEST,K,L,LA,
     *        LB,LK,M,N,W
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,R,X
      DIMENSION A(IA,JA),R(IR)
      DATA SRNAME/'CHOSOL'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IR.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = HBAND - 1
      DO 1030 I = 1,N
         X = 0.0D0
         DO 1000 J = 1,W
            X = X + A(I,J)*A(I,J)
 1000    CONTINUE
C
C     Range checking on a(i,w+1)
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF ((A(I,W+1)-X).LE.0.0D0) IERROR = 4
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
         A(I,W+1) = DSQRT(A(I,W+1)-X)
C
         DO 1020 K = 1,W
            X = 0.0D0
            IF (I+K.LE.N) THEN
               IF (K.NE.W) THEN
                  L = W - K
 1010             CONTINUE
                  IK = I + K
                  LK = L + K
                  X = X + A(IK,L)*A(I,LK)
                  L = L - 1
                  IF (L.NE.0) GO TO 1010
               END IF
               LA = I + K
               LB = W - K + 1
               A(LA,LB) = (A(LA,LB)-X)/A(I,W+1)
            END IF
 1020    CONTINUE
 1030 CONTINUE
      R(1) = R(1)/A(1,W+1)
      DO 1050 I = 2,N
         X = 0.0D0
         K = 1
         IF (I.LE.W+1) K = W - I + 2
         DO 1040 J = K,W
            IJ = I + J - W - 1
            X = X + A(I,J)*R(IJ)
 1040    CONTINUE
         R(I) = (R(I)-X)/A(I,W+1)
 1050 CONTINUE
      R(N) = R(N)/A(N,W+1)
      I = N - 1
 1060 CONTINUE
      X = 0.0D0
      L = I + W
      IF (I.GT.N-W) L = N
      M = I + 1
      DO 1070 J = M,L
         IJ = W + I - J + 1
         X = X + A(J,IJ)*R(J)
 1070 CONTINUE
      R(I) = (R(I)-X)/A(I,W+1)
      I = I - 1
      IF (I.NE.0) GO TO 1060
C
      END
C
      SUBROUTINE CHOSUB(A,IA,JA,R,IR,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      performs forward and backward substitution on A matrix
C      reduced by chordn
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja).  contains the
C              elements of the lower half of the positive
C              definite symmetric band matrix of order N and
C              semi-bandwidth hband.  A should previously have
C              been reduced using chordn or chosol
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.hband)
C      R       on entry, contains the vector of rhs's
C      IR      dimension of R (.ge.n)
C      N       order of matrix A
C      HBAND   semi-bandwidth of A
C      ITEST   error checking option
C
C ARGUMENTS out
C      R       on exit, contains the solution vector
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE chosub(a, IA, JA, R, IR, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IERROR,IJ,IR,ITEST,J,JA,K,L,M,N,W
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,R,X
      DIMENSION A(IA,JA),R(IR)
      DATA SRNAME/'CHOSUB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IR.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = HBAND - 1
      R(1) = R(1)/A(1,W+1)
      DO 1010 I = 2,N
         X = 0.0D0
         K = 1
         IF (I.LE.W+1) K = W - I + 2
         DO 1000 J = K,W
            IJ = I + J - W - 1
            X = X + A(I,J)*R(IJ)
 1000    CONTINUE
         R(I) = (R(I)-X)/A(I,W+1)
 1010 CONTINUE
      R(N) = R(N)/A(N,W+1)
      I = N - 1
 1020 CONTINUE
      X = 0.0D0
      L = I + W
      IF (I.GT.N-W) L = N
      M = I + 1
      DO 1030 J = M,L
         IJ = W + I - J + 1
         X = X + A(J,IJ)*R(J)
 1030 CONTINUE
      R(I) = (R(I)-X)/A(I,W+1)
      I = I - 1
      IF (I.NE.0) GO TO 1020
C
      END
C
      SUBROUTINE CMTNUL(A,IA,JA,M,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      sets complex matrix A to the null matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  20 Oct 1984 (crie)
C      comments      1 Nov 1985 (CG)
C
C ARGUMENTS in
C      IA      first dimension of array A (.ge.m)
C      JA      second dimension of array A (.ge.n)
C      M       number of rows of A to be set to zero
C      N       number of columns of A to be set to zero
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       array of dimension (2,ia,ja).  a(1,i,j)=0
C              and a(2,i,j)=0 for
C              i=1(1)m and j=1(1)n
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE cmtnul(a, IA, JA, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IERROR,ITEST,J,JA,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A
      DIMENSION A(2,IA,JA)
      DATA SRNAME/'CMTNUL'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1010 I = 1,M
         DO 1000 J = 1,N
            A(1,I,J) = 0.0D0
            A(2,I,J) = 0.0D0
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE CPRTMT(A,IA,JA,M,N,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints A complex matrix in A standard format
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0   29 Oct 1984 (crie)
C      comments       1 Nov 1985  (CG)
C
C ARGUMENTS in
C      A       matrix of dimension 2,ia,ja containing numbers to be
C              printed
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      M       number of rows of A to be printed (.le.ia)
C      N       number of columes of A to be printed (.le.ja)
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE cprtmt(a, IA, JA, M, N, NOUT, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IA,M,N,NOUT,J,JA,K
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A
      DIMENSION A(2,IA,JA)
      DATA SRNAME/'CPRTMT'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IA.LT.M .OR. JA.LT.N) IERROR = 2
         IF (N.LE.0 .OR. M.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      WRITE (NOUT,FMT=9990) (((A(I,J,K),I=1,2),J=1,M),K=1,N)
C
 9990 FORMAT (' ',3 (2X,2D12.4))
      END
C
      SUBROUTINE CPRTVC(V,IV,N,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints a complex vector in a standard format
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0   29 Oct 1984 (crie)
C      comments       1 Nov 1985  (CG)
C
C ARGUMENTS in
C      V       vector of dimension 2,iv containing numbers to be
C              printed
C      IV      dimension of V (.ge.n)
C      N       number of elements of V to be printed
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE cprtvc(v, IV, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IV,N,NOUT,J
      CHARACTER*6 SRNAME
      DOUBLE PRECISION V
      DIMENSION V(2,IV)
      DATA SRNAME/'CPRTVC'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IV.LT.N) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      WRITE (NOUT,FMT=9990) ((V(I,J),I=1,2),J=1,N)
C
 9990 FORMAT (' ',3 (2X,2D12.4))
      END
C
      SUBROUTINE CPRTVL(VAL,IVAL,NF,INF,JNF,DOFNOD,TOTNOD,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints out the nodal values of the solution in a
C      standard format
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  20 Jan 1984 (CRIE)
C      Commented     1 Nov 1985 (CG)
C
C ARGUMENTS in
C      VAL     complex vector of dimension 2*ival containing
C              solution values,and prescribed boundary values
C      IVAL    dimension of VAL (.ge.total number of freedoms
C              in system)
C      NF      integer array of dimension (inf,jnf) containing
C              freedom numbers associated with each NODE
C      INF     first dimension of NF (.ge.totnod)
C      JNF     second dimension of NF (.ge.dofnod)
C      DOFNOD  number of degrees of freedom at each NODE
C      TOTNOD  total number of nodes in mesh
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE cprtvl(val, IVAL, NF, INF, JNF, DOFNOD,
C    *      TOTNOD, NOUT, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFNOD,ERRMES,I,IERROR,INF,ITEST,IVAL,J,JNF,K,L,NODE,NOUT,
     *        TOTNOD,N,NF
      CHARACTER*6 SRNAME
      DOUBLE PRECISION VAL,WORK
      DIMENSION VAL(2,IVAL),WORK(2,10),NF(INF,JNF),NODE(2)
      DATA SRNAME/'CPRTVL'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (INF.LT.TOTNOD .OR. JNF.LT.DOFNOD) IERROR = 2
         IF (DOFNOD.LE.0 .OR. TOTNOD.LE.0 .OR. NOUT.LE.0) IERROR = 1
         IF (DOFNOD.GT.10) IERROR = 1
         ITEST = ERRMES(IERROR,ITEST,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      IF (DOFNOD.EQ.1) THEN
C
C     For dofnod=1
C
         WRITE (NOUT,FMT=9920)
         N = 0
         DO 1000 I = 1,TOTNOD
            N = N + 1
            NODE(N) = I
            K = NF(I,1)
            WORK(1,N) = 0.0D0
            WORK(2,N) = 0.0D0
            IF (K.NE.0) THEN
               WORK(1,N) = VAL(1,K)
               WORK(2,N) = VAL(2,K)
            END IF
            IF (N.EQ.2) THEN
               WRITE (NOUT,FMT=9910) (NODE(J),WORK(1,J),WORK(2,J),J=1,
     *            2)
               N = 0
            END IF
 1000    CONTINUE
         IF (N.NE.0) WRITE (NOUT,FMT=9910) NODE(1),WORK(1,1),WORK(2,1)
      ELSE
         WRITE (NOUT,FMT=9990)
         DO 1080 I = 1,TOTNOD
            DO 1010 J = 1,DOFNOD
               K = NF(I,J)
               WORK(1,J) = 0.0D0
               WORK(2,J) = 0.0D0
               IF (K.NE.0) THEN
                  WORK(1,J) = VAL(1,K)
                  WORK(2,J) = VAL(2,K)
               END IF
 1010       CONTINUE
C
C     Select number of degrees of freedom
C
            GO TO (1080,1020,1060,1030,1060,1040,1060,1050,
     *             1060,1070) DOFNOD
            GO TO 1060
 1020       CONTINUE
            WRITE (NOUT,FMT=9970) I, (WORK(1,L),WORK(2,L),L=1,DOFNOD)
            GO TO 1080
 1030       CONTINUE
            WRITE (NOUT,FMT=9960) I, (WORK(1,L),WORK(2,L),L=1,DOFNOD)
            GO TO 1080
 1040       CONTINUE
            WRITE (NOUT,FMT=9950) I, (WORK(1,L),WORK(2,L),L=1,DOFNOD)
            GO TO 1080
 1050       CONTINUE
            WRITE (NOUT,FMT=9940) I, (WORK(1,L),WORK(2,L),L=1,DOFNOD)
            GO TO 1080
 1060       CONTINUE
            WRITE (NOUT,FMT=9980) I, (WORK(1,L),WORK(2,L),L=1,DOFNOD)
            GO TO 1080
 1070       CONTINUE
            WRITE (NOUT,FMT=9930) I, (WORK(1,L),WORK(2,L),L=1,DOFNOD)
 1080    CONTINUE
      END IF
C
 9990 FORMAT (/' ','NODE',6X,2 ('REAL',7X,'IMAGINARY',16X),/' ')
 9980 FORMAT (' ',I4,2X,2 (D12.5,2X),8X,2 (D12.5,2X),
     *       8 (/' ',6X,2 (D12.5,2X),8X,2 (D12.5,2X)))
 9970 FORMAT (' ',I4,2X,2 (D12.5,2X),8X,2 (D12.5,2X))
 9960 FORMAT (' ',I4,2X,2 (D12.5,2X),8X,2 (D12.5,2X),
     *       1 (/' ',6X,2 (D12.5,2X),8X,2 (D12.5,2X)))
 9950 FORMAT (' ',I4,2X,2 (D12.5,2X),8X,2 (D12.5,2X),
     *       2 (/' ',6X,2 (D12.5,2X),8X,2 (D12.5,2X)))
 9940 FORMAT (' ',I4,2X,2 (D12.5,2X),8X,2 (D12.5,2X),
     *       3 (/' ',6X,2 (D12.5,2X),8X,2 (D12.5,2X)))
 9930 FORMAT (' ',I4,2X,2 (D12.5,2X),8X,2 (D12.5,2X),
     *       4 (/' ',6X,2 (D12.5,2X),8X,2 (D12.5,2X)))
 9920 FORMAT (/' ',2 ('NODE',6X,'REAL',7X,'IMAGINARY',6X),/' ')
 9910 FORMAT (2 (' ',I4,2X,2 (D12.5,2X),1X))
      END
C
      SUBROUTINE CSYBAK(KB,IKB,JKB,LOADS,ILOADS,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      performs bakward substitution on a matrix processed by
C      chordn and chofwd
C
C HISTORY
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      KB      array of dimension (ikb,jkb).  contains the
C              elements of the lower half of the positive
C              definite band matrix of order N and with semi-
C              bandwidth HBAND, reduced by chordn or chosol
C      IKB     first dimension of KB (.ge.n)
C      jakb    second dimension of KB (.ge.hband)
C      LOADS   on entry, contains elements of N rhs's after
C              processing by chofwd
C      ILOADS  dimension of vector LOADS (.ge.n)
C      N       order of matrix KB
C      HBAND   semi-bandwidth of matrix a
C      ITEST   error checking option
C
C ARGUMENTS out
C      LOADS   on exit, contains solution vector
C
C ROUTINES called
C      ERRMES
C
C
      INTEGER HBAND,I,IKB,ITEST,J,JKB,K,L,W,M,IJ,N,IERROR,ERRMES,ILOADS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION KB,X,LOADS,Y,AR,AI,XR,XI
      DIMENSION KB(2,IKB,JKB),LOADS(2,ILOADS)
      DATA SRNAME/'CSYBAK'/
C
C
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ILOADS.LT.N) IERROR = 3
         IF (IKB.LT.N .OR. JKB.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      W = HBAND - 1
      X = LOADS(1,1)
      Y = LOADS(2,1)
      AR = KB(1,1,W+1)
      AI = KB(2,1,W+1)
      IF (DABS(AR).GT.DABS(AI)) THEN
         LOADS(1,1) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
         LOADS(2,1) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
      ELSE
         LOADS(1,1) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
         LOADS(2,1) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
      END IF
      DO 1010 I = 2,N
         XR = 0.0D0
         XI = 0.0D0
         K = 1
         IF (I.LE.W+1) K = W - I + 2
         DO 1000 J = K,W
            IJ = I + J - W - 1
            X = KB(1,I,J)
            Y = KB(2,I,J)
            AR = LOADS(1,IJ)
            AI = LOADS(2,IJ)
            XR = XR + X*AR - Y*AI
            XI = XI + X*AI*Y*AR
 1000    CONTINUE
         X = LOADS(1,I) - XR
         Y = LOADS(2,I) - XI
         AR = KB(1,I,W+1)
         AI = KB(2,I,W+1)
         IF (DABS(AR).GT.DABS(AI)) THEN
            LOADS(1,I) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
            LOADS(2,I) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
         ELSE
            LOADS(1,I) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
            LOADS(2,I) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
         END IF
 1010 CONTINUE
      X = LOADS(1,N)
      Y = LOADS(2,N)
      AR = KB(1,N,W+1)
      AI = KB(2,N,W+1)
      IF (DABS(AR).GT.DABS(AI)) THEN
         LOADS(1,N) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
         LOADS(2,N) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
      ELSE
         LOADS(1,N) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
         LOADS(2,N) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
      END IF
      I = N - 1
 1020 CONTINUE
      XR = 0.0D0
      XI = 0.0D0
      L = I + W
      IF (I.GT.N-W) L = N
      M = I + 1
      DO 1030 J = M,L
         IJ = W + I - J + 1
         X = KB(1,J,IJ)
         Y = KB(2,J,IJ)
         AR = LOADS(1,J)
         AI = LOADS(2,J)
         XR = XR + X*AR - Y*AI
         XI = XI + X*AI + Y*AR
 1030 CONTINUE
      X = LOADS(1,I) - XR
      Y = LOADS(2,I) - XI
      AR = KB(1,I,W+1)
      AI = KB(2,I,W+1)
      IF (DABS(AR).GT.DABS(AI)) THEN
         LOADS(1,I) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
         LOADS(2,I) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
      ELSE
         LOADS(1,I) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
         LOADS(2,I) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
      END IF
      I = I - 1
      IF (I.NE.0) GO TO 1020
      END
C
      SUBROUTINE CSYRDN(KB,IKB,JKB,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      performs symmetric reduction on A complex symmetric banded
C      banded matrix.  only the lower band and diagonal are stored
C      in A rectangular array KB
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1984 (crie)
C      Commented     1 Nov 1985 (CG)
C
C ARGUMENTS in
C      KB      on entry, contains lower band and diagonal of
C              complex symmetric matrix
C      IKB     first dimension of KB (.GE. N)
C      JKB     second dimension of KB (.GE. HBAND)
C      N       order of matrix KB
C      HBAND   semi-bandwidth of KB  (including diagonal)
C      ITEST   error checking option
C
C ARGUMENTS out
C      KB      reduced matrix L, where the input matrix KB  has
C              been reduced to triangular matrices L and lt
C              where KB =l lt
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE csyrdn(kb, IKB, JKB, N, HBAND, ITEST)
C**********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER A,B,HBAND,I,IK,IKB,ITEST,J,JKB,K,L,W,LK,N,IERROR,ERRMES
      CHARACTER*6 SRNAME
      DOUBLE PRECISION KB,X,Y,AR,AI,XR,XI
      DIMENSION KB(2,IKB,JKB)
      DATA SRNAME/'CSYRDN'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IKB.LT.N .OR. JKB.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      W = HBAND - 1
      DO 1030 I = 1,N
         XR = 0.0D00
         XI = 0.0D00
         DO 1000 J = 1,W
            X = KB(1,I,J)
            Y = KB(2,I,J)
            XR = XR + X*X - Y*Y
            XI = XI + X*Y*2.0D0
 1000    CONTINUE
C
         IF (ITEST.NE.-1) THEN
            IERROR = 0
            X = KB(1,I,W+1) - XR
            Y = KB(2,I,W+1) - XI
            IF (DSQRT(X*X+Y*Y).LE.0.0D00) IERROR = 3
            ITEST = ERRMES(ITEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
         IF (KB(1,I,W+1)-XR.GE.0.0D00) THEN
            AR = KB(1,I,W+1) - XR
            AI = KB(2,I,W+1) - XI
            X = DSQRT((AR+DSQRT(AR*AR+AI*AI))/2.0D0)
            Y = 0.0D0
            IF (X.GT.0.0D0) Y = AI/ (2.0D0*X)
            KB(1,I,W+1) = X
            KB(2,I,W+1) = Y
         ELSE
            AR = KB(1,I,W+1) - XR
            AI = KB(2,I,W+1) - XI
            Y = DSIGN(1.0D0,AI)*DSQRT((DABS(AR)+DSQRT(AR*AR+AI*AI))/
     *          2.0D0)
            X = 0.0D0
            IF (Y.GT.0.0D0) X = AI/ (2.0D0*Y)
            KB(1,I,W+1) = X
            KB(2,I,W+1) = Y
         END IF
         DO 1020 K = 1,W
            XR = 0.0D0
            XI = 0.0D0
            IF (I+K.LE.N) THEN
               IF (K.NE.W) THEN
                  L = W - K
 1010             CONTINUE
                  IK = I + K
                  LK = L + K
                  X = KB(1,IK,L)
                  Y = KB(2,IK,L)
                  AR = KB(1,I,LK)
                  AI = KB(2,I,LK)
                  XR = XR + X*AR - Y*AI
                  XI = XI + X*AI + Y*AR
                  L = L - 1
                  IF (L.NE.0) GO TO 1010
               END IF
               A = I + K
               B = W - K + 1
               X = KB(1,A,B) - XR
               Y = KB(2,A,B) - XI
               AR = KB(1,I,W+1)
               AI = KB(2,I,W+1)
               IF (DABS(AR).GT.DABS(AI)) THEN
                  KB(1,A,B) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
                  KB(2,A,B) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
               ELSE
                  KB(1,A,B) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
                  KB(2,A,B) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
               END IF
            END IF
 1020    CONTINUE
 1030 CONTINUE
C
      END
C
      SUBROUTINE CSYSOL(KB,IKB,JKB,LOADS,ILOADS,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      solves a set of complex symmetric banded equations with a
C      single right hand side using a symmetric decomposition.  only
C      the lower band and diagonal are stored in a rectangular array kb.
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1979 (crie)
C      Commented    12 Feb 1985 (CG)
C
C ARGUMENTS in
C      KB      on entry contains lower half of complex symmetric
C              band matrix stored as a rectangular array
C      IKB     first dimension of KB (.GE. N)
C      JKB     second dimension of KB (.GE. HBAND)
C      LOADS   contains elements of right hand side
C      ILOADS  dimension of LOADS (.GE. N)
C      N       order of matrix KB
C      HBAND   semi-bandwidth of KB (includes diagonal)
C      ITEST   error checking option
C
C ARGUMENTS out
C      KB      on exit, contains lower triangular reduced
C      LOADS   matrix solution vector
C
C ROUTINES called
C      ERRMES, CSYRDN, CSYSUB
C
C     SUBROUTINE csysol(kb, IKB, JKB, LOADS, ILOADS, N, HBAND,
C    *     ITEST)
C*************************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER HBAND,IKB,ITEST,JKB,JTEST,IERROR,N,ERRMES,ILOADS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION KB,LOADS
      DIMENSION KB(2,IKB,JKB),LOADS(2,ILOADS)
      DATA SRNAME/'CSYSOL'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ILOADS.LT.N) IERROR = 3
         IF (IKB.LT.N .OR. JKB.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      JTEST = 1
      CALL CSYRDN(KB,IKB,JKB,N,HBAND,JTEST)
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = JTEST
         IF (JTEST.EQ.3) IERROR = 4
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      CALL CSYSUB(KB,IKB,JKB,LOADS,ILOADS,N,HBAND,JTEST)
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = JTEST
         IF (JTEST.EQ.3) IERROR = 4
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C
      END
C
      SUBROUTINE CSYSUB(KB,IKB,JKB,LOADS,ILOADS,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      performs forward and backward substitution on a matrix
C      reduced by csyrdn
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1984 (crie)
C      Commented    10 Oct 1985 (CG)
C
C ARGUMENTS in
C      KB      array of dimension (ikb,jkb).  contains the
C              elements of the lower half of the complex symmetric
C              band matrix of order N and semi-bandwidth hband. KB
C              should previously have been reduced using csysol or csyrdn.
C      IKB     first dimension of KB (.ge.n)
C      JKB     second dimension of KB (.ge.hband)
C      LOADS   on entry, contains the vector of rhs's
C      ILOADS  dimension of LOADS (.ge.n)
C      N       order of matrix KB
C      HBAND   semi-bandwidth of KB
C      ITEST   error checking option
C
C ARGUMENTS out
C      LOADS   on exit, contains the solution vector
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE csysub(kb, IKB, JKB, LOADS, ILOADS, N, HBAND,
C    *     ITEST)
C**********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER HBAND,I,IKB,ITEST,J,JKB,K,L,W,M,IJ,N,IERROR,ERRMES,ILOADS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION KB,X,LOADS,Y,AR,AI,XR,XI
      DIMENSION KB(2,IKB,JKB),LOADS(2,ILOADS)
      DATA SRNAME/'CSYSUB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ILOADS.LT.N) IERROR = 3
         IF (IKB.LT.N .OR. JKB.LT.HBAND) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = HBAND - 1
      X = LOADS(1,1)
      Y = LOADS(2,1)
      AR = KB(1,1,W+1)
      AI = KB(2,1,W+1)
      IF (DABS(AR).GT.DABS(AI)) THEN
         LOADS(1,1) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
         LOADS(2,1) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
      ELSE
         LOADS(1,1) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
         LOADS(2,1) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
      END IF
      DO 1010 I = 2,N
         XR = 0.0D0
         XI = 0.0D0
         K = 1
         IF (I.LE.W+1) K = W - I + 2
         DO 1000 J = K,W
            IJ = I + J - W - 1
            X = KB(1,I,J)
            Y = KB(2,I,J)
            AR = LOADS(1,IJ)
            AI = LOADS(2,IJ)
            XR = XR + X*AR - Y*AI
            XI = XI + X*AI + Y*AR
 1000    CONTINUE
         X = LOADS(1,I) - XR
         Y = LOADS(2,I) - XI
         AR = KB(1,I,W+1)
         AI = KB(2,I,W+1)
         IF (DABS(AR).GT.DABS(AI)) THEN
            LOADS(1,I) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
            LOADS(2,I) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
         ELSE
            LOADS(1,I) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
            LOADS(2,I) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
         END IF
 1010 CONTINUE
      X = LOADS(1,N)
      Y = LOADS(2,N)
      AR = KB(1,N,W+1)
      AI = KB(2,N,W+1)
      IF (DABS(AR).GT.DABS(AI)) THEN
         LOADS(1,N) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
         LOADS(2,N) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
      ELSE
         LOADS(1,N) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
         LOADS(2,N) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
      END IF
      I = N - 1
 1020 CONTINUE
      XR = 0.0D0
      XI = 0.0D0
      L = I + W
      IF (I.GT.N-W) L = N
      M = I + 1
      DO 1030 J = M,L
         IJ = W + I - J + 1
         X = KB(1,J,IJ)
         Y = KB(2,J,IJ)
         AR = LOADS(1,J)
         AI = LOADS(2,J)
         XR = XR + X*AR - Y*AI
         XI = XI + X*AI + Y*AR
 1030 CONTINUE
      X = LOADS(1,I) - XR
      Y = LOADS(2,I) - XI
      AR = KB(1,I,W+1)
      AI = KB(2,I,W+1)
      IF (DABS(AR).GT.DABS(AI)) THEN
         LOADS(1,I) = (X+ (AI/AR)*Y)/ ((AI/AR)*AI+AR)
         LOADS(2,I) = (Y- (AI/AR)*X)/ ((AI/AR)*AI+AR)
      ELSE
         LOADS(1,I) = ((AR/AI)*X+Y)/ ((AR/AI)*AR+AI)
         LOADS(2,I) = ((AR/AI)*Y-X)/ ((AR/AI)*AR+AI)
      END IF
      I = I - 1
      IF (I.NE.0) GO TO 1020
C
      END
C
      SUBROUTINE CVCNUL(VEC,IVEC,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      sets the first N elements of a complex vector to zero
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1984 (crie)
C      Commented    23 Oct 1985 (CG)
C
C ARGUMENTS in
C      iv      length of vector v (.ge.n)
C      N       number of elements to be set to zero
C      ITEST   error checking option
C
C ARGUMENTS out
C      v       vector of length iv.  v(1,i)=0.0d0 and v(2,i)=0.0d0
C              for i=1(1)n
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE cvcnul(vec, IVEC, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IVEC,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION VEC
      DIMENSION VEC(2,IVEC)
      DATA SRNAME/'CVCNUL'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IVEC) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
C
C     Main loops
C
         IF (IERROR.NE.0) RETURN
      END IF
      DO 1000 I = 1,N
         VEC(1,I) = 0.0D0
         VEC(2,I) = 0.0D0
 1000 CONTINUE
C
      END
C
      SUBROUTINE DAXI(D,ID,JD,E,NU,NUMSS,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms the 4 by 4 stress-strain matrix for use in
C      axisymmetric isotropic problems
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    13 Feb 1980 (KR)
C
C ARGUMENTS in
C      ID      first dimension of matrix D (.GE. 4)
C      JD      second dimension of D (.GE. 4)
C      E       young's modulus
C      NU      poisson's ratio
C      ITEST   error checking option
C
C ARGUMENTS out
C      D       stress-strain matrix
C      NUMSS   order of stress-strain matrix, 4 in this case
C
C ROUTINES called
C      MATNUL  ERRMES
C
C
C     SUBROUTINE daxi(d, ID, JD, E, NU, NUMSS, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,ID,IERROR,ITEST,J,JD,NUMSS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION D,E,NU,NU1,NUNU
      DIMENSION D(ID,JD)
      DATA SRNAME/'DAXI'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (NU.LT.0.0D0 .OR. NU.GE.0.5D0) IERROR = 2
         IF (ID.LT.NUMSS .OR. JD.LT.NUMSS) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      NUMSS = 4
C
C     Initialise D matrix
C
      CALL MATNUL(D,ID,JD,NUMSS,NUMSS,ITEST)
C
      NU1 = NU/ (1.0D0-NU)
      NUNU = 0.5D0* (1.0D0-2.0D0*NU)/ (1.0D0-NU)
C
      D(1,1) = 1.0D0
      D(2,2) = 1.0D0
      D(3,3) = NUNU
      D(4,4) = 1.0D0
      D(1,2) = NU1
      D(2,1) = NU1
      D(1,4) = NU1
      D(4,1) = NU1
      D(2,4) = NU1
      D(4,2) = NU1
C
      DO 1010 I = 1,4
         DO 1000 J = 1,4
            D(I,J) = D(I,J)*E* (1.0D0-NU)/
     *               ((1.0D0-2.0D0*NU)* (1.0D0+NU))
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE DCSBRK(JACIN,IJACIN,JJACIN,FACNUM,COSIN,ICOSIN,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates the direction cosines of the outward normal
C      to the specified face of a hexahedral element given the
C      jacobian inverse
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1 Feb 1981 (CG)
C      Commented    1 Feb 1981 (CG)
C
C ARGUMENTS in
C      JACIN   array of dimension (ijacin,jjacin). contains the
C              inverse of the transformation jacobian.
C      IJACIN  first dimension of JACIN (.ge.3)
C      JJACIN  second dimension of JACIN (.ge.3)
C      FACNUM  the side number for which the outward normal
C              is required (.le.6)
C      ICOSIN  dimension of vector COSIN (.ge.3)
C      ITEST   error checking option
C
C ARGUMENTS out
C      COSIN   vector of dimension icosin. contains the dir-
C              ection cosines of the outward normal
C
C ROUTINES called
C      ERRMES  MATVEC
C
C
C     SUBROUTINE dcsbrk(jacin, IJACIN, JJACIN, FACNUM, COSIN,
C    *     ICOSIN, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DIMEN,ERRMES,FACNUM,ICOSIN,IERROR,IJACIN,ITEST,IWORK,
     *        JJACIN
      CHARACTER*6 SRNAME
      DOUBLE PRECISION AMOD,COSIN,JACIN,WORK
      DIMENSION COSIN(ICOSIN),JACIN(IJACIN,JJACIN),WORK(3)
      DATA DIMEN/3/,IWORK/3/,SRNAME/8H DCSBRK /
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IJACIN.LT.3 .OR. JJACIN.LT.3) IERROR = 3
         IF (ICOSIN.LT.3) IERROR = 2
         IF (FACNUM.LE.0 .OR. FACNUM.GT.6) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      GO TO (1000,1010,1020,1030,1040,1050) FACNUM
      GO TO 1020
C
C     Face number 1 : zeta = -1
C
 1000 CONTINUE
      WORK(1) = 0.0D0
      WORK(2) = 0.0D0
      WORK(3) = -1.0D0
      GO TO 1060
C
C     Face number 2 : zeta = +1
C
 1010 CONTINUE
      WORK(1) = 0.0D0
      WORK(2) = 0.0D0
      WORK(3) = 1.0D0
      GO TO 1060
C
C     Face number 3 : xi = -1
C
 1020 CONTINUE
      WORK(1) = -1.0D0
      WORK(2) = 0.0D0
      WORK(3) = 0.0D0
      GO TO 1060
C
C     Face number 4 : eta = +1
C
 1030 CONTINUE
      WORK(1) = 0.0D0
      WORK(2) = 1.0D0
      WORK(3) = 0.0D0
      GO TO 1060
C
C     Face number 5 : xi = +1
C
 1040 CONTINUE
      WORK(1) = 1.0D0
      WORK(2) = 0.0D0
      WORK(3) = 0.0D0
      GO TO 1060
C
C     Face number 6 : eta = -1
C
 1050 CONTINUE
      WORK(1) = 0.0D0
      WORK(2) = -1.0D0
      WORK(3) = 0.0D0
C
C     Calculate direction cosines
C
 1060 CONTINUE
      CALL MATVEC(JACIN,IJACIN,JJACIN,WORK,IWORK,DIMEN,DIMEN,COSIN,
     *            ICOSIN,ITEST)
      AMOD = DSQRT(COSIN(1)*COSIN(1)+COSIN(2)*COSIN(2)+
     *       COSIN(3)*COSIN(3))
      COSIN(1) = COSIN(1)/AMOD
      COSIN(2) = COSIN(2)/AMOD
      COSIN(3) = COSIN(3)/AMOD
C
      END
C
      SUBROUTINE DCSQUA(JACIN,IJACIN,JJACIN,SIDNUM,COSIN,ICOSIN,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates the direction cosines of the outward normal
C      to the specified side of a quadrilateral element given the
C      jacobian inverse
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1 Feb 1981 (CG)
C      Commented    1 Feb 1981 (CG)
C
C ARGUMENTS in
C      JACIN   array of dimension (ijacin,jjacin). contains the
C              inverse of the transformation jacobian.
C      IJACIN  first dimension of JACIN (.ge.2)
C      JJACIN  second dimension of JACIN (.ge.2)
C      SIDNUM  the side number for which the outward normal
C              is required (.le.4)
C      ICOSIN  dimension of vector COSIN (.ge.2)
C      ITEST   error checking option
C
C ARGUMENTS out
C      COSIN   vector of dimension icosin. contains the dir-
C              ection cosines of the outward normal
C
C ROUTINES called
C      ERRMES  MATVEC
C
C
C     SUBROUTINE dcsqua(jacin, IJACIN, JJACIN, SIDNUM, COSIN,
C    *     ICOSIN, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DIMEN,ERRMES,ICOSIN,IERROR,IJACIN,ITEST,IWORK,JJACIN,
     *        SIDNUM
      CHARACTER*6 SRNAME
      DOUBLE PRECISION AMOD,COSIN,JACIN,WORK
      DIMENSION COSIN(ICOSIN),JACIN(IJACIN,JJACIN),WORK(2)
      DATA DIMEN/2/,IWORK/2/,SRNAME/8H DCSQUA /
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IJACIN.LT.2 .OR. JJACIN.LT.2) IERROR = 3
         IF (ICOSIN.LT.2) IERROR = 2
         IF (SIDNUM.LE.0 .OR. SIDNUM.GT.4) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      GO TO (1000,1010,1020,1030) SIDNUM
C
C     Side number 1 : xi = -1
C
 1000 CONTINUE
      WORK(1) = -1.0D0
      WORK(2) = 0.0D0
      GO TO 1040
C
C     Side number 2 : eta = +1
C
 1010 CONTINUE
      WORK(1) = 0.0D0
      WORK(2) = 1.0D0
      GO TO 1040
C
C     Side number 3 : xi = +1
C
 1020 CONTINUE
      WORK(1) = 1.0D0
      WORK(2) = 0.0D0
      GO TO 1040
C
C     Side number 4 : eta = -1
C
 1030 CONTINUE
      WORK(1) = 0.0D0
      WORK(2) = -1.0D0
C
C     Calculate direction cosines
C
 1040 CONTINUE
      CALL MATVEC(JACIN,IJACIN,JJACIN,WORK,IWORK,DIMEN,DIMEN,COSIN,
     *            ICOSIN,ITEST)
      AMOD = DSQRT(COSIN(1)*COSIN(1)+COSIN(2)*COSIN(2))
      COSIN(1) = COSIN(1)/AMOD
      COSIN(2) = COSIN(2)/AMOD
C
      END
C
      SUBROUTINE DCSTRI(JACIN,IJACIN,JJACIN,SIDNUM,COSIN,ICOSIN,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates the direction cosines of the outward normal
C      to the specified side of a triangular element given the
C      jacobian inverse
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1 Feb 1981 (CG)
C      Commented    1 Feb 1981 (CG)
C
C ARGUMENTS in
C      JACIN   array of dimension (ijacin,jjacin). contains the
C              inverse of the transformation jacobian.
C      IJACIN  first dimension of JACIN (.ge.2)
C      JJACIN  second dimension of JACIN (.ge.2)
C      SIDNUM  the side number for which the outward normal
C              is required (.le.3)
C      ICOSIN  dimension of vector COSIN (.ge.2)
C      ITEST   error checking option
C
C ARGUMENTS out
C      COSIN   vector of dimension icosin. contains the dir-
C              ection cosines of the outward normal
C
C ROUTINES called
C      ERRMES  MATVEC
C
C
C     SUBROUTINE dcstri(jacin, IJACIN, JJACIN, SIDNUM, COSIN,
C    *     ICOSIN, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DIMEN,ERRMES,ICOSIN,IERROR,IJACIN,ITEST,IWORK,JJACIN,
     *        SIDNUM
      CHARACTER*6 SRNAME
      DOUBLE PRECISION AMOD,COSIN,JACIN,WORK
      DIMENSION COSIN(ICOSIN),JACIN(IJACIN,JJACIN),WORK(2)
      DATA DIMEN/2/,IWORK/2/,SRNAME/8H DCSTRI /
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IJACIN.LT.2 .OR. JJACIN.LT.2) IERROR = 3
         IF (ICOSIN.LT.2) IERROR = 2
         IF (SIDNUM.LE.0 .OR. SIDNUM.GT.3) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      GO TO (1000,1010,1020) SIDNUM
C
C     Side number 1 : l3 = 0
C
 1000 CONTINUE
      WORK(1) = 0.5D0
      WORK(2) = -DSQRT(3.0D0)/2.0D0
      GO TO 1030
C
C     Side number 2 : l1 = 0
C
 1010 CONTINUE
      WORK(1) = -1.0D0
      WORK(2) = 0.0D0
      GO TO 1030
C
C     Side number 3 : l2 = 0
C
 1020 CONTINUE
      WORK(1) = 0.5D0
      WORK(2) = DSQRT(3.0D0)/2.0D0
C
C     Calculate direction cosines
C
 1030 CONTINUE
      CALL MATVEC(JACIN,IJACIN,JJACIN,WORK,IWORK,DIMEN,DIMEN,COSIN,
     *            ICOSIN,ITEST)
      AMOD = DSQRT(COSIN(1)*COSIN(1)+COSIN(2)*COSIN(2))
      COSIN(1) = COSIN(1)/AMOD
      COSIN(2) = COSIN(2)/AMOD
C
      END
C
      SUBROUTINE DIRECT(NELE,ELTOP,IELTOP,JELTOP,NF,INF,JNF,DOFNOD,
     *                  STEER,ISTEER,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      constructs the steering vector to DIRECT assembly of a
C      system matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    13 Feb 1980 (KR)
C
C ARGUMENTS in
C      NELE    element number
C      ELTOP   2d array containing element type, number of
C              nodes on the element, and the element topologies
C      IELTOP  first dimension of ELTOP (.GE. number of
C              elements in problem)
C      JELTOP  second dimension of ELTOP (.GE. number of nodes
C              on element + 2)
C      NF      contains freedom numbers associated with each
C              node
C      INF     first dimension of NF (.GE. total number of
C              nodes in problem)
C      JNF     second dimension of NF (.GE. DOFNOD)
C      DOFNOD  number of degrees of freedom at each node
C      ISTEER  dimension of vector STEER (.GE. total number of
C              degrees of freedom on element)
C      ITEST   error checking option
C
C ARGUMENTS out
C      STEER   vector containing freedom numbers associated
C              with element NELE, arranged in local node order
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE direct(nele, ELTOP, IELTOP, JELTOP, NF, INF, JNF,
C    *     DOFNOD, STEER, ISTEER, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFNOD,ELTOP,ERRMES,IDEG,IELTOP,IERROR,INF,INOD,ISTEER,
     *        ITEST,JELTOP,JNF,JNOD,JTEST,K,NELE,NF,NODEL,STEER
      CHARACTER*6 SRNAME
      DIMENSION ELTOP(IELTOP,JELTOP),NF(INF,JNF),STEER(ISTEER)
      DATA SRNAME/'DIRECT'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (JNF.LT.DOFNOD) IERROR = 3
         IF (IELTOP.LT.NELE) IERROR = 2
         IF (NELE.LE.0 .OR. DOFNOD.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      NODEL = ELTOP(NELE,2)
C
C     Range check on NODEL : number of node in element
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (JELTOP.LT.NODEL+2) IERROR = 4
         IF (ISTEER.LT.DOFNOD*NODEL) IERROR = 6
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      K = 1
      DO 1010 INOD = 1,NODEL
         JNOD = ELTOP(NELE,INOD+2)
C
C     Range check on JNOD : node number
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF (INF.LT.JNOD) IERROR = 5
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
C     Construct steering vector
C
         DO 1000 IDEG = 1,DOFNOD
            STEER(K) = NF(JNOD,IDEG)
            K = K + 1
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE DISO(D,ID,JD,E,NU,NUMSS,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms 6 by 6 stress-strain matrix for 3d isotropic
C      problems
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    13 Feb 1980 (KR)
C
C ARGUMENTS in
C      ID      first dimension of matrix D (.GE. 6)
C      JD      second dimension of D (.GE. 6)
C      E       young's modulus
C      NU      poisson's ratio
C      ITEST   error checking option
C
C ARGUMENTS out
C      D       stress-strain matrix
C      NUMSS   order of stress-strain matrix (6)
C
C ROUTINES called
C      MATNUL  ERRMES
C
C
C     SUBROUTINE diso(d, ID, JD, E, NU, NUMSS, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,ID,IERROR,ITEST,J,JD,NUMSS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION D,E,NU,NU1,NUNU
      DIMENSION D(ID,JD)
      DATA SRNAME/'DISO'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (NU.LT.0.0D0 .OR. NU.GE.0.5D0) IERROR = 2
         IF (ID.LT.NUMSS .OR. JD.LT.NUMSS) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      NUMSS = 6
C
C     Initialise matrix D
C
      CALL MATNUL(D,ID,JD,NUMSS,NUMSS,ITEST)
C
C     Set values
C
      NU1 = NU/ (1.0D0-NU)
      NUNU = 0.5D0* (1.0D0-2.0D0*NU)/ (1.0D0-NU)
C
      D(1,1) = 1.0D0
      D(2,2) = 1.0D0
      D(3,3) = 1.0D0
      D(1,2) = NU1
      D(2,1) = NU1
      D(1,3) = NU1
      D(3,1) = NU1
      D(2,3) = NU1
      D(3,2) = NU1
      D(4,4) = NUNU
      D(5,5) = NUNU
      D(6,6) = NUNU
C
      DO 1010 I = 1,6
         DO 1000 J = 1,6
            D(I,J) = D(I,J)*E/ (2.0D0* (1.0D0+NU)*NUNU)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE DPLT(D,ID,JD,E,NU,T,NUMSS,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms 3 by 3 stress-strain matrix for use in plate
C      bending problems
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    13 Feb 1980 (KR)
C
C ARGUMENTS in
C      ID      first dimension of D (.GE. 3)
C      JD      second dimension of D (.GE. 3)
C      E       young's modulus
C      NU      poisson's ratio
C      T       thickness of plate
C      ITEST   error checking option
C
C ARGUMENTS out
C      D       stress-strain matrix
C      NUMSS   order of stress-strain matrix (3)
C
C ROUTINES called
C      MATNUL  ERRMES
C
C
C     SUBROUTINE dplt(d, ID, JD, E, NU, T, NUMSS, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,ID,IERROR,ITEST,J,JD,NUMSS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION D,E,NU,T,T3
      DIMENSION D(ID,JD)
      DATA SRNAME/'DPLT'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (NU.LT.0.0D0 .OR. NU.GE.0.5D0) IERROR = 2
         IF (ID.LT.NUMSS .OR. JD.LT.NUMSS) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      NUMSS = 3
C
C     Initialise matrix D
C
      CALL MATNUL(D,ID,JD,NUMSS,NUMSS,ITEST)
C
      T3 = T**3
      D(1,1) = 1.0D0
      D(2,2) = 1.0D0
      D(3,3) = (1.0D0-NU)*0.5D0
      D(1,2) = NU
      D(2,1) = NU
C
      DO 1010 I = 1,3
         DO 1000 J = 1,3
            D(I,J) = D(I,J)*T3*E/ (12.0D0* (1.0D0-NU*NU))
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE DPSN(D,ID,JD,E,NU,NUMSS,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms the 3 by 3 stress-strain matrix for use in plane
C      strain problems
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1980 (ims)
C      Commented    14 Feb 1980 (KR)
C
C ARGUMENTS in
C      ID      first dimension of array D (.GE. 3)
C      JD      second dimension of D (.GE. 3)
C      E       young's modulus
C      NU      poisson's ratio
C      ITEST   error checking option
C
C ARGUMENTS out
C      D       stress-strain matrix for plane strain
C      NUMSS   order of stress-strain matrix (3)
C
C ROUTINES called
C      MATNUL  ERRMES
C
C
C     SUBROUTINE dpsn(d, ID, JD, E, NU, NUMSS, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,ID,IERROR,ITEST,J,JD,NUMSS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION D,E,NU,NU1,NUNU
      DIMENSION D(ID,JD)
      DATA SRNAME/'DPSN'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (NU.LT.0.0D0 .OR. NU.GE.0.5D0) IERROR = 2
         IF (ID.LT.NUMSS .OR. JD.LT.NUMSS) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      NUMSS = 3
C
C     Initialise matrix D
C
      CALL MATNUL(D,ID,JD,NUMSS,NUMSS,ITEST)
C
      NU1 = NU/ (1.0D0-NU)
      NUNU = (0.5D0-NU)/ (1.0D0-NU)
C
      D(1,1) = 1.0D0
      D(2,2) = 1.0D0
      D(3,3) = NUNU
      D(1,2) = NU1
      D(2,1) = NU1
C
      DO 1010 I = 1,3
         DO 1000 J = 1,3
            D(I,J) = D(I,J)*E/ (2.0D0* (1.0D0+NU)*NUNU)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE DPSS(D,ID,JD,E,NU,NUMSS,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms 3 by 3 stress-strain matrix for use in plane
C      stress problems
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Feb 1980 (KR)
C
C ARGUMENTS in
C      ID      first dimension of D (.GE. 3)
C      JD      second dimension of D (.GE. 3)
C      E       young's modulus
C      NU      poisson's ratio
C      ITEST   error checking option
C
C ARGUMENTS out
C      D       stress-strain matrix for plane stress
C      NUMSS   order of stress-strain matrix (3)
C
C ROUTINES called
C      MATNUL  ERRMES
C
C
C     SUBROUTINE dpss(d, ID, JD, E, NU, NUMSS, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,ID,IERROR,ITEST,J,JD,NUMSS
      CHARACTER*6 SRNAME
      DOUBLE PRECISION D,E,NU
      DIMENSION D(ID,JD)
      DATA SRNAME/'DPSS'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (NU.LT.0.0D0 .OR. NU.GE.0.5D0) IERROR = 2
         IF (ID.LT.NUMSS .OR. JD.LT.NUMSS) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      NUMSS = 3
C
C     Initialise matrix D
C
      CALL MATNUL(D,ID,JD,NUMSS,NUMSS,ITEST)
C
      D(1,1) = 1.0D0
      D(2,2) = 1.0D0
      D(3,3) = (1.0D0-NU)*0.5D0
      D(1,2) = NU
      D(2,1) = NU
C
      DO 1010 I = 1,3
         DO 1000 J = 1,3
            D(I,J) = D(I,J)*E/ (1.0D0-NU*NU)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE DYAD(V,IV,W,IW,A,IA,JA,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms the DYAD matrix A from two vectors V and W
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979  (CG)
C      Commented    14 Feb 1980  (KR)
C
C ARGUMENTS in
C      V       first vector in multipcation
C      IV      dimension of vector V (.GE. N)
C      W       second vector in multiplication
C      IW      dimension of vector W (.GE. N)
C      IA      first dimension of dyadic array A (.GE. N)
C      JA      second dimension of A (.GE. N)
C      N       number of elements of vectors V and W to be used
C              in forming the DYAD
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       dyadic array formed by product of V and W
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE dyad(v, IV, W, IW, A, IA, JA, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IERROR,ITEST,IV,IW,J,JA,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W
      DIMENSION A(IA,JA),V(IV),W(IW)
      DATA SRNAME/'DYAD'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IW) IERROR = 3
         IF (N.GT.IV) IERROR = 2
         IF (N.LE.0) IERROR = 1
         IF (N.GT.IA .OR. N.GT.JA) IERROR = 4
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 J = 1,N
         DO 1000 I = 1,N
            A(I,J) = V(I)*W(J)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE ELGEOM(NELE,ELTOP,IELTOP,JELTOP,COORD,ICOORD,JCOORD,
     *                  GEOM,IGEOM,JGEOM,DIMEN,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      constructs the element geometry array for the specified
C      element in the local node order
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Feb 1980 (KR)
C
C ARGUMENTS in
C      NELE    element number for which the nodal coordinate
C              array is required
C      ELTOP   contains element type, number of nodes, and
C              element topologies for all the elements
C      IELTOP  first dimension of ELTOP (.GE. maximum node
C              number on region)
C      JELTOP  second dimension of ELTOP (.GE. number of nodes
C              on element + 2)
C      COORD   coord(i,j) contains the j'th global coordinate
C              of the i'th node
C      ICOORD  first dimension of COORD (.GE. maximum number of
C              nodes in the mesh)
C      JCOORD  second dimension of COORD (.GE. DIMEN)
C      IGEOM   first dimension of array GEOM (.GE. number of
C              nodes on the element)
C      JGEOM   second dimension of GEOM (.GE. DIMEN)
C      DIMEN   dimensionality of the mesh
C      ITEST   error checking option
C
C ARGUMENTS out
C      GEOM    contains global coordinates of the nodes
C              associated with element NELE in the local node
C              numbering order
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE elgeom(nele, ELTOP, IELTOP, JELTOP, COORD,
C    *     ICOORD, JCOORD, GEOM, IGEOM, JGEOM, DIMEN, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DIMEN,ELTOP,ERRMES,ICOORD,IDIM,IELTOP,IERROR,IGEOM,INOD,
     *        ITEST,JCOORD,JELTOP,JGEOM,JNOD,JTEST,NELE,NODEL
      CHARACTER*6 SRNAME
      DOUBLE PRECISION COORD,GEOM
      DIMENSION COORD(ICOORD,JCOORD),ELTOP(IELTOP,JELTOP),
     *          GEOM(IGEOM,JGEOM)
      DATA SRNAME/'ELGEOM'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (JGEOM.LT.DIMEN) IERROR = 4
         IF (JCOORD.LT.DIMEN) IERROR = 3
         IF (IELTOP.LT.NELE) IERROR = 2
         IF (NELE.LE.0 .OR. DIMEN.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      NODEL = ELTOP(NELE,2)
C
C     Range checking on NODEL : nodel+2 <= JELTOP and NODEL <= IGEOM
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (JELTOP.LT.NODEL+2) IERROR = 5
         IF (IGEOM.LT.NODEL) IERROR = 7
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      DO 1010 JNOD = 1,NODEL
         INOD = ELTOP(NELE,JNOD+2)
C
C     Range checking on INOD : INOD <= ICOORD
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF (ICOORD.LT.INOD) IERROR = 6
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
C     Construct geometry array GEOM
C
         DO 1000 IDIM = 1,DIMEN
            GEOM(JNOD,IDIM) = COORD(INOD,IDIM)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      INTEGER FUNCTION ERRMES(ITEST,IERROR,SRNAME)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the value of IERROR or terminates the program,
C      printing a failure message
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Feb 1980 (KR)
C
C ARGUMENTS in
C      ITEST   contains either 0 (hard fail) or 1 (soft fail).
C              any other entry gives hard fail.
C      IERROR  contains the number of the detected error
C      SRNAME  contains up to 8 characters - usually a library
C              routine name
C
C ARGUMENTS out
C      ERRMES  routine name, contains the value of IERROR
C
C ROUTINES called
C      can call auxiliary routine in some versions of library
C      ERUNIT and ADUNIT
C
C
C     integer function errmes(itest, IERROR, SRNAME)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER IERROR,ITEST,JTEST,UNIT,GET
      CHARACTER*6 SRNAME
C
      DATA GET/0/,JTEST/1/
C
C     Hard failure
C
      IF (ITEST.EQ.-99) THEN
C
C     To return Release message
C
         WRITE (UNIT,FMT=9980)
      ELSE IF (ITEST.EQ.1 .OR. IERROR.EQ.0) THEN
C
C     Soft failure
C
         ERRMES = IERROR
         IF (ITEST.NE.0 .AND. IERROR.NE.0) THEN
            CALL ADUNIT(UNIT,GET,JTEST)
            WRITE (UNIT,FMT=9990) SRNAME,IERROR
         END IF
      ELSE
         CALL ERUNIT(UNIT,GET,JTEST)
         WRITE (UNIT,FMT=9990) SRNAME,IERROR
         STOP
      END IF
 9990 FORMAT (' ERROR DETECTED BY LEVEL 0 LIBRARY ROUTINE ',A,
     *       ' - ITEST = ',I5,//)
 9980 FORMAT (' RELEASE 3.0  -  1 JAN 87')
      END
C
      SUBROUTINE FORMNF(REST,IREST,JREST,RESNOD,TOTNOD,DOFNOD,NF,INF,
     *                  JNF,TOTDOF,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      constructs the nodal freedom array from the restrained
C      freedom data
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    18 Feb 1980 (KR)
C      recoded      01 Nov 1981 (nb)
C
C ARGUMENTS in
C      REST    integer array; rest(i,j) contains the i'th set
C              of restraint information - rest(i,1) contains
C              the node number, rest(i,j+1) for j=1(1)dofnod
C              contains the local freedom numbers of the
C              freedoms that are restrained
C      IREST   first dimension of array REST (.GE. RESNOD)
C      JREST   second dimension of REST (.GE. DOFNOD)
C      RESNOD  number of nodes at which freedoms are restrained
C      TOTNOD  total number of nodes in mesh
C      INF     first dimension of array INF (.GE. TOTNOD)
C      JNF     second dimension of INF (.GE. DOFNOD)
C      ITEST   error checking option
C
C ARGUMENTS out
C      NF      nf(i,j), j=1(1)dofnod, contains the freedom
C              numbers associated with the i'th node
C      TOTDOF  total number of freedoms in problem under
C              consideration
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE formnf(rest, IREST, JREST, RESNOD, TOTNOD,
C    *     DOFNOD, NF, INF, JNF, TOTDOF, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFNOD,ERRMES,I,IABS,IERROR,INF,IREST,ITEST,J,JNF,JREST,
     *        JTEST,K,L,M,NF,RESNOD,REST,TOTDOF,TOTNOD
      CHARACTER*6 SRNAME
      LOGICAL SWITCH
      DIMENSION NF(INF,JNF),REST(IREST,JREST)
      DATA SRNAME/'FORMNF'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (INF.LT.TOTNOD .OR. JNF.LT.DOFNOD) IERROR = 3
         IF (IREST.LT.RESNOD .OR. JREST.LT.DOFNOD+1) IERROR = 2
         IF (RESNOD.LT.0 .OR. TOTNOD.LE.0 .OR. DOFNOD.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      SWITCH = .TRUE.
C
C     Initialise nodel freedom array
C
      DO 1010 I = 1,TOTNOD
         DO 1000 J = 1,DOFNOD
            NF(I,J) = 1
 1000    CONTINUE
 1010 CONTINUE
C
C     If no restrained nodes branch
C
      IF (RESNOD.NE.0) THEN
         DO 1030 I = 1,RESNOD
            K = REST(I,1)
            DO 1020 J = 1,DOFNOD
               L = REST(I,J+1)
               M = IABS(L)
C
C     Range checking on K and M
C
               IF (JTEST.NE.-1) THEN
                  IERROR = 0
                  IF (K.GT.TOTNOD .OR. M.GT.DOFNOD) IERROR = 4
                  ITEST = ERRMES(JTEST,IERROR,SRNAME)
                  IF (ITEST.NE.0) RETURN
               END IF
C
               IF (L.GT.0) NF(K,L) = 0
               IF (L.LT.0) THEN
                  NF(K,M) = L
                  SWITCH = .FALSE.
               END IF
 1020       CONTINUE
 1030    CONTINUE
      END IF
C
C     Renumber nodal freedom array
C
      K = 1
      DO 1050 I = 1,TOTNOD
         DO 1040 J = 1,DOFNOD
            IF (NF(I,J).GT.0) THEN
               NF(I,J) = K
               K = K + 1
            END IF
 1040    CONTINUE
 1050 CONTINUE
C
C     Set up for prescribed values
C
      TOTDOF = K - 1
      IF (.NOT.SWITCH) THEN
         DO 1070 I = 1,TOTNOD
            DO 1060 J = 1,DOFNOD
               IF (NF(I,J).LT.0) THEN
                  NF(I,J) = -K
                  K = K + 1
               END IF
 1060       CONTINUE
 1070    CONTINUE
      END IF
      END
C
      SUBROUTINE FREDIF(IELE,ELTOP,IELTOP,JELTOP,NF,INF,JNF,DOFNOD,
     *                  FIRST,DIF,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates the maximum freedom number difference for an
C      element
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    18 Feb 1980 (KR)
C
C ARGUMENTS in
C      nele    element number
C      ELTOP   eltop(i,1) = element type of element I
C              eltop(i,2) = number of nodes on element I
C              eltop(i,j+2), j=1(1)number of nodes on element,
C              contains the nodes associated with element I
C      IELTOP  FIRST dimension of array ELTOP (.GE. nele)
C      JELTOP  second dimension of ELTOP (.GE. number of nodes
C              on element)
C      NF      nf(i,j) contains the freedom numbers associated
C              with node I
C      INF     FIRST dimension of NF (.GE. maximum node number
C              on element)
C      JNF     second dimension of NF (.GE. DOFNOD)
C      DOFNOD  number of degrees of freedom per node on the
C              element
C      FIRST   must be set to .true. for the FIRST call to
C              FREDIF and .false. for subsequent calls
C      DIF     must be zero for FIRST call to fredif;
C              subsequently contains the maximum freedom
C              difference prior to the current call
C      ITEST   error checking option
C
C ARGUMENTS out
C      FIRST   set to .false.
C      DIF     maximum freedom difference for all elements up
C              to and including element nele
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE fredif(iele, ELTOP, IELTOP, JELTOP, NF, INF, JNF,
C    *     DOFNOD, FIRST, DIF, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DIF,DOFNOD,ELTOP,ERRMES,I,IDEG,IELE,IELTOP,IERROR,INF,
     *        INOD,ITEST,J,JELTOP,JNF,JTEST,MAX,MAX0,MAXINT,MIN,MIN0,NF,
     *        NODEL
      CHARACTER*6 SRNAME
      LOGICAL FIRST
      DIMENSION ELTOP(IELTOP,JELTOP),NF(INF,JNF)
      DATA SRNAME/'FREDIF'/
C
C     Initialisation
C
      IF (FIRST) THEN
         FIRST = .FALSE.
         DIF = 0
      END IF
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IELTOP.LT.IELE) IERROR = 3
         IF (JNF.LT.DOFNOD) IERROR = 2
         IF (IELE.LE.0 .OR. DOFNOD.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      NODEL = ELTOP(IELE,2)
C
C     Range checking on NODEL
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (JELTOP.LT.NODEL+2) IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      MAX = 0
      MIN = MAXINT(MAX)
      DO 1010 I = 1,NODEL
         INOD = ELTOP(IELE,I+2)
C
C     Range checking on INOD
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF (INF.LT.INOD) IERROR = 5
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
         DO 1000 J = 1,DOFNOD
            IDEG = NF(INOD,J)
            IF (IDEG.GT.0) THEN
               MAX = MAX0(IDEG,MAX)
               MIN = MIN0(IDEG,MIN)
            END IF
 1000    CONTINUE
 1010 CONTINUE
C
C     Calculate maximum freedom number difference
C
      DIF = MAX0(DIF,MAX-MIN)
C
      END
C
      SUBROUTINE GAURDN(A,IA,JA,AL,IAL,JAL,N,HBAND,ROPIV,IROPIV,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      decomposes A real unsymmetric matrix of order N into
C      triangular matrices using gaussian elimination with
C      partial pivoting
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1 29 Oct 1979 (CG)
C      Commented   10 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimensions (ia,ja).  on entry, contains
C              the elements of the band matrix
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.min(2*hband-1,n))
C      IAL     first dimension of array AL (.ge.n)
C      JAL     second dimension of array AL (.ge.hband-1)
C      N       order of matrix A
C      HBAND   semi-bandwidth of matrix A
C      IROPIV  dimension of vector ROPIV
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       array of dimensions (ia,ja).  on exit, contains
C              the upper triangular matrix u, with the
C              diagonal elements of u stored as their
C              reciprocals.  the i'th row of u is stored in the
C              i'th row of A, starting with the diagonal
C              element of u in a(i,1)
C      ROPIV   vector of length IROPIV, containing details of
C              row interchanges.  if no interchange occurs at
C              the r'th major step then ropiv(r)=r; if the r
C              and J rows are interchanged then ropiv(r)=j
C
C ROUTINES called
C      VEPS    ERRMES
C
C
C     SUBROUTINE gaurdn(a, IA, JA, AL, IAL, JAL, N, HBAND, ROPIV,
C    *     IROPIV, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IAL,IERROR,IK,IR,IROPIV,ITEST,IW,J,JA,
     *        JAL,JJ,JR,JTEST,K,L,M,N,ROPIV
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,AL,EPS,ONE,VEPS,X,Y,ZERO
      DIMENSION A(IA,JA),AL(IAL,JAL),ROPIV(IROPIV)
      DATA ONE/1.0D0/,SRNAME/8H GAURDN /,ZERO/0.0D0/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IA.LT.N .OR. JA.LT.2*HBAND-1) IERROR = 4
         IF (IAL.LT.N .OR. JAL.LT.HBAND) IERROR = 3
         IF (IROPIV.LT.N) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      IERROR = 5
      EPS = VEPS(X)
      IW = MIN0(N,2*HBAND-1)
      M = HBAND
      K = IW - HBAND
      IF (K.GT.0) THEN
         DO 1020 I = 1,K
            L = IW - M
            DO 1000 J = 1,M
               JJ = J + L
               A(I,J) = A(I,JJ)
 1000       CONTINUE
            M = M + 1
            DO 1010 J = M,IW
               A(I,J) = ZERO
 1010       CONTINUE
 1020    CONTINUE
      END IF
      M = N - IW + HBAND + 1
      J = IW + 1
      IF (M.LE.N) THEN
         DO 1040 I = M,N
            J = J - 1
            DO 1030 K = J,IW
               A(I,K) = ZERO
 1030       CONTINUE
C
C     Zeros inserted
C
 1040    CONTINUE
      END IF
      DO 1060 I = 1,N
         X = ZERO
         DO 1050 J = 1,IW
            X = X + DABS(A(I,J))
 1050    CONTINUE
         IF (X.GT.ZERO) THEN
C
C     Row norms of A calculated and their reciprocals stored in
C     first column of AL
C
            AL(I,1) = ONE/X
         ELSE
            GO TO 1120
         END IF
 1060 CONTINUE
C
      IERROR = 6
      DO 1110 IR = 1,N
         X = ZERO
         M = MIN0(IR+HBAND-1,N)
         DO 1070 I = IR,M
            Y = DABS(A(I,1))*AL(I,1)
            IF (Y.GT.X) THEN
               X = Y
               J = I
            END IF
 1070    CONTINUE
C
C     Ir'th pivot element selected.
C
         IF (X.LT.EPS) THEN
            GO TO 1130
         ELSE
            ROPIV(IR) = J
            IF (J.NE.IR) THEN
               DO 1080 I = 1,IW
                  X = A(IR,I)
                  A(IR,I) = A(J,I)
                  A(J,I) = X
 1080          CONTINUE
C
C     Row IR and J interchanged.
C
C
               AL(J,1) = AL(IR,1)
            END IF
            JR = IR + 1
            Y = ONE/A(IR,1)
            IF (JR.LE.M) THEN
               DO 1100 I = JR,M
                  X = A(I,1)*Y
                  IF (IW.GE.2) THEN
                     DO 1090 J = 2,IW
                        A(I,J-1) = A(I,J) - X*A(IR,J)
 1090                CONTINUE
                  END IF
                  IK = I - IR
                  AL(IR,IK) = X
                  A(I,IW) = ZERO
 1100          CONTINUE
            END IF
C
C     Elimination completed
C
            A(IR,1) = Y
         END IF
 1110 CONTINUE
C
      RETURN
 1120 CONTINUE
      IR = I
C
 1130 CONTINUE
      A(IR,1) = ZERO
      ITEST = ERRMES(JTEST,IERROR,SRNAME)
C
      END
C
      SUBROUTINE GAUSOL(A,IA,JA,AL,IAL,JAL,N,HBAND,ROPIV,IROPIV,R,IR,
     *                  ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates the solution of A set of unsymmetric real
C      banded equations with A single rhs using gaussian
C      elimination with partial pivoting
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    11 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja).  on entry, contains
C              the elements of the band matrix
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.min(2*hband-1,n))
C      IAL     first dimension of array AL (.ge.n)
C      JAL     second dimension of array AL (.ge.hband-1)
C      N       order of band matrix A
C      HBAND   semi-bandwidth of matrix A
C      IROPIV  dimension of vector ROPIV (.ge.n)
C      R       on entry, contains the vector of rhs's
C      IR      dimension of R (.ge.n)
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       on exit, contains the upper triangular matrix u,
C              with the diagonal elements of u stored as their
C              reciprocals.  the i'th row of u is stored in the
C              i'th row of A, with the diagonal element of u in
C              the location a(i,1)
C      AL      contains the sub-diagonal elements of L, the
C              lower triangular matrix.  the multipliers l(i,r)
C              obtained at the r'th major step of the
C              elimination are stored in a(r,i-r)
C      ROPIV   contains details of the row interchanges.
C              ropiv(r)=r if no interchange occurs at the r'th
C              major step; if rows R and J are interchanged
C              then ropiv(r)=j
C      R       on exit, contains the solution vector
C
C ROUTINES called
C      VEPS    ERRMES
C
C
C     SUBROUTINE gausol(a, IA, JA, AL, IAL, JAL, N, HBAND, ROPIV,
C    *     IROPIV, R, IR, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IAL,IERROR,II,IK,IR,IRO,IROPIV,ITEST,IW,
     *        J,JA,JAL,JJ,JR,JTEST,K,KK,L,M,N,ROPIV
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,AL,EPS,ONE,R,VEPS,X,Y,ZERO
      DIMENSION A(IA,JA),AL(IAL,JAL),R(IR),ROPIV(IROPIV)
C
      DATA ONE/1.0D0/,SRNAME/8H GAUSOL /,ZERO/0.0D0/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IA.LT.N .OR. JA.LT.2*HBAND-1) IERROR = 5
         IF (IAL.LT.N .OR. JAL.LT.HBAND) IERROR = 4
         IF (IROPIV.LT.N) IERROR = 3
         IF (IR.LT.N) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      IERROR = 6
      EPS = VEPS(X)
      IW = MIN0(N,2*HBAND-1)
      M = HBAND
      K = IW - HBAND
      IF (K.GT.0) THEN
         DO 1020 I = 1,K
            L = IW - M
            DO 1000 J = 1,M
               JJ = J + L
               A(I,J) = A(I,JJ)
 1000       CONTINUE
            M = M + 1
            DO 1010 J = M,IW
               A(I,J) = ZERO
 1010       CONTINUE
 1020    CONTINUE
      END IF
      M = N - IW + HBAND + 1
      J = IW + 1
      IF (M.LE.N) THEN
         DO 1040 I = M,N
            J = J - 1
            DO 1030 K = J,IW
               A(I,K) = ZERO
 1030       CONTINUE
C
C     Insert zeros
C
 1040    CONTINUE
      END IF
C
      DO 1060 I = 1,N
         X = ZERO
         DO 1050 J = 1,IW
            X = X + DABS(A(I,J))
 1050    CONTINUE
         IF (X.GT.ZERO) THEN
C
C     ROPIV norms of A calculated and theiro reciprocals stored in
C     firost column of AL
C
            AL(I,1) = ONE/X
         ELSE
            GO TO 1170
         END IF
 1060 CONTINUE
C
      IERROR = 7
      DO 1110 IRO = 1,N
         X = ZERO
         M = MIN0(IRO+HBAND-1,N)
         DO 1070 I = IRO,M
            Y = DABS(A(I,1))*AL(I,1)
            IF (Y.GT.X) THEN
               X = Y
               J = I
            END IF
 1070    CONTINUE
C
C     Iro'th pivot element selected
C
         IF (X.LT.EPS) THEN
            GO TO 1180
         ELSE
            ROPIV(IRO) = J
            IF (J.NE.IRO) THEN
               DO 1080 I = 1,IW
                  X = A(IRO,I)
                  A(IRO,I) = A(J,I)
                  A(J,I) = X
 1080          CONTINUE
C
C     Row pivots IRO and J interchanged
C
               AL(J,1) = AL(IRO,1)
            END IF
            JR = IRO + 1
            Y = ONE/A(IRO,1)
            IF (JR.LE.M) THEN
               DO 1100 I = JR,M
                  X = A(I,1)*Y
                  IF (IW.GE.2) THEN
                     DO 1090 J = 2,IW
                        A(I,J-1) = A(I,J) - X*A(IRO,J)
 1090                CONTINUE
                  END IF
                  IK = I - IRO
                  AL(IRO,IK) = X
                  A(I,IW) = ZERO
 1100          CONTINUE
            END IF
C
C     Elimination complete
C
            A(IRO,1) = Y
         END IF
 1110 CONTINUE
C
      M = HBAND - 1
      DO 1130 K = 1,N
         M = MIN0(M+1,N)
         J = ROPIV(K)
         IF (J.NE.K) THEN
            X = R(K)
C
C     Row pivots K and J interchanged
C
            R(K) = R(J)
            R(J) = X
         END IF
         IK = K + 1
         IF (IK.GT.M) THEN
            GO TO 1140
         ELSE
            X = R(K)
            DO 1120 I = IK,M
               II = I - K
               R(I) = R(I) - X*AL(K,II)
 1120       CONTINUE
C
C     Forward substitution complete
C
         END IF
 1130 CONTINUE
C
 1140 CONTINUE
      DO 1160 K = 1,N
         M = MIN0(K,IW)
         I = N + 1 - K
         II = I - 1
         Y = A(I,1)
         X = R(I)
         IF (M.NE.1) THEN
            DO 1150 J = 2,M
               KK = J + II
               X = X - A(I,J)*R(KK)
 1150       CONTINUE
         END IF
C
C     Backward substitution complete
C
         R(I) = X*Y
 1160 CONTINUE
C
      RETURN
 1170 CONTINUE
      IRO = I
C
 1180 CONTINUE
      A(IRO,1) = ZERO
      ITEST = ERRMES(JTEST,IERROR,SRNAME)
C
      END
C
      SUBROUTINE GAUSUB(A,IA,JA,AL,IAL,JAL,N,HBAND,ROPIV,IROPIV,R,IR,
     *                  ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates the solution of A set of unsymmetric real
C      banded linear equations with A single rhs.  the banded
C      matrix has previously been decomposed into triangular
C      matrices using gaurdn
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    11 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimensions (ia,ja).  on entry, contains
C              the elements of the band matrix in lu form,
C              after processing by gaurdn
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.min(2*hband-1,n))
C      IAL     first dimension of AL (.ge.n)
C      JAL     second dimension of AL (.ge.hband-1)
C      N       order of banded matrix A
C      HBAND   semi-bandwidth of A
C      ROPIV   vector of dimension iropiv.  contains details
C              of row interchanges performed by gaurdn
C      IROPIV  dimension of ROPIV (.ge.n)
C      R       on entry, contains the vector of the rhs,
C              length IR
C      IR      dimension of R (.ge.n)
C      ITEST   error checking option
C
C ARGUMENTS out
C      R       on exit, contains solution vector
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE gausub(a, IA, JA, AL, IAL, JAL, N, HBAND, ROPIV,
C    *     IROPIV, R, IR, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IAL,IERROR,II,IK,IR,IROPIV,ITEST,IW,J,
     *        JA,JAL,K,KK,M,N,ROPIV
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,AL,R,X,Y
      DIMENSION A(IA,JA),AL(IAL,JAL),R(IR),ROPIV(IROPIV)
      DATA SRNAME/'GAUSUB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IR.LT.N) IERROR = 5
         IF (IA.LT.N .OR. JA.LT.2*HBAND-1) IERROR = 4
         IF (IAL.LT.N .OR. JAL.LT.HBAND) IERROR = 3
         IF (IROPIV.LT.N) IERROR = 2
         IF (N.LE.0 .OR. HBAND.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      IW = MIN0(N,2*HBAND-1)
      M = HBAND - 1
      DO 1010 K = 1,N
         M = MIN0(M+1,N)
         J = ROPIV(K)
         IF (J.NE.K) THEN
            X = R(K)
C
C     Rows K and J interchanged
C
            R(K) = R(J)
            R(J) = X
         END IF
         IK = K + 1
         IF (IK.GT.M) THEN
            GO TO 1020
         ELSE
            X = R(K)
            DO 1000 I = IK,M
               II = I - K
               R(I) = R(I) - X*AL(K,II)
 1000       CONTINUE
C
C     Forward substitution complete
C
         END IF
 1010 CONTINUE
C
 1020 CONTINUE
      DO 1040 K = 1,N
         M = MIN0(K,IW)
         I = N + 1 - K
         II = I - 1
         Y = A(I,1)
         X = R(I)
         IF (M.NE.1) THEN
            DO 1030 J = 2,M
               KK = J + II
               X = X - A(I,J)*R(KK)
 1030       CONTINUE
         END IF
C
C     Backward substitution complete
C
         R(I) = X*Y
 1040 CONTINUE
C
      END
C
      SUBROUTINE HOUSE(A,IA,JA,T,IT,JT,DIAG,IDIAG,SUB,ISUB,N,TOL,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      uses householder's method to reduce A real symmetric
C      matrix to tridiagonal form for use with qlval, qlvec
C      A is stored as A full matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    19 Feb 1980 (KR)
C
C ARGUMENTS in
C      A       array containing the elements of the symmetric
C              matrix
C      IA      first dimension of A (.GE. N)
C      JA      second dimension of A (.GE. N)
C      IT      first dimension of array T (.GE. N)
C      JT      second dimension of T (.GE. N)
C      IDIAG   dimension of vector DIAG (.GE. N)
C      ISUB    dimension of vector SUB (.GE. N)
C      N       order of matrix A
C      TOL     value of rmin/eps, where rmin is the smallest
C              positive number exactly representable on the
C              computer, and eps is the smallest positive
C              number such that 1.+eps>1.
C      ITEST   error checking option
C
C ARGUMENTS out
C      T       contains the orthogonal matrix 'q', the product
C              of the householder transformation matrices
C      DIAG    contains diagonal elements of tridiagonal matrix
C      SUB     contains the n-1 off-diagonal elements of the
C              tridiagonal matrix stored in sub(2) to sub(n).
C              sub(1)=0.
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE house(a, IA, JA, T, IT, JT, DIAG, IDIAG, SUB,
C    *     ISUB, N, TOL, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IDIAG,IERROR,II,ISUB,IT,ITEST,J,J1,JA,JT,K,L,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,DIAG,F,G,H,HH,SUB,T,TOL
      DIMENSION A(IA,JA),DIAG(IDIAG),SUB(ISUB),T(IT,JT)
      DATA SRNAME/'HOUSE'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IDIAG.LT.N .OR. ISUB.LT.N) IERROR = 2
         IF (IA.LT.N .OR. JA.LT.N) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 I = 1,N
         DO 1000 J = 1,I
            T(I,J) = A(I,J)
 1000    CONTINUE
 1010 CONTINUE
C
      IF (N.NE.1) THEN
         DO 1080 II = 2,N
            I = N - II + 2
            L = I - 2
            F = T(I,I-1)
            G = 0.0D0
            IF (L.NE.0) THEN
               DO 1020 K = 1,L
                  G = G + T(I,K)*T(I,K)
 1020          CONTINUE
C
C     If G is too small for orthogonality to be guaranteed the
C     transformation is skipped
C
            END IF
            H = G + F*F
            IF (G.GT.TOL) THEN
               L = L + 1
               G = DSQRT(H)
               IF (F.GE.0.0D0) G = -G
               SUB(I) = G
               H = H - F*G
               T(I,I-1) = F - G
               F = 0.0D0
               DO 1050 J = 1,L
C
C     Form element of a*u
C
                  T(J,I) = T(I,J)/H
                  G = 0.0D0
                  DO 1030 K = 1,J
                     G = G + T(J,K)*T(I,K)
 1030             CONTINUE
                  J1 = J + 1
                  IF (J1.LE.L) THEN
                     DO 1040 K = J1,L
C
C     Form element of p
C
                        G = G + T(K,J)*T(I,K)
 1040                CONTINUE
                  END IF
                  SUB(J) = G/H
C
C     Form K
C
                  F = F + G*T(J,I)
 1050          CONTINUE
C
C     Form reduced A
C
               HH = F/ (H+H)
               DO 1070 J = 1,L
                  F = T(I,J)
                  G = SUB(J) - HH*F
                  SUB(J) = G
                  DO 1060 K = 1,J
                     T(J,K) = T(J,K) - F*SUB(K) - G*T(I,K)
 1060             CONTINUE
 1070          CONTINUE
            ELSE
               SUB(I) = F
               H = 0.0D0
            END IF
            DIAG(I) = H
 1080    CONTINUE
      END IF
C
C     Accumulation of transformation matrices
C
      SUB(1) = 0.0D0
      DIAG(1) = 0.0D0
      DO 1130 I = 1,N
         L = I - 1
         IF (DIAG(I).NE.0.0D0) THEN
            DO 1110 J = 1,L
               G = 0.0D0
               DO 1090 K = 1,L
                  G = G + T(I,K)*T(K,J)
 1090          CONTINUE
               DO 1100 K = 1,L
                  T(K,J) = T(K,J) - G*T(K,I)
 1100          CONTINUE
 1110       CONTINUE
         END IF
         DIAG(I) = T(I,I)
         T(I,I) = 1.0D0
         IF (L.NE.0) THEN
            DO 1120 J = 1,L
               T(I,J) = 0.0D0
               T(J,I) = 0.0D0
 1120       CONTINUE
         END IF
 1130 CONTINUE
C
      END
C
      SUBROUTINE IASRHS(RHS,IRHS,VALUE,IVALUE,STEER,ISTEER,DOFEL,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      the routine adds into the right-hand side of a system
C      the values contianed in an element vector, thus
C      forming the right-hand side VALUE is real, RHS is complex
C      (ordered pairs), with VALUE added into imaginary part of rhs.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0   1 Jul 1984 (crie)
C      Commented     1 Jul 1985 (CG)
C
C ARGUMENTS in
C      RHS     the right-hand side of the system
C              complex ( ordered pairs )
C      IRHS    dimension of array rsh
C      VALUE   the element vector of the current element to
C              be added into the right-hand side, imaginary component
C      ivale   dimension of array VALUE
C      STEER   the steering vector containing the freedom
C              numbers of the freedoms associated with the
C              current element in the local order
C      ISTEER  dimension of array STEER
C      DOFEL   the maximum number of degrees of freedom on
C              an element of the current type
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE iasrhs(rhs,irhs,value,ivalue,steer,isteer,
C    *     dofel,itest)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFEL,ERRMES,IERROR,IRHS,ISTEER,ITEST,IVALUE,K,L,STEER,
     *        JTEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION RHS,VALUE
      DIMENSION RHS(2,IRHS),STEER(ISTEER),VALUE(IVALUE)
      DATA SRNAME/'IASRHS'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 3
         IF (IVALUE.LT.DOFEL) IERROR = 2
         IF (DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1000 K = 1,DOFEL
         IF (STEER(K).NE.0) THEN
            L = STEER(K)
            IF (JTEST.NE.-1) THEN
               IERROR = 0
               IF (L.GT.IRHS) IERROR = 4
               ITEST = ERRMES(ITEST,IERROR,SRNAME)
               IF (ITEST.NE.0) RETURN
            END IF
            RHS(2,L) = RHS(2,L) + VALUE(K)
         END IF
 1000 CONTINUE
C
      END
C
      SUBROUTINE IASSYM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
     *                  HBAND,DOFEL,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      for real symmetric system matrix, adds the contribution
C      from an element matrix into real part of complex SYSK
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1985 (crie)
C      Commented     7 Nov 1985 (CG)
C
C ARGUMENTS in
C      SYSK    contains system matrix prior to addition of
C              current element matrix contribution
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. HBAND)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL)
C      JELK    second dimension of ELK (.GE. DOFEL)
C      STEER   contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTEER  first dimension of STEER (.GE. DOFEL)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL   maximum degrees of freedom associated with
C              element type
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix -   ordered pairs
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE iassym(sysk, ISYSK, JSYSK, ELK, IELK, JELK,
C    *     STEER, ISTEER, HBAND, DOFEL, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER CD,DOFEL,ERRMES,HBAND,I,IELK,IERROR,ISTEER,ISYSK,ITEST,J,
     *        JELK,JSYSK,STEER,STEERI,JTEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STEER(ISTEER),SYSK(2,ISYSK,JSYSK)
      DATA SRNAME/'IASSYM'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 4
         IF (IELK.LT.DOFEL .OR. JELK.LT.DOFEL) IERROR = 3
         IF (JSYSK.LT.HBAND) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
      DO 1010 I = 1,DOFEL
         IF (STEER(I).NE.0) THEN
            DO 1000 J = 1,DOFEL
               IF (STEER(J).NE.0) THEN
                  CD = STEER(J) - STEER(I) + HBAND
                  IF (CD.LE.HBAND) THEN
                     STEERI = STEER(I)
                     IF (JTEST.NE.-1) THEN
                        IERROR = 0
                        IF (ISYSK.LT.STEERI) IERROR = 5
                        ITEST = ERRMES(ITEST,IERROR,SRNAME)
                        IF (ITEST.NE.0) RETURN
                     END IF
                     SYSK(2,STEERI,CD) = SYSK(2,STEERI,CD) + ELK(I,J)
                  END IF
               END IF
 1000       CONTINUE
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE IASUSM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
     *                  HBAND,DOFEL,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      for complex unsymmetric system matrix, assembles
C      contribution from real element matrix into
C      the imaginary part of a complex system matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1985 (CG)
C
C ARGUMENTS in
C      SYSK    contains system matrix into which contributions
C              from current element matrix are to be assembled
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. 2*hband-1)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL)
C      JELK    second dimension of ELK (.GE. DOFEL)
C      STEER   contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTEER  first dimension of STEER (.GE. DOFEL)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL   maximum number of degrees of freedom associated
C              with this element type
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    complex system matrix (stored as ordered pairs)
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE iasusm(sysk, ISYSK, JSYSK, ELK, IELK, JELK,
C    *      STEER, ISTEER, HBAND, DOFEL, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFEL,ERRMES,HBAND,I,IELK,IERROR,ISTEER,ISYSK,ITEST,J,
     *        JELK,JSYSK,JTEST,OFFSET,STEER,STEERI,STEERJ
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STEER(ISTEER),SYSK(2,ISYSK,JSYSK)
      DATA SRNAME/'IASUSM'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 4
         IF (IELK.LT.DOFEL .OR. JELK.LT.DOFEL) IERROR = 3
         IF (JSYSK.LT.2*HBAND-1) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1010 I = 1,DOFEL
         STEERI = STEER(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL
               STEERJ = STEER(J)
               IF (STEERJ.GT.0) THEN
                  OFFSET = STEERJ - STEERI + HBAND
C
C     Range checking on STEERI and STEERJ
C
                  IF (JTEST.NE.-1) THEN
                     IERROR = 0
                     IF (ISYSK.LT.STEERI .OR.
     *                   JSYSK.LT.OFFSET) IERROR = 5
                     ITEST = ERRMES(JTEST,IERROR,SRNAME)
                     IF (ITEST.NE.0) RETURN
                  END IF
C
                  SYSK(2,STEERI,OFFSET) = SYSK(2,STEERI,OFFSET) +
     *                                    ELK(I,J)
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE JACO(A,IA,JA,DIAG,IDIAG,SUB,ISUB,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      reduces A real symmetric band matrix to tridiagonal form
C      using jacobi rotations, for use with qlvql or qlvec.
C      the lower triangle of the matrix is stored in A
C      rectangular array.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    26 Feb 1980 (KR)
C
C ARGUMENTS in
C      A       contains the elements of the lower triangle of
C              the positive definite band matrix
C      IA      first dimension of A (.GE. N)
C      JA      second dimension of A (.GE. HBAND)
C      IDIAG   dimension of vector DIAG (.GE. N)
C      ISUB    dimension of vector SUB (.GE. N)
C      N       order of matrix A
C      HBAND   semi-bandwidth of matrix A (includes diagonal)
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       destroyed on succesful exit
C      DIAG    contains the diagonal elements of the
C              tridiagonal matrix
C      SUB     contains the n-1 off-diagonal elements of the
C              tridiagonal matrix stored in sub(2) to sub(n),
C              with sub(1)=0
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE jaco(a, IA, JA, DIAG, IDIAG, SUB, ISUB, N, HBAND,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IDIAG,IERROR,IR,IRR,ISUB,ITEST,IUGL,J,
     *        J2,JA,JL,JM,K,KR,L,M,MAXL,MAXR,N,N2
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,B,C,C2,CS,DIAG,G,S,S2,SUB,U,U1
      DIMENSION A(IA,JA),DIAG(IDIAG),SUB(ISUB)
      DATA SRNAME/'JACO'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ISUB.LT.N) IERROR = 4
         IF (IDIAG.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      G = 0.0D0
      DO 1010 I = 1,N
         DO 1000 J = 1,HBAND
            L = HBAND + 1 - J
            K = I + 1 - L
            IF (K.GT.0) A(K,L) = A(I,J)
 1000    CONTINUE
 1010 CONTINUE
C
      KR = HBAND - 1
      DO 1030 I = 1,KR
         M = HBAND - I
         DO 1020 J = 1,M
            K = N + 1 - I
            L = HBAND + 1 - J
            A(K,L) = 0.0D0
 1020    CONTINUE
 1030 CONTINUE
C
      M = HBAND - 1
      N2 = N - 2
      IF (N2.GE.1) THEN
         DO 1080 K = 1,N2
            MAXR = M
            IF (N-K.LT.M) MAXR = N - K
            DO 1070 IRR = 2,MAXR
               IR = 2 + MAXR - IRR
               KR = K + IR
               DO 1060 J = KR,N,M
                  IF (J.EQ.KR) THEN
                     IF (A(K,IR+1).EQ.0.0D0) THEN
                        GO TO 1070
                     ELSE
                        B = -A(K,IR)/A(K,IR+1)
                        IUGL = K
                     END IF
                  ELSE IF (G.EQ.0.0D0) THEN
                     GO TO 1070
                  ELSE
                     JM = J - M
                     B = -A(JM-1,M+1)/G
                     IUGL = J - M
                  END IF
                  S = 1.0D0/DSQRT(1.0D0+B*B)
                  C = B*S
                  C2 = C*C
                  S2 = S*S
                  CS = C*S
                  U = C2*A(J-1,1) - 2.0D0*CS*A(J-1,2) + S2*A(J,1)
                  U1 = S2*A(J-1,1) + 2.0D0*CS*A(J-1,2) + C2*A(J,1)
                  A(J-1,2) = CS* (A(J-1,1)-A(J,1)) + (C2-S2)*A(J-1,2)
                  A(J-1,1) = U
                  A(J,1) = U1
                  J2 = J - 2
                  DO 1040 L = IUGL,J2
                     JL = J - L
                     U = C*A(L,JL) - S*A(L,JL+1)
                     A(L,JL+1) = S*A(L,JL) + C*A(L,JL+1)
                     A(L,JL) = U
 1040             CONTINUE
                  JM = J - M
                  IF (J.NE.KR) A(JM-1,M+1) = C*A(JM-1,M+1) - S*G
                  MAXL = M - 1
                  IF (N-J.LT.M-1) MAXL = N - J
                  IF (MAXL.GT.0) THEN
                     DO 1050 L = 1,MAXL
                        U = C*A(J-1,L+2) - S*A(J,L+1)
                        A(J,L+1) = S*A(J-1,L+2) + C*A(J,L+1)
                        A(J-1,L+2) = U
 1050                CONTINUE
                  END IF
                  IF (J+M.LE.N) THEN
                     G = -S*A(J,M+1)
                     A(J,M+1) = C*A(J,M+1)
                  END IF
 1060          CONTINUE
 1070       CONTINUE
 1080    CONTINUE
      END IF
C
      SUB(1) = 0.0D0
      DO 1090 I = 1,N
         DIAG(I) = A(I,1)
 1090 CONTINUE
C
      IF (2.LE.N) THEN
         DO 1100 I = 2,N
            SUB(I) = A(I-1,2)
 1100    CONTINUE
      END IF
      RETURN
*     $st$ Unreachable comments ...
C
      END
C
      SUBROUTINE LINQUA(XI,ETA,GEOM,IGEOM,JGEOM,NODEL,SIDNUM,ALEN,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates a unit of length along the side of a
C      rectangular element (4, 8 or 12 noded)
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0   1  Feb 1981 (CG)
C      Commented    24 july 1981 (CG)
C
C ARGUMENTS in
C      XI      local coordinate of point at which length is
C              required
C      ETA     local coordinate of point at which length is
C              required
C      GEOM    local coordinate array containing the global
C              coordiantes of each node on an element in the
C              local order
C      IGEOM   first dimension of array GEOM (.ge.nodel)
C      JGEOM   second dimension of array GEOM (.ge.2)
C      NODEL   number of nodes on the element
C      SIDNUM  the side number of the side of the element to
C              be used in calculating the length (.le.3)
C      ITEST   error checking option
C
C ARGUMENTS out
C      ALEN    the unit of length at the specified point
C
C ROUTINES called
C      ERRMES  QUAM4  QUAM8  QUAM12  MATMUL
C
C
C     SUBROUTINE linqua(xi, ETA, GEOM, IGEOM, JGEOM, NODEL,
C    *     SIDNUM, ALEN, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DIMEN,ERRMES,IDER,IERROR,IFUN,IGEOM,IJAC,ITEST,JDER,JGEOM,
     *        JJAC,JTEST,N,NODEL,SIDNUM
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ALEN,DER,ETA,FUN,GEOM,JAC,XI
      DIMENSION DER(2,12),FUN(12),GEOM(IGEOM,JGEOM),JAC(2,2)
      DATA DIMEN/2/,IDER/2/,IFUN/12/,IJAC/2/,JDER/12/,JJAC/2/,
     *     SRNAME/8H LINQUA /
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF ((NODEL.LE.0) .OR. (SIDNUM.LE.0)) IERROR = 1
         IF (IGEOM.LT.NODEL .OR. JGEOM.LT.2) IERROR = 2
         IF (SIDNUM.LT.1 .OR. SIDNUM.GT.4) IERROR = 3
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      N = NODEL/4
C
C     Range checking on N (should 1, 2 or 3)
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (N.LE.0 .OR. N.GE.4) IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      GO TO (1000,1010,1020) N
C
 1000 CONTINUE
      CALL QUAM4(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
      GO TO 1030
 1010 CONTINUE
      CALL QUAM8(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
      GO TO 1030
 1020 CONTINUE
      CALL QUAM12(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
C
 1030 CONTINUE
      CALL MATMUL(DER,IDER,JDER,GEOM,IGEOM,JGEOM,JAC,IJAC,JJAC,DIMEN,
     *            NODEL,DIMEN,ITEST)
C
C     Select correct side of element
C
      GO TO (1040,1050,1040,1050) SIDNUM
 1040 CONTINUE
      ALEN = DSQRT(JAC(2,1)**2+JAC(2,2)**2)
      RETURN
 1050 CONTINUE
      ALEN = DSQRT(JAC(1,1)**2+JAC(1,2)**2)
C
      END
C
      SUBROUTINE LINTRI(XI,ETA,GEOM,IGEOM,JGEOM,NODEL,SIDNUM,ALEN,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates a unit of length along the side of a
C      triangular element (3, 6 or 10 noded)
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0   1  Feb 1981 (CG)
C      Commented    24 july 1981 (CG)
C
C ARGUMENTS in
C      XI      local coordinate of point at which length is
C              required
C      ETA     local coordinate of point at which length is
C              required
C      GEOM    local coordinate array containing the global
C              coordiantes of each node on an element in the
C              local order
C      IGEOM   first dimension of array GEOM (.ge.nodel)
C      JGEOM   second dimension of array GEOM (.ge.2)
C      NODEL   number of nodes on the element
C      SIDNUM  the side number of the side of the element to
C              be used in calculating the length
C      ITEST   error checking option
C
C ARGUMENTS out
C      ALEN    the unit of length at the specified point
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE lintri(xi, ETA, GEOM, IGEOM, JGEOM, NODEL,
C    *     SIDNUM, ALEN, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IERROR,IGEOM,ITEST,JGEOM,JTEST,N,NODEL,SIDNUM
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ALEN,DXDL,DYDL,ETA,GEOM,L1,L2,L3,T1,T2,T3,T4,XI
      DIMENSION GEOM(IGEOM,JGEOM)
      DATA SRNAME/'LINTRI'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF ((NODEL.LE.0) .OR. (SIDNUM.LE.0)) IERROR = 1
         IF (IGEOM.LT.NODEL .OR. JGEOM.LT.2) IERROR = 2
         IF (SIDNUM.LT.1 .OR. SIDNUM.GT.3) IERROR = 3
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      N = NODEL/3
C
C     Range checking on N (should be 1, 2 or 3)
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (N.LE.0 .OR. N.GE.4) IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      GO TO (1000,1040,1080) N
 1000 CONTINUE
      GO TO (1010,1020,1030) SIDNUM
C
C     Code for 3-node triangle
C
 1010 CONTINUE
      DXDL = GEOM(1,1) - GEOM(2,1)
      DYDL = GEOM(1,2) - GEOM(2,2)
      GO TO 1120
 1020 CONTINUE
      DXDL = GEOM(2,1) - GEOM(3,1)
      DYDL = GEOM(2,2) - GEOM(3,2)
      GO TO 1120
 1030 CONTINUE
      DXDL = GEOM(3,1) - GEOM(1,1)
      DYDL = GEOM(3,2) - GEOM(1,2)
      GO TO 1120
C
C     Code for 6-node triangle
C
 1040 CONTINUE
      GO TO (1050,1060,1070) SIDNUM
 1050 CONTINUE
      L1 = 1.D0/3.D0* (1.D0+2.D0*XI)
      DXDL = (4.D0*L1-1.D0)*GEOM(1,1) + 4.D0* (1.D0-2.D0*L1)*GEOM(2,1) +
     *       (4.D0*L1-3.D0)*GEOM(3,1)
      DYDL = (4.D0*L1-1.D0)*GEOM(1,2) + 4.D0* (1.D0-2.D0*L1)*GEOM(2,2) +
     *       (4.D0*L1-3.D0)*GEOM(3,2)
      GO TO 1120
 1060 CONTINUE
      L2 = 1.D0/3.D0* (1.D0-XI-DSQRT(3.D0)*ETA)
      DXDL = (4.D0*L2-1.D0)*GEOM(3,1) + 4.D0* (1.D0-2.D0*L2)*GEOM(4,1) +
     *       (4.D0*L2-3.D0)*GEOM(5,1)
      DYDL = (4.D0*L2-1.D0)*GEOM(3,2) + 4.D0* (1.D0-2.D0*L2)*GEOM(4,2) +
     *       (4.D0*L2-3.D0)*GEOM(5,2)
      GO TO 1120
 1070 CONTINUE
      L3 = 1.D0/3.D0* (1.D0-XI+DSQRT(3.D0)*ETA)
      DXDL = (4.D0*L3-3.D0)*GEOM(1,1) + (4.D0*L3-1.D0)*GEOM(5,1) +
     *       4.D0* (1.D0-2.D0*L3)*GEOM(6,1)
      DYDL = (4.D0*L3-3.D0)*GEOM(1,2) + (4.D0*L3-1.D0)*GEOM(5,2) +
     *       4.D0* (1.D0-2.D0*L3)*GEOM(6,2)
      GO TO 1120
C
C     Code for 10-node triangle
C
 1080 CONTINUE
      GO TO (1090,1100,1110) SIDNUM
 1090 CONTINUE
      L1 = 1.D0/3.D0* (1.D0+2.D0*XI)
      L2 = 1.D0 - L1
      T1 = 1.D0/2.D0* (27.D0*L1*L1-14.D0*L2+2.D0)
      T2 = 9.D0/2.D0* (3.D0*L1*L1+6.D0*L1*L2-L1-L2)
      T3 = 9.D0/2.D0* (3.D0*L2*L2+6.D0*L1*L2-L1-L2)
      T4 = 1.D0/2.D0* (27*L2*L2-14.D0*L2+2.D0)
      DXDL = T1*GEOM(1,1) + T2*GEOM(2,1) + T3*GEOM(4,1) + T4*GEOM(4,1)
      DYDL = T1*GEOM(1,2) + T2*GEOM(2,2) + T3*GEOM(4,2) + T4*GEOM(4,2)
      GO TO 1120
 1100 CONTINUE
      L2 = 1.D0/3.D0* (1.D0-XI-DSQRT(3.D0)*ETA)
      L3 = 1.D0 - L2
      T1 = 1.D0/2.D0* (27.D0*L2*L2-14.D0*L2+2.D0)
      T2 = 9.D0/2.D0* (3.D0*L2*L2+6.D0*L2*L3-L2-L3)
      T3 = 9.D0/2.D0* (3.D0*L3*L3+6.D0*L2*L3-L2-L3)
      T4 = 1.D0/2.D0* (27.D0*L3*L3-14.D0*L3+2.D0)
      DXDL = T1*GEOM(4,1) + T2*GEOM(5,1) + T3*GEOM(6,1) + T4*GEOM(7,1)
      DXDL = T1*GEOM(4,2) + T2*GEOM(5,2) + T3*GEOM(6,2) + T4*GEOM(7,2)
      GO TO 1120
 1110 CONTINUE
      L3 = 1.D0/3.D0* (1.D0-XI+DSQRT(3.D0)*ETA)
      L1 = 1.D0 - L3
      T1 = 1.D0/2.D0* (27.D0*L1*L1-14.D0*L1+2.D0)
      T2 = 1.D0/2.D0* (27.D0*L3*L3-14.D0*L3+2.D0)
      T3 = 9.D0/2.D0* (3.D0*L3*L3+6.D0*L1*L3-L1-L3)
      T4 = 9.D0/2.D0* (3.D0*L1*L1+6.D0*L1*L3-L1-L3)
      DXDL = T1*GEOM(1,1) + T2*GEOM(7,1) + T3*GEOM(8,1) + T4*GEOM(9,1)
      DXDL = T1*GEOM(1,2) + T2*GEOM(7,2) + T3*GEOM(8,2) + T4*GEOM(9,2)
C
C     Do the calculation
C
 1120 CONTINUE
      ALEN = DSQRT(DXDL**2+DYDL**2)
C
      END
C
      SUBROUTINE MATADD(A,IA,JA,B,IB,JB,M,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      adds the matrix A to B, storing the result in A
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja)
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      B       array of dimension (ib,jb)
C      IB      first dimension of B (.ge.m)
C      JB      second dimension of B (.ge.n)
C      M       number of rows of A and B to be added
C      N       number of columns of A and B to be added
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       on exit, contains sum of A and B
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matadd(a, IA, JA, B, IB, JB, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IB,IERROR,ITEST,J,JA,JB,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,B
      DIMENSION A(IA,JA),B(IB,JB)
      DATA SRNAME/'MATADD'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (M.GT.IB .OR. N.GT.JB) IERROR = 3
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 J = 1,N
         DO 1000 I = 1,M
            A(I,J) = A(I,J) + B(I,J)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE MATCOP(A,IA,JA,B,IB,JB,M,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      copies matrix A into matrix B
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja) which is to be copied
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      IB      first dimension of array B (.ge.m)
C      JB      second dimension of B (.ge.n)
C      M       number of rows of A to be copied
C      N       number of columns of A to be copied
C      ITEST   error checking option
C
C ARGUMENTS out
C      B       array of dimension (ib,jb) into which A is
C              copied
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matcop(a, IA, JA, B, IB, JB, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IB,IERROR,ITEST,J,JA,JB,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,B
      DIMENSION A(IA,JA),B(IB,JB)
      DATA SRNAME/'MATCOP'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (M.GT.IB .OR. N.GT.JB) IERROR = 3
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 J = 1,N
         DO 1000 I = 1,M
            B(I,J) = A(I,J)
 1000    CONTINUE
 1010 CONTINUE
      END
C
      SUBROUTINE MATIDN(A,IA,JA,M,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      sets the matrix A to the identity matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      IA      first dimension of array A (.ge.m)
C      JA      second dimension of array A (.ge.n)
C      M       number of rows of A to be assigned values
C      N       number of columns of A to be assigned values
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       array of dimension (ia,ja).  a(i,j) is set to 1
C              if i=j, 0 otherwise
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matidn(a, IA, JA, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IERROR,ITEST,J,JA,L,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A
      DIMENSION A(IA,JA)
      DATA SRNAME/'MATIDN'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (N.LE.0 .OR. M.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (IERROR.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 J = 1,N
         DO 1000 I = 1,M
            A(I,J) = 0.0D0
 1000    CONTINUE
 1010 CONTINUE
C
C     Set diagonal entry
C
      L = MIN0(M,N)
      DO 1020 I = 1,L
         A(I,I) = 1.0D0
 1020 CONTINUE
C
      END
C
      SUBROUTINE MATINV(A,IA,JA,B,IB,JB,N,DET,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms the inverse of matrix A in B
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja) to be inverted
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.n)
C      IB      first dimension of array B (.ge.n)
C      JB      second dimension of array B (.ge.n)
C      N       order of matrix A (.gt.1 .and. .lt. 4)
C      ITEST   error checking option
C
C ARGUMENTS out
C      B       array of dimension (ib,jb) containing inverse of
C              A
C      DET     contains value of determinant of matrix A
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matinv(a, IA, JA, B, IB, JB, N, DET, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IA,IB,IERROR,ITEST,JA,JB,JTEST,K,L,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,B,DET,UNFLO,X
      DIMENSION A(IA,JA),B(IB,JB)
      DATA SRNAME/'MATINV'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IB .OR. N.GT.JB) IERROR = 3
         IF (N.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (N.LE.1 .OR. N.GE.4) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      M = N - 1
      GO TO (1000,1030) M
C
C     Code for 2x2 matrix
C
 1000 CONTINUE
      DET = A(1,1)*A(2,2) - A(1,2)*A(2,1)
C
C     Check that determinant is not near zero
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (DABS(DET).LT.UNFLO(X)) IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      B(1,1) = A(2,2)
      B(1,2) = -A(1,2)
      B(2,1) = -A(2,1)
      B(2,2) = A(1,1)
      DO 1020 K = 1,2
         DO 1010 L = 1,2
            B(K,L) = B(K,L)/DET
 1010    CONTINUE
 1020 CONTINUE
      RETURN
C
C     Code for 3x3 matrix
C
 1030 CONTINUE
      DET = A(1,1)* (A(2,2)*A(3,3)-A(3,2)*A(2,3))
      DET = DET - A(1,2)* (A(2,1)*A(3,3)-A(3,1)*A(2,3))
      DET = DET + A(1,3)* (A(2,1)*A(3,2)-A(3,1)*A(2,2))
C
C     Check on determinant not near zero
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (DABS(DET).LT.UNFLO(X)) IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      B(1,1) = A(2,2)*A(3,3) - A(3,2)*A(2,3)
      B(2,1) = -A(2,1)*A(3,3) + A(3,1)*A(2,3)
      B(3,1) = A(2,1)*A(3,2) - A(3,1)*A(2,2)
      B(1,2) = -A(1,2)*A(3,3) + A(3,2)*A(1,3)
      B(2,2) = A(1,1)*A(3,3) - A(3,1)*A(1,3)
      B(3,2) = -A(1,1)*A(3,2) + A(3,1)*A(1,2)
      B(1,3) = A(1,2)*A(2,3) - A(2,2)*A(1,3)
      B(2,3) = -A(1,1)*A(2,3) + A(2,1)*A(1,3)
      B(3,3) = A(1,1)*A(2,2) - A(2,1)*A(1,2)
C
      DO 1050 K = 1,3
         DO 1040 L = 1,3
            B(K,L) = B(K,L)/DET
 1040    CONTINUE
 1050 CONTINUE
C
      END
C
      SUBROUTINE MATMUL(A,IA,JA,B,IB,JB,C,IC,JC,L,M,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      pre-multiplies matrix B by A, storing the result in C
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja)
C      IA      first dimension of A (.ge.l)
C      JA      second dimension of A (.ge.m)
C      B       array of dimension (ib,jb)
C      IB      first dimension of B (.ge.m)
C      JB      second dimension of B (.ge.n)
C      IC      first dimension of array C (.ge.l)
C      JC      second dimension of array C (.ge.n)
C      L       number of rows of A to be used in multiplication
C      M       number of columns of A and number of rows of B
C              to be used in multiplication
C      N       number of columns of B to be used in
C              multiplication
C      ITEST   error checking option
C
C ARGUMENTS out
C      C       contains result of matrix multiplication (c=a*b)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matmul(a, IA, JA, B, IB, JB, C, IC, JC, L, M, N,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IB,IC,IERROR,ITEST,J,JA,JB,JC,K,L,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,B,C,X
      DIMENSION A(IA,JA),B(IB,JB),C(IC,JC)
      DATA SRNAME/'MATMUL'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (L.GT.IC .OR. N.GT.JC) IERROR = 4
         IF (M.GT.IB .OR. N.GT.JB) IERROR = 3
         IF (L.GT.IA .OR. M.GT.JA) IERROR = 2
         IF (L.LE.0 .OR. M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1020 I = 1,L
         DO 1010 J = 1,N
            X = 0.0D0
            DO 1000 K = 1,M
               X = X + A(I,K)*B(K,J)
 1000       CONTINUE
            C(I,J) = X
 1010    CONTINUE
 1020 CONTINUE
C
      END
C
      SUBROUTINE MATNUL(A,IA,JA,M,N,ITEST)
*$pl$ cmmode=verbatim
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      sets matrix A to the null matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      IA      first dimension of array A (.ge.m)
C      JA      second dimension of array A (.ge.n)
C      M       number of rows of A to be set to zero
C      N       number of columns of A to be set to zero
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       array of dimension (ia,ja).  a(i,j)=0 for
C              i=1(1)m and j=1(1)n
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matnul(a, IA, JA, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IERROR,ITEST,J,JA,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A
      DIMENSION A(IA,JA)
      DATA SRNAME/'MATNUL'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 J = 1,N
         DO 1000 I = 1,M
            A(I,J) = 0.0D0
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE MATRAN(A,IA,JA,B,IB,JB,M,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms the transpose of the matrix A
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  20 Oct 1979 (ims)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja) to be transposed
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      IB      first dimension of array B (.ge.n)
C      JB      second dimension of array B (.ge.m)
C      M       number of rows of A to be transposed
C      N       number of columns of A to be transposed
C      ITEST   error checking option
C
C ARGUMENTS out
C      B       array of dimension (ib,jb).  b(j,i)=a(i,j) for
C              i=1(1)m and j=1(1)n
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matran(a, IA, JA, B, IB, JB, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IB,IERROR,ITEST,J,JA,JB,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,B
      DIMENSION A(IA,JA),B(IB,JB)
      DATA SRNAME/'MATRAN'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IB .OR. M.GT.JB) IERROR = 3
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (IERROR.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 I = 1,M
         DO 1000 J = 1,N
            B(J,I) = A(I,J)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE MATSUB(A,IA,JA,B,IB,JB,M,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      subtracts matrix B from A, storing the result in A
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    12 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja)
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      B       array of dimension (ib,jb) to be subtracted from
C              A
C      IB      first dimension of B (.ge.m)
C      JB      second dimension of B (.ge.n)
C      M       number of rows of A and B to be subtracted
C      N       number of columns of A and B to be subtracted
C      ITEST   error checking option
C
C ARGUMENTS out
C      A       array of dimension (ia,ja).  on exit, a(i,j)
C              is set to a(i,j)-b(i,j) for i=1(1)m and j=1(1)n
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matsub(a, IA, JA, B, IB, JB, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IB,IERROR,ITEST,J,JA,JB,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,B
      DIMENSION A(IA,JA),B(IB,JB)
      DATA SRNAME/'MATSUB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (M.GT.IB .OR. N.GT.JB) IERROR = 3
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (IERROR.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 J = 1,N
         DO 1000 I = 1,M
            A(I,J) = A(I,J) - B(I,J)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE MATVEC(A,IA,JA,V,IV,M,N,W,IW,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      post-multiplies the matrix A by the vector V, storing
C      the result in the vector W
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja)
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      V       vector of dimension IV
C      IV      dimension of V (.ge.n)
C      M       number of rows of A to be used in the
C              multiplication
C      N       number of columns of A and the number of
C              elemenets of V to be used in the multiplication
C      IW      dimension of vector W (.ge.m)
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of dimension iw; contains the result of
C              the operation w=a*v
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE matvec(a, IA, JA, V, IV, M, N, W, IW, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IERROR,ITEST,IV,IW,J,JA,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W,X
      DIMENSION A(IA,JA),V(IV),W(IW)
      DATA SRNAME/'MATVEC'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (M.GT.IW) IERROR = 4
         IF (N.GT.IV) IERROR = 3
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 I = 1,M
         X = 0.0D0
         DO 1000 J = 1,N
            X = X + A(I,J)*V(J)
 1000    CONTINUE
         W(I) = X
 1010 CONTINUE
C
      END
C
      SUBROUTINE MVSYB(A,IA,JA,V,IV,W,IW,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      post-multiplies A real symmetric banded matrix stored as
C      A lower triangle by A vector
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja).  contains the
C              elements of the lower half of the real symmetric
C              band matrix of order N and semi-bandwidth HBAND
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.hband)
C      V       vector of dimension IV
C      IV      dimension of vector V (.ge.n)
C      IW      dimension of vector W (.ge.n)
C      N       order of the real symmetric band matrix
C      HBAND   semi-bandwidth of the real symmetric band matrix
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of dimension iw.  contains the result of
C              the operation w=a*v
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE mvsyb(a, IA, JA, V, IV, W, IW, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IA,IERROR,IJ,ITEST,IV,IW,J,JA,JI,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W,X
      DIMENSION A(IA,JA),V(IV),W(IW)
      DATA SRNAME/'MVSYB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IW.LT.N) IERROR = 4
         IF (IV.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1020 I = 1,N
         X = 0.0D0
         J = HBAND
 1000    CONTINUE
         IF (I+J.GT.HBAND) THEN
            IJ = I + J - HBAND
            X = X + A(I,J)*V(IJ)
            J = J - 1
            IF (J.NE.0) GO TO 1000
         END IF
         J = HBAND - 1
 1010    CONTINUE
         IF (I-J.LT.N-HBAND+1) THEN
            JI = I - J + HBAND
            X = X + A(JI,J)*V(JI)
            J = J - 1
            IF (J.NE.0) GO TO 1010
         END IF
         W(I) = X
 1020 CONTINUE
C
      END
C
      SUBROUTINE MVSYSP(A,IA,ROW,IROW,DIAG,IDIAG,V,IV,W,IW,N,ITEST)
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W
      INTEGER IA,ROW,IROW,DIAG,IDIAG,IV,IW,N,ITEST
      INTEGER I,ID,IN,JROW,J
      DIMENSION A(IA),ROW(IROW),DIAG(IDIAG),V(IV),W(IW)
      DATA SRNAME/'MVSYSP'/
C
      DO 1000 I = 1,N
         W(I) = 0.0
 1000 CONTINUE
      DO 1030 I = 1,N
         ID = DIAG(I)
         IN = DIAG(I+1) - 1
         DO 1010 J = ID,IN
            JROW = ROW(J)
            W(JROW) = W(JROW) + A(J)*V(I)
 1010    CONTINUE
         ID = ID + 1
         IF (IN.GE.ID) THEN
            DO 1020 J = ID,IN
               JROW = ROW(J)
               W(I) = W(I) + A(J)*V(JROW)
 1020       CONTINUE
         END IF
 1030 CONTINUE
      END
C
      SUBROUTINE MVUSB(A,IA,JA,V,IV,W,IW,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      post-multiplies A real unsymmetric banded matrix stored as
C      A rectangular array by A vector
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of dimension (ia,ja).  contains the
C              elements of the real unsymmetric band matrix
C              of order N and semi-bandwidth HBAND
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.2*hband-1)
C      V       vector of dimension IV
C      IV      dimension of vector V (.ge.n)
C      IW      dimension of vector W (.ge.n)
C      N       order of the real unsymmetric band matrix
C      HBAND   semi-bandwidth of the real unsymmetric band matrix
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of dimension iw.  contains the result of
C              the operation w=a*v
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE mvusb(a, IA, JA, V, IV, W, IW, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IERROR,IF,IS,ITEST,IV,IW,J,K,N,IA,JA
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W,X
      DIMENSION A(IA,JA),V(IV),W(IW)
      DATA SRNAME/'MVUSB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IW.LT.N) IERROR = 4
         IF (IV.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.2*HBAND-1) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 I = 1,N
         X = 0.0D0
         IS = MAX0(HBAND+1-I,1)
         IF = MIN0(N+HBAND-I,2*HBAND-1)
         DO 1000 J = IS,IF
            K = I + J - HBAND
            X = X + A(I,J)*V(K)
 1000    CONTINUE
         W(I) = X
 1010 CONTINUE
C
      END
C
      DOUBLE PRECISION FUNCTION NORM(RHS,IRHS,TOTDOF,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      this routine computes an l2 NORM of a vector for use
C      in terminating non-linear iterations
C
C method
C      square root of the sums of squares
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Jun 1986 (cjh,cg)
C
C ARGUMENTS in
C      RHS     vector containing values
C      IRHS    dimension of vector RHS (irhs.ge.totdof)
C      TOTDOF  number of entries in RHS
C      ITEST   error checking option
C
C ARGUMENTS out
C      NORM    the value of the NORM (function value)
C
C ROUTINES called
C      ERRMES
C
C
C     double precision function norm(rhs, IRHS, TOTDOF, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,IRHS,ITEST,TOTDOF
      CHARACTER*6 SRNAME
      DOUBLE PRECISION RHS
      DIMENSION RHS(IRHS)
      DATA SRNAME/'NORM'/
C
C     Parameter checking
C
      NORM = 0.0D0
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (TOTDOF.GT.IRHS) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Compute NORM
C
      DO 1000 I = 1,TOTDOF
         NORM = NORM + RHS(I)**2
 1000 CONTINUE
      NORM = DSQRT(NORM)
C
      END
C
      SUBROUTINE PRTGEO(TOTNOD,DIMEN,COORD,ICOORD,JCOORD,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints out element geometry in a standard format
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      TOTNOD  total number of nodes in the mesh
C      DIMEN   dimensionality of the geometric data
C      COORD   array of dimension (icoord,jcoord) containing
C              global coordinates of the nodes
C      ICOORD  first dimension of COORD (.ge.totnod)
C      JCOORD  second dimension of COORD (.ge.dimen)
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE prtgeo(totnod, DIMEN, COORD, ICOORD, JCOORD,
C    *     NOUT, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER TOTNOD,DIMEN,ICOORD,JCOORD,ITEST,NOUT,ERRMES,IERROR
      INTEGER I,J
      CHARACTER*6 SRNAME
      DOUBLE PRECISION COORD
      DIMENSION COORD(ICOORD,JCOORD)
      DATA SRNAME/'PRTGEO'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ICOORD.LT.TOTNOD .OR. JCOORD.LT.DIMEN) IERROR = 2
         IF (TOTNOD.LE.0 .OR. DIMEN.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      WRITE (NOUT,FMT=9990)
      WRITE (NOUT,FMT=9980) TOTNOD
      WRITE (NOUT,FMT=9970) DIMEN
      IF (DIMEN.EQ.1) WRITE (NOUT,FMT=9960)
      IF (DIMEN.EQ.2) WRITE (NOUT,FMT=9950)
      IF (DIMEN.EQ.3) WRITE (NOUT,FMT=9940)
      IF (DIMEN.EQ.4) WRITE (NOUT,FMT=9930)
C
      DO 1000 I = 1,TOTNOD
         WRITE (NOUT,FMT=9920) I, (COORD(I,J),J=1,DIMEN)
 1000 CONTINUE
C
 9990 FORMAT (' ',////' **** NODAL GEOMETRY ****',//' ')
 9980 FORMAT (' NUMBER OF NODES = ',I3)
 9970 FORMAT (' DIMENSIONS      = ',I3)
 9960 FORMAT (/' ',2X,'NODE',9X,'X1',/' ')
 9950 FORMAT (/' ',2X,'NODE',9X,'X1',12X,'X2',/' ')
 9940 FORMAT (/' ',2X,'NODE',9X,'X1',12X,'X2',12X,'X3',/' ')
 9930 FORMAT (/' ',2X,'NODE',9X,'X1',12X,'X2',12X,'X3',12X,'X4',/' ')
 9920 FORMAT (' ',2X,I3,5X,4 (D12.4,2X))
      END
C
      SUBROUTINE PRTMAT(A,IA,JA,M,N,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints A two-dimensional array in A standard format
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      A       array of diimension (ia,ja) containing numbers
C              to be printed
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      M       number of rows of A to be printed
C      N       number of columns of A to be printed
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE prtmat(a, IA, JA, M, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IERROR,ITEST,J,JA,M,N,NOUT
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A
      DIMENSION A(IA,JA)
      DATA SRNAME/'PRTMAT'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IA.LT.M .OR. JA.LT.N) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1000 I = 1,M
         WRITE (NOUT,FMT=9990) (A(I,J),J=1,N)
 1000 CONTINUE
C
 9990 FORMAT (' ',6D12.4)
      END
C
      SUBROUTINE PRTTOP(TOTELS,ELTOP,IELTOP,JELTOP,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints element topologies in a standard format
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      TOTELS  total number of elements in the mesh
C      ELTOP   integer array of dimension (ieltop,jeltop)
C              containing element topologies, element type, and
C              number of nodes on the element
C      IELTOP  first dimension of ELTOP (.ge.totels)
C      JELTOP  second dimension of ELTOP (.ge.number of nodes
C              on element + 2)
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE prttop(totels, ELTOP, IELTOP, JELTOP, NOUT, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ELTOP,ERRMES,I,IELTOP,IERROR,ITEST,J,JELTOP,JTEST,K,L,
     *        NOUT,TOTELS
      CHARACTER*6 SRNAME
      DIMENSION ELTOP(IELTOP,JELTOP)
      DATA SRNAME/'PRTTOP'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IELTOP.LT.TOTELS) IERROR = 2
         IF (TOTELS.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      WRITE (NOUT,FMT=9990)
      WRITE (NOUT,FMT=9980) TOTELS
      WRITE (NOUT,FMT=9970)
      DO 1000 I = 1,TOTELS
         L = ELTOP(I,2)
         K = L + 2
C
C     Range checking on K
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF (JELTOP.LT.K) IERROR = 3
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
         WRITE (NOUT,FMT=9960) I, (ELTOP(I,J),J=1,K)
 1000 CONTINUE
C
 9990 FORMAT (' ',////' **** ELEMENT TOPOLOGY ****',//' ')
 9980 FORMAT (' NUMBER OF ELEMENTS = ',I3)
 9970 FORMAT (/' ',2X,'ELEM',4X,'ELTYP',4X,'NODEL',4X,'NODES',/' ')
 9960 FORMAT (' ',2X,I4,4X,I3,7X,I3,4X,9 (I4,2X),/' ',27X,9 (I4,2X))
      END
C
      SUBROUTINE PRTVAL(VAL,IVAL,NF,INF,JNF,DOFNOD,TOTNOD,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints out the nodal values of the solution in a
C      standard format
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C      recoded      01 Nov 1981 (nb)
C
C ARGUMENTS in
C      VAL     vector of dimension IVAL containing solution
C              values,and prescribed boundary values
C      IVAL    dimension of VAL (.ge.total number of freedoms
C              in system)
C      NF      integer array of dimension (inf,jnf) containing
C              freedom numbers associated with each NODE
C      INF     first dimension of NF (.ge.totnod)
C      JNF     second dimension of NF (.ge.dofnod)
C      DOFNOD  number of degrees of freedom at each NODE
C      TOTNOD  total number of nodes in mesh
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE prtval(val, IVAL, NF, INF, JNF, DOFNOD, TOTNOD,
C    *     NOUT, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFNOD,ERRMES,I,IERROR,INF,ITEST,IVAL,J,JNF,JTEST,K,N,NF,
     *        NODE,NOUT,TOTNOD
      CHARACTER*6 SRNAME
      DOUBLE PRECISION VAL,WORK
      DIMENSION VAL(IVAL),WORK(5),NF(INF,JNF),NODE(5)
      DATA SRNAME/'PRTVAL'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (INF.LT.TOTNOD .OR. JNF.LT.DOFNOD) IERROR = 2
         IF (DOFNOD.LE.0 .OR. TOTNOD.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      IF (DOFNOD.EQ.1) THEN
C
         WRITE (NOUT,FMT=9950)
         N = 0
         DO 1000 I = 1,TOTNOD
            N = N + 1
            NODE(N) = I
            K = NF(I,1)
            WORK(N) = 0.0D0
            IF (K.NE.0) THEN
               IF (K.LE.0) K = IABS(K)
               WORK(N) = VAL(K)
            END IF
            IF (N.EQ.4) THEN
               WRITE (NOUT,FMT=9930) (NODE(J),WORK(J),J=1,4)
               N = 0
            END IF
 1000    CONTINUE
C
         IF (N.NE.0) WRITE (NOUT,FMT=9930) (NODE(J),WORK(J),J=1,N)
      ELSE
         IF (DOFNOD.EQ.2) WRITE (NOUT,FMT=9990)
         IF (DOFNOD.EQ.3) WRITE (NOUT,FMT=9980)
         IF (DOFNOD.EQ.4) WRITE (NOUT,FMT=9970)
         IF (DOFNOD.GE.5) WRITE (NOUT,FMT=9960)
         N = 0
         DO 1020 I = 1,TOTNOD
            DO 1010 J = 1,DOFNOD
               N = N + 1
               NODE(N) = I
               K = NF(I,J)
C
C     Range checking on K
C
               IF (JTEST.NE.-1) THEN
                  IERROR = 0
                  IF (IVAL.LT.K) IERROR = 3
                  ITEST = ERRMES(JTEST,IERROR,SRNAME)
                  IF (ITEST.NE.0) RETURN
               END IF
C
               WORK(N) = 0.0D0
               IF (K.NE.0) THEN
                  IF (K.LE.0) K = IABS(K)
                  WORK(N) = VAL(K)
               END IF
               IF (((DOFNOD.NE.2).OR. (N.EQ.4)) .AND.
     *             (DOFNOD.EQ.2)) THEN
                  WRITE (NOUT,FMT=9920) NODE(1),WORK(1),WORK(2),
     *               NODE(3),WORK(3),WORK(4)
                  N = 0
               ELSE IF ((DOFNOD.NE.2) .AND. (N.EQ.DOFNOD)) THEN
                  WRITE (NOUT,FMT=9940) I, (WORK(K),K=1,DOFNOD)
                  N = 0
               END IF
 1010       CONTINUE
 1020    CONTINUE
C
         IF (N.NE.0) THEN
            IF (DOFNOD.EQ.2) WRITE (NOUT,FMT=9920) NODE(1),WORK(1),
     *          WORK(2)
            IF (DOFNOD.NE.2) WRITE (NOUT,FMT=9940) I, (WORK(K),K=1,N)
         END IF
      END IF
C
 9990 FORMAT (/' ',2 ('NODE',6X,2 ('VALUE',9X)),/' ')
 9980 FORMAT (/' NODE',6X,3 ('VALUE',9X),/' ')
 9970 FORMAT (/' NODE',6X,4 ('VALUE',9X),/' ')
 9960 FORMAT (/' NODE',6X,5 ('VALUE',9X),/' ')
 9950 FORMAT (/' ',4 ('NODE',5X,'VALUE',5X),/' ')
 9940 FORMAT (' ',I4,1X,5 (D12.5,2X),/' ',5X,5 (D12.5,2X),/' ',5X,
     *       5 (D12.5,2X))
 9930 FORMAT (' ',4 (I4,1X,D12.5,2X))
 9920 FORMAT (' ',2 (I4,1X,2 (D12.5,2X),5X))
      END
C
      SUBROUTINE PRTVEC(V,IV,N,NOUT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      prints a vector in a standard format
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      V       vector of dimension IV containing numbers to be
C              printed
C      IV      dimension of V (.ge.n)
C      N       number of elements of V to be printed
C      NOUT    fortran unit number
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE prtvec(v, IV, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IV,N,NOUT
      CHARACTER*6 SRNAME
      DOUBLE PRECISION V
      DIMENSION V(IV)
      DATA SRNAME/'PRTVEC'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IV.LT.N) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      WRITE (NOUT,FMT=9990) (V(I),I=1,N)
C
 9990 FORMAT (' ',6D12.4)
      END
C
      SUBROUTINE QBRK6(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a six-point gauss type
C      quadrature rule for use in evaluating the integral of a
C      3d function over a cube
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    15 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp(=6))
C      IABSS   first dimension of array ABSS (.ge.3)
C      JABSS   second dimension of array ABSS (.ge.nqp(=6))
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of dimension iwght.  contains weights to
C              be used in the 6-point quadrature formula
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of points to be used in quadrature
C              formula
C      NQP     number of quadrature points to be used (=6)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qbrk6(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,W,WGHT
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QBRK6'/
C
      NQP = 6
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.3 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = 8.0D0/6.0D0
C
      DO 1000 I = 1,6
         WGHT(I) = W
         ABSS(1,I) = 0.0D0
         ABSS(2,I) = 0.0D0
         ABSS(3,I) = 0.0D0
 1000 CONTINUE
C
      ABSS(1,5) = -1.0D0
      ABSS(1,6) = 1.0D0
      ABSS(2,3) = -1.0D0
      ABSS(2,4) = 1.0D0
      ABSS(3,1) = -1.0D0
      ABSS(3,2) = 1.0D0
C
      END
C
      SUBROUTINE QBRK8(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a 8-point gauss type
C      quadrature rule for use in evaluating the integral of a
C      3d function over a cube
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    15 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp(=8))
C      IABSS   first dimension of array ABSS (.ge.3)
C      JABSS   second dimension of array ABSS (.ge.nqp(=8))
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of dimension iwght.  contains weights to
C              be used in the 8-point quadrature formula
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of points to be used in quadrature
C              formula
C      NQP     number of quadrature points to be used (=8)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qbrk8(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,W,WGHT,XY
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QBRK8'/
C
      NQP = 8
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.3 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = 1.0D0
      XY = DSQRT(1.0D0/3.0D0)
      DO 1000 I = 1,8
         WGHT(I) = W
         ABSS(1,I) = XY
         ABSS(2,I) = XY
         ABSS(3,I) = XY
 1000 CONTINUE
C
      DO 1010 I = 1,4
         ABSS(3,I) = -ABSS(1,1)
 1010 CONTINUE
C
      DO 1020 I = 1,2
         ABSS(1,I+1) = -ABSS(1,1)
         ABSS(1,I+5) = -ABSS(1,1)
         ABSS(2,I) = -ABSS(1,1)
         ABSS(2,I+4) = -ABSS(1,1)
 1020 CONTINUE
C
      END
C
      SUBROUTINE QLIN2(WGHT,IWGHT,ABSS,IABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the weights and abscissae of a 2-point gauss-
C      legendre quadrature formula for use in evaluating a 1d
C      integral over a finite range
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    15 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp(=2))
C      IABSS   dimension of vector ABSS (.ge.nqp(=2))
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of dimension iwght.  contains weights to
C              be used in the 2-point quadrature formula
C      ABSS    vector of dimension iabss.  contains abscissae
C              of points to be used in 2-point quadrature
C              formula
C      NQP     number of quadrature points (=2)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qlin2(wght, IWGHT, ABSS, IABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IABSS,IERROR,ITEST,IWGHT,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,WGHT
      DIMENSION ABSS(IABSS),WGHT(IWGHT)
      DATA SRNAME/'QLIN2'/
C
      NQP = 2
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      ABSS(1) = 1.0D0/DSQRT(3.0D0)
      ABSS(2) = -ABSS(1)
      WGHT(1) = 1.0D0
      WGHT(2) = 1.0D0
C
      END
C
      SUBROUTINE QLIN3(WGHT,IWGHT,ABSS,IABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a 3-point gauss-
C      legendre quadrature formula for use in evaluating a 1d
C      integral over a finite range
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    15 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp(=3))
C      IABSS   dimension of vector ABSS (.ge.nqp(=3))
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of dimension iwght.  contains weights for
C              3-point formula
C      ABSS    vector of dimension iabss.  contains abscissae
C              of points for use in 3-point formula
C      NQP     number of quadrature points (=3)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qlin3(wght, IWGHT, ABSS, IABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IABSS,IERROR,ITEST,IWGHT,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,WGHT
      DIMENSION ABSS(IABSS),WGHT(IWGHT)
      DATA SRNAME/'QLIN3'/
C
      NQP = 3
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      ABSS(1) = 0.2D0*DSQRT(15.0D0)
      ABSS(2) = 0.0D0
      ABSS(3) = -ABSS(1)
      WGHT(1) = 5.0D0/9.0D0
      WGHT(3) = WGHT(1)
      WGHT(2) = 8.0D0/9.0D0
C
      END
C
      SUBROUTINE QLVAL(DIAG,IDIAG,SUB,ISUB,N,EPS,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates all the eigenvalues of a real symmetric
C      tridiagonal matrix or of a full real symmetric matrix
C      that has been reduced to tridiagonal form using
C      SUBROUTINE house
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    15 Oct 1980 (KR)
C
C ARGUMENTS in
C      DIAG    vector of length idiag.  on entry, contains the
C              diagonal elements of the tridiagonal matrix
C      IDIAG   dimension of vector DIAG (.ge.n)
C      SUB     vector of dimension isub.  on entry, contains
C              sub-diagonal elements of tridiagonal matrix in
C              elements sub(2) to sub(n).  sub(1) May be
C              arbitrary.  contents destroyed during execution
C              of SUBROUTINE
C      ISUB    dimension of SUB (.ge.n)
C      N       order of tridiagonal matrix
C      EPS     smallest positive number such that 1.+eps>1.
C      ITEST   error checking option
C
C ARGUMENTS out
C      DIAG    vector of dimension idiag.  on exit, contains
C              eigenvalues in ascending order
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qlval(diag, IDIAG, SUB, ISUB, N, EPS, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,I1,IDIAG,IERROR,II,ISUB,ITEST,J,JTEST,L,M,M1,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION B,C,DIAG,EPS,F,G,H,P,R,S,SUB
      DIMENSION DIAG(IDIAG),SUB(ISUB)
      DATA SRNAME/'QLVAL'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IDIAG.LT.N .OR. ISUB.LT.N) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      IF (N.NE.1) THEN
         DO 1000 I = 2,N
            SUB(I-1) = SUB(I)
 1000    CONTINUE
      END IF
C
      SUB(N) = 0.0D0
      B = 0.0D0
      F = 0.0D0
C
      DO 1080 L = 1,N
         J = 0
         H = EPS* (DABS(DIAG(L))+DABS(SUB(L)))
C
C     Look for small sub-diagonal element
C
         IF (B.LT.H) B = H
         DO 1010 M = L,N
            IF (DABS(SUB(M)).LE.B) GO TO 1020
 1010    CONTINUE
C
 1020    CONTINUE
         IF (M.NE.L) THEN
 1030       CONTINUE
            IF (J.EQ.30) THEN
               GO TO 1090
            ELSE
C
C     Form shift
C
               J = J + 1
               G = DIAG(L)
               H = DIAG(L+1) - G
               IF (DABS(H).GE.DABS(SUB(L))) THEN
C
                  P = 2.0D0*SUB(L)/H
                  R = DSQRT(P*P+1.0D0)
                  DIAG(L) = SUB(L)*P/ (1.0D0+R)
               ELSE
                  P = H*0.5D0/SUB(L)
                  R = DSQRT(P*P+1.0D0)
                  H = P + R
                  IF (P.LT.0.0D0) H = P - R
                  DIAG(L) = SUB(L)/H
               END IF
               H = G - DIAG(L)
               I1 = L + 1
               IF (I1.LE.N) THEN
C
                  DO 1040 I = I1,N
                     DIAG(I) = DIAG(I) - H
 1040             CONTINUE
               END IF
C
C     Ql transformation
C
               F = F + H
               P = DIAG(M)
               C = 1.0D0
               S = 0.0D0
               M1 = M - 1
               DO 1050 II = L,M1
                  I = M1 - II + L
                  G = C*SUB(I)
                  H = C*P
                  IF (DABS(P).LT.DABS(SUB(I))) THEN
                     C = P/SUB(I)
                     R = DSQRT(C*C+1.0D0)
                     SUB(I+1) = S*SUB(I)*R
                     S = 1.0D0/R
                     C = C/R
                  ELSE
                     C = SUB(I)/P
                     R = DSQRT(C*C+1.0D0)
                     SUB(I+1) = S*P*R
                     S = C/R
                     C = 1.0D0/R
                  END IF
                  P = C*DIAG(I) - S*G
                  DIAG(I+1) = H + S* (C*G+S*DIAG(I))
 1050          CONTINUE
C
               SUB(L) = S*P
               DIAG(L) = C*P
               IF (DABS(SUB(L)).GT.B) GO TO 1030
            END IF
         END IF
C
C     Order eigenvalue
C
         P = DIAG(L) + F
         IF (L.NE.1) THEN
            DO 1060 II = 2,L
               I = L - II + 2
               IF (P.GE.DIAG(I-1)) THEN
                  GO TO 1070
               ELSE
                  DIAG(I) = DIAG(I-1)
               END IF
 1060       CONTINUE
         END IF
         I = 1
 1070    CONTINUE
         DIAG(I) = P
 1080 CONTINUE
C
      ITEST = 0
      RETURN
C
 1090 CONTINUE
      IF (JTEST.NE.-1) THEN
         IERROR = 3
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
C
      END IF
      END
C
      SUBROUTINE QLVEC(DIAG,IDIAG,SUB,ISUB,T,IT,JT,N,EPS,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates all the eigenvalues and eigenvectors of a
C      real symmetric tridiagonal matrix, or of a full real
C      symmetric matrix reduced to tridiagonal form by
C      SUBROUTINE house
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    16 Oct 1980 (KR)
C
C ARGUMENTS in
C      DIAG    vector of length idiag.  on entry, contains
C              diagonal elements of tridiagonal matrix
C      IDIAG   dimension of vector DIAG (.ge.n)
C      SUB     vector of length isub.  on entry, contains
C              sub-diagonal elements of tridiagonal matrix in
C              sub(2) to sub(n).  on exit, contents of SUB are
C              destroyed
C      ISUB    dimension of vector SUB (.ge.n)
C      T       array of dimension (it,jt).  there are two modes
C              of operation:
C                (I)  eigen vectors of tridiagonal matrix
C                     on entry T should contain the identity
C                     matrix of order N
C                (II) eigenvectors of full symmetric matrix
C                     on entry T should contain the orthogonal
C                     matrix obtained from SUBROUTINE house
C      IT      first dimension of array T (.ge.n)
C      JT      second dimension of T (.ge.n)
C      N       order of tridiagonal matrix
C      EPS     smallest positive number such that 1.+eps>1.
C      ITEST   error checking option
C
C ARGUMENTS out
C      DIAG    vector of dimension idiag.  on exit, contains
C              the eigenvalues in ascending order
C      T       array of dimension (it,jt).  on exit, T contains
C              the normalised eigenvectors , with t(i,j),
C              i=1(1)n containing the eigenvector corresponding
C              to the eigenvalue in diag(j)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qlvec(diag, IDIAG, SUB, ISUB, T, IT, JT, N, EPS,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,I1,IDIAG,IERROR,II,ISUB,IT,ITEST,J,JT,JTEST,K,L,
     *        M,M1,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION B,C,DIAG,EPS,F,G,H,P,R,S,SUB,T
      DIMENSION DIAG(IDIAG),SUB(ISUB),T(IT,JT)
      DATA SRNAME/'QLVEC'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (IT.LT.N .OR. JT.LT.N) IERROR = 3
         IF (IDIAG.LT.N .OR. ISUB.LT.N) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      IF (N.NE.1) THEN
         DO 1000 I = 2,N
            SUB(I-1) = SUB(I)
 1000    CONTINUE
      END IF
C
      SUB(N) = 0.0D0
      B = 0.0D0
      F = 0.0D0
      DO 1070 L = 1,N
         J = 0
         H = EPS* (DABS(DIAG(L))+DABS(SUB(L)))
C
C     Look for small sub-diagonal element
C
         IF (B.LT.H) B = H
         DO 1010 M = L,N
            IF (DABS(SUB(M)).LE.B) GO TO 1020
 1010    CONTINUE
C
 1020    CONTINUE
         IF (M.NE.L) THEN
 1030       CONTINUE
            IF (J.EQ.30) THEN
               GO TO 1110
            ELSE
C
C     Form shift
C
               J = J + 1
               G = DIAG(L)
               H = DIAG(L+1) - G
               IF (DABS(H).GE.DABS(SUB(L))) THEN
                  P = 2.0D0*SUB(L)/H
                  R = DSQRT(P*P+1.0D0)
                  DIAG(L) = SUB(L)*P/ (1.0D0+R)
               ELSE
                  P = H*0.5D0/SUB(L)
                  R = DSQRT(P*P+1.0D0)
                  H = P + R
                  IF (P.LT.0.0D0) H = P - R
                  DIAG(L) = SUB(L)/H
               END IF
               H = G - DIAG(L)
               I1 = L + 1
               IF (I1.LE.N) THEN
                  DO 1040 I = I1,N
                     DIAG(I) = DIAG(I) - H
 1040             CONTINUE
               END IF
C
C     Ql transformation
C
               F = F + H
               P = DIAG(M)
               C = 1.0D0
               S = 0.0D0
               M1 = M - 1
               DO 1060 II = L,M1
                  I = M1 - II + L
                  G = C*SUB(I)
                  H = C*P
                  IF (DABS(P).LT.DABS(SUB(I))) THEN
                     C = P/SUB(I)
                     R = DSQRT(C*C+1.0D0)
                     SUB(I+1) = S*SUB(I)*R
                     S = 1.0D0/R
                     C = C/R
                  ELSE
                     C = SUB(I)/P
                     R = DSQRT(C*C+1.0D0)
                     SUB(I+1) = S*P*R
                     S = C/R
                     C = 1.0D0/R
                  END IF
                  P = C*DIAG(I) - S*G
C
C     Form vector
C
                  DIAG(I+1) = H + S* (C*G+S*DIAG(I))
                  DO 1050 K = 1,N
                     H = T(K,I+1)
                     T(K,I+1) = S*T(K,I) + C*H
                     T(K,I) = C*T(K,I) - S*H
 1050             CONTINUE
 1060          CONTINUE
C
               SUB(L) = S*P
               DIAG(L) = C*P
               IF (DABS(SUB(L)).GT.B) GO TO 1030
            END IF
         END IF
         DIAG(L) = DIAG(L) + F
 1070 CONTINUE
C
C     Order eigenvalues and eigenvectors
C
      DO 1100 I = 1,N
         K = I
         P = DIAG(I)
         I1 = I + 1
         IF (I1.LE.N) THEN
            DO 1080 J = I1,N
               IF (DIAG(J).LT.P) THEN
                  K = J
                  P = DIAG(J)
               END IF
 1080       CONTINUE
         END IF
C
         IF (K.NE.I) THEN
            DIAG(K) = DIAG(I)
            DIAG(I) = P
            DO 1090 J = 1,N
               P = T(J,I)
               T(J,I) = T(J,K)
               T(J,K) = P
 1090       CONTINUE
         END IF
 1100 CONTINUE
C
      ITEST = 0
      RETURN
C
 1110 CONTINUE
      IF (JTEST.NE.-1) THEN
         IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
      END IF
C
      END
C
      SUBROUTINE QQUA4(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a 4-point gaussian
C      product quadrature rule for use in evaluating the
C      integral of a 2d function over a rectangular region
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    16 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp)
C      IABSS   first dimension of array ABSS (.ge.2)
C      JABSS   second dimension of array ABSS (.ge.nqp)
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of dimension iwght.  contains weights to
C              be used in 4-point formula
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of points to be used in formula
C      NQP     number of points to be used in formula (=4)
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE qqua4(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,AREA,WGHT
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QQUA4'/
C
      NQP = 4
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.2 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      AREA = 4.0D0
      WGHT(1) = AREA*0.25D+0
      WGHT(2) = WGHT(1)
      WGHT(3) = WGHT(1)
      WGHT(4) = WGHT(1)
C
      ABSS(1,1) = -1.0D0/DSQRT(3.0D0)
      ABSS(1,2) = ABSS(1,1)
      ABSS(1,3) = +1.0D0/DSQRT(3.0D0)
      ABSS(1,4) = ABSS(1,3)
      ABSS(2,1) = -1.0D0/DSQRT(3.0D0)
      ABSS(2,2) = +1.0D0/DSQRT(3.0D0)
      ABSS(2,3) = ABSS(2,2)
      ABSS(2,4) = ABSS(2,1)
C
      END
C
      SUBROUTINE QQUA9(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a 9-point gaussian
C      product quadrature rule for evaluating the integral of a
C      2d function over a rectangular region
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    16 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp)
C      IABSS   first dimension of array ABSS (.ge.2)
C      JABSS   second dimension of array ABSS (.ge.nqp)
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of length iwght.  contains weights to be
C              used in quadrature formula
C      ABSS    contains abscissae of points to be used in
C              formula
C      NQP     number of quadrature points (=9)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qqua9(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,AREA,WGHT,XY
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QQUA9'/
C
      NQP = 9
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.2 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      AREA = 4.0D0
      WGHT(1) = AREA*25.0D0/324.0D0
      WGHT(3) = WGHT(1)
      WGHT(5) = WGHT(1)
      WGHT(7) = WGHT(1)
      WGHT(2) = AREA*10.0D0/81.0D0
      WGHT(4) = WGHT(2)
      WGHT(6) = WGHT(2)
      WGHT(8) = WGHT(2)
      WGHT(9) = AREA*16.0D0/81.0D0
C
      XY = DSQRT(3.0D0/5.0D0)
      ABSS(1,1) = -XY
      ABSS(2,1) = -XY
      ABSS(1,2) = -XY
      ABSS(2,2) = 0.0D0
      ABSS(1,3) = -XY
      ABSS(2,3) = XY
      ABSS(1,4) = 0.0D0
      ABSS(2,4) = XY
      ABSS(1,5) = XY
      ABSS(2,5) = XY
      ABSS(1,6) = XY
      ABSS(2,6) = 0.0D0
      ABSS(1,7) = XY
      ABSS(2,7) = -XY
      ABSS(1,8) = 0.0D0
      ABSS(2,8) = -XY
      ABSS(1,9) = 0.0D0
      ABSS(2,9) = 0.0D0
C
      END
C
      SUBROUTINE QTET4(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a 4-point rule for
C      evaluating the integral of a 3d function over a
C      tetrahedral region
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0   6 Oct 1980 (CG)
C      Commented    16 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp)
C      IABSS   first dimension of array ABSS (.ge.3)
C      JABSS   second dimension of array ABSS (.ge.nqp)
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of dimension iwght.  contains weights for
C              4-point quadrature rule
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of points to be used in quadrature
C              rule
C      NQP     number of quadrature points (=4)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qtet4(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,ALPHA,BETA,GAMA,WGHT
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QTET4'/
C
      NQP = 4
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.3 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      ALPHA = 0.223807D0
      BETA = 0.387298D0
      GAMA = 0.158114D0
C
      DO 1000 I = 1,4
         WGHT(I) = 1.0D0/16.0D0*DSQRT(6.0D0)
 1000 CONTINUE
C
      ABSS(1,1) = 2.0D0*ALPHA
      ABSS(2,1) = 0.0D0
      ABSS(3,1) = -GAMA
      ABSS(1,2) = -ALPHA
      ABSS(2,2) = -BETA
      ABSS(3,2) = -GAMA
      ABSS(1,3) = -ALPHA
      ABSS(2,3) = BETA
      ABSS(3,3) = -GAMA
      ABSS(1,4) = 0.0D0
      ABSS(2,4) = 0.0D0
      ABSS(3,4) = 3.0D0*GAMA
C
      END
C
      SUBROUTINE QTRI4(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a 4-point gauss-type
C      quadrature rule for evaluating the integral of a 2d
C      function over a triangular region
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    21 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp)
C      IABSS   first dimension of array ABSS (.ge.2)
C      JABSS   second dimension of array ABSS (.ge.nqp)
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of length IWGHT, containing NQP weights
C              of quadrature formula
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of points to be used in quadrature
C              rule
C      NQP     number of quadrature points (=4)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qtri4(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,AREA,WGHT
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QTRI4'/
C
      NQP = 4
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.2 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      AREA = 3.0D0*DSQRT(3.0D0)/4.0D0
C
      WGHT(1) = AREA*1.0D0/12.0D0
      WGHT(2) = AREA*1.0D0/12.0D0
      WGHT(3) = AREA*1.0D0/12.0D0
      WGHT(4) = AREA*3.0D0/4.0D0
C
      ABSS(1,1) = 1.0D0
      ABSS(2,1) = 0.0D0
      ABSS(1,2) = -0.5D0
      ABSS(2,2) = -DSQRT(3.0D0)/2.0D0
      ABSS(1,3) = -0.5D0
      ABSS(2,3) = +DSQRT(3.0D0)/2.0D0
      ABSS(1,4) = 0.0D0
      ABSS(2,4) = 0.0D0
C
      END
C
      SUBROUTINE QTRI7(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae of a 7-point gauss-type
C      quadrature rule for evaluating the integral of a 2d
C      function over a triangular region
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    21 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp)
C      IABSS   first dimension of array ABSS (.ge.2)
C      JABSS   second dimension of array ABSS (.ge.nqp)
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of length IWGHT, containing NQP weights
C              of quadrature formula
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of points to be used in quadrature
C              rule
C      NQP     number of quadrature points (=7)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qtri7(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,AREA,WGHT
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QTRI7'/
C
      NQP = 7
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.2 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      AREA = 3.0D0*DSQRT(3.0D0)/4.0D0
      WGHT(1) = AREA*3.0D0/60.0D0
      WGHT(2) = AREA*8.0D0/60.0D0
      WGHT(3) = WGHT(1)
      WGHT(4) = WGHT(2)
      WGHT(5) = WGHT(1)
      WGHT(6) = WGHT(2)
      WGHT(7) = AREA*27.0D0/60.0D0
C
      ABSS(1,1) = 1.0D0
      ABSS(1,2) = 0.25D0
      ABSS(1,3) = -0.5D0
      ABSS(1,4) = -0.5D0
      ABSS(1,5) = -0.5D0
      ABSS(1,6) = 0.25D0
      ABSS(1,7) = 0.0D0
      ABSS(2,1) = 0.0D0
      ABSS(2,2) = -DSQRT(3.0D0)/4.0D0
      ABSS(2,3) = -DSQRT(3.0D0)/2.0D0
      ABSS(2,4) = 0.0D0
      ABSS(2,5) = DSQRT(3.0D0)/2.0D0
      ABSS(2,6) = DSQRT(3.0D0)/4.0D0
      ABSS(2,7) = 0.0D0
C
      END
C
      SUBROUTINE QUAM12(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and their
C      derivatives at a specified point for an 12-noded c0
C      continuous quadrilateral element.  the approximated
C      function will be continuous across element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    21 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    length of vector FUN (.ge.12)
C      IDER    first dimension of array DER (.ge.2)
C      JDER    second dimension of array DER (.ge.12)
C      XI      first local coordinate
C      ETA     second local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of length ifun.  fun(i) contains the
C              value of the i'th shape function at (xi,eta)
C              for i=1(1)12
C      DER     array of dimension (ider,jder).  der(i,j)
C              contains the value of the derivative of the j'th
C              shape function with respect to the i'th
C              coordinate, for i=1(1)2 and j=1(1)12
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE quam12(fun, IFUN, DER, IDER, JDER, XI, ETA, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,ETA,FUN,VAL,VEPS,XI
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'QUAM12'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.12) IERROR = 1
         IF (IDER.LT.2 .OR. JDER.LT.12) IERROR = 2
         VAL = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.VAL .OR. DABS(ETA).GT.VAL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      FUN(1) = 1.0D0/32.0D0* (1.0D0-XI)* (1.0D0-ETA)*
     *         (-10.0D0+9.0D0* (XI*XI+ETA*ETA))
      FUN(2) = 9.0D0/32.0D0* (1.0D0-XI)* (1.0D0-ETA*ETA)*
     *         (1.0D0-3.0D0*ETA)
      FUN(3) = 9.0D0/32.0D0* (1.0D0-XI)* (1.0D0-ETA*ETA)*
     *         (1.0D0+3.0D0*ETA)
      FUN(4) = 1.0D0/32.0D0* (1.0D0-XI)* (1.0D0+ETA)*
     *         (-10.0D0+9.0D0* (XI*XI+ETA*ETA))
      FUN(5) = 9.0D0/32.0D0* (1.0D0+ETA)* (1.0D0-XI*XI)*
     *         (1.0D0-3.0D0*XI)
      FUN(6) = 9.0D0/32.0D0* (1.0D0+ETA)* (1.0D0-XI*XI)*
     *         (1.0D0+3.0D0*XI)
      FUN(7) = 1.0D0/32.0D0* (1.0D0+XI)* (1.0D0+ETA)*
     *         (-10.0D0+9.0D0* (XI*XI+ETA*ETA))
      FUN(8) = 9.0D0/32.0D0* (1.0D0+XI)* (1.0D0-ETA*ETA)*
     *         (1.0D0+3.0D0*ETA)
      FUN(9) = 9.0D0/32.0D0* (1.0D0+XI)* (1.0D0-ETA*ETA)*
     *         (1.0D0-3.0D0*ETA)
      FUN(10) = 1.0D0/32.0D0* (1.0D0+XI)* (1.0D0-ETA)*
     *          (-10.0D0+9.0D0* (XI*XI+ETA*ETA))
      FUN(11) = 9.0D0/32.0D0* (1.0D0-ETA)* (1.0D0-XI*XI)*
     *          (1.0D0+3.0D0*XI)
      FUN(12) = 9.0D0/32.0D0* (1.0D0-ETA)* (1.0D0-XI*XI)*
     *          (1.0D0-3.0D0*XI)
C
      DER(1,1) = 1.0D0/32.0D0* (1.0D0-ETA)*
     *           (10.D0-27.D0*XI*XI+18.D0*XI-9.D0*ETA*ETA)
      DER(2,1) = 1.D0/32.D0* (1.D0-XI)*
     *           (10.D0-27.D0*ETA*ETA+18.D0*ETA-9.D0*XI*XI)
      DER(1,2) = -9.D0/32.D0* (1.D0-ETA*ETA)* (1.D0-3.D0*ETA)
      DER(2,2) = 9.D0/32.D0* (1.D0-XI)* (9.D0*ETA*ETA-2.D0*ETA-3.D0)
      DER(1,3) = -9.D0/32.D0* (1.D0-ETA*ETA)* (1.D0+3.D0*ETA)
      DER(2,3) = 9.D0/32.D0* (1.D0-XI)* (-9.D0*ETA*ETA-2.D0*ETA+3.D0)
      DER(1,4) = 1.D0/32.D0* (1.D0+ETA)*
     *           (10.D0-27.D0*XI*XI+18.D0*XI-9.D0*ETA*ETA)
      DER(2,4) = 1.D0/32.D0* (1.D0-XI)*
     *           (-10.D0+27.D0*ETA*ETA+18.D0*ETA+9.D0*XI*XI)
      DER(1,5) = 9.D0/32.D0* (1.D0+ETA)* (9.D0*XI*XI-2.D0*XI-3.D0)
      DER(2,5) = 9.D0/32.D0* (1.D0-XI*XI)* (1.D0-3.D0*XI)
      DER(1,6) = 9.D0/32.D0* (1.D0+ETA)* (3.D0-2.D0*XI-9.D0*XI*XI)
      DER(2,6) = 9.D0/32.D0* (1.D0-XI*XI)* (1.D0+3.D0*XI)
      DER(1,7) = 1.D0/32.D0* (1.D0+ETA)*
     *           (-10.D0+27.D0*XI*XI+18.D0*XI+9.D0*ETA*ETA)
      DER(2,7) = 1.D0/32.D0* (1.D0+XI)*
     *           (-10.D0+27.D0*ETA*ETA+18.D0*ETA+9.D0*XI*XI)
      DER(1,8) = 9.D0/32.D0* (1.D0-ETA*ETA)* (1.D0+3.D0*ETA)
      DER(2,8) = 9.D0/32.D0* (1.D0+XI)* (3.D0-2.D0*ETA-9.D0*ETA*ETA)
      DER(1,9) = 9.D0/32.D0* (1.D0-ETA*ETA)* (1.D0-3.D0*ETA)
      DER(2,9) = 9.D0/32.D0* (1.D0+XI)* (9.D0*ETA*ETA-2.D0*ETA-3.D0)
      DER(1,10) = 1.D0/32.D0* (1.D0-ETA)*
     *            (-10.D0+27.D0*XI*XI+18.D0*XI+9.D0*ETA*ETA)
      DER(2,10) = 1.D0/32.D0* (1.D0+XI)*
     *            (10.D0-27.D0*ETA*ETA+18.D0*ETA-9.D0*XI*XI)
      DER(1,11) = 9.D0/32.D0* (1.D0-ETA)* (3.D0-2.D0*XI-9.D0*XI*XI)
      DER(2,11) = -9.D0/32.D0* (1.D0-XI*XI)* (1.D0+3.D0*XI)
      DER(1,12) = 9.D0/32.D0* (1.D0-ETA)* (9.D0*XI*XI-2.D0*XI-3.D0)
      DER(2,12) = -9.D0/32.D0* (1.D0-XI*XI)* (1.D0-3.D0*XI)
C
      END
C
      SUBROUTINE QUAM4(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and their
C      derivatives at a specified point for a 4-noded c0
C      continuous quadrilateral element.  the approximated
C      function will be continuous across element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    21 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    length of vector FUN (.ge.4)
C      IDER    first dimension of array DER (.ge.2)
C      JDER    second dimension of array DER (.ge.4)
C      XI      first local coordinate value
C      ETA     second local coordinate value
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of length ifun.  fun(i) contains the
C              value of the i'th shape function at the point
C              (xi,eta)
C      DER     array of dimension (ider,jder).  der(i,j)
C              contains the value of the derivative of the j'th
C              shape function with respect to the i'th
C              coordinate at the point (xi,eta)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE quam4(fun, IFUN, DER, IDER, JDER, XI, ETA, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,ETA,ETAM,ETAP,FUN,VAL,VEPS,XI,XIM,XIP
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'QUAM4'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.4) IERROR = 1
         IF (IDER.LT.2 .OR. JDER.LT.4) IERROR = 2
         VAL = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.VAL .OR. DABS(ETA).GT.VAL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      ETAM = 0.250D0* (1.0D0-ETA)
      ETAP = 0.250D0* (1.0D0+ETA)
      XIM = 0.250D0* (1.0D0-XI)
      XIP = 0.250D0* (1.0D0+XI)
C
      FUN(1) = 4.0D0*XIM*ETAM
      FUN(2) = 4.0D0*XIM*ETAP
      FUN(3) = 4.0D0*XIP*ETAP
      FUN(4) = 4.0D0*XIP*ETAM
C
      DER(1,1) = -ETAM
      DER(2,1) = -XIM
      DER(1,2) = -ETAP
      DER(2,2) = XIM
      DER(1,3) = ETAP
      DER(2,3) = XIP
      DER(1,4) = ETAM
      DER(2,4) = -XIP
C
      END
C
      SUBROUTINE QUAM8(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and their
C      derivatives at a specified point for an 8-noded c0
C      continuous quadrilateral element.  the approximated
C      function will be continuous across element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    21 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    length of vector FUN (.ge.8)
C      IDER    first dimension of array DER (.ge.2)
C      JDER    second dimension of array DER (.ge.8)
C      XI      first local coordinate
C      ETA     second local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of length ifun.  fun(i) contains the
C              value of the i'th shape function at (xi,eta)
C              for i=1(1)8
C      DER     array of dimension (ider,jder).  der(i,j)
C              contains the value of the derivative of the j'th
C              shape function with respect to the i'th
C              coordinate, for i=1(1)2 and j=1(1)8
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE quam8(fun, IFUN, DER, IDER, JDER, XI, ETA, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,ETA,ETAM,ETAP,FUN,VAL,VEPS,XI,XIM,XIP
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'QUAM8'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.8) IERROR = 1
         IF (IDER.LT.2 .OR. JDER.LT.8) IERROR = 2
         VAL = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.VAL .OR. DABS(ETA).GT.VAL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      ETAM = 0.250D0* (1.0D0-ETA)
      ETAP = 0.250D0* (1.0D0+ETA)
      XIM = 0.250D0* (1.0D0-XI)
      XIP = 0.250D0* (1.0D0+XI)
C
      DER(1,1) = ETAM* (2.0D0*XI+ETA)
      DER(1,2) = -8.0D0*ETAM*ETAP
      DER(1,3) = ETAP* (2.0D0*XI-ETA)
      DER(1,4) = -4.0D0*ETAP*XI
      DER(1,5) = ETAP* (2.0D0*XI+ETA)
      DER(1,6) = 8.0D0*ETAP*ETAM
      DER(1,7) = ETAM* (2.0D0*XI-ETA)
      DER(1,8) = -4.0D0*ETAM*XI
      DER(2,1) = XIM* (XI+2.0D0*ETA)
      DER(2,2) = -4.0D0*XIM*ETA
      DER(2,3) = XIM* (2.0D0*ETA-XI)
      DER(2,4) = 8.0D0*XIM*XIP
      DER(2,5) = XIP* (XI+2.0D0*ETA)
      DER(2,6) = -4.0D0*XIP*ETA
      DER(2,7) = XIP* (2.0D0*ETA-XI)
      DER(2,8) = -8.0D0*XIM*XIP
C
      FUN(1) = 4.0D0*ETAM*XIM* (-XI-ETA-1.0D0)
      FUN(2) = 32.0D0*XIM*ETAM*ETAP
      FUN(3) = 4.0D0*ETAP*XIM* (-XI+ETA-1.0D0)
      FUN(4) = 32.0D0*XIM*XIP*ETAP
      FUN(5) = 4.0D0*XIP*ETAP* (XI+ETA-1.0D0)
      FUN(6) = 32.0D0*XIP*ETAP*ETAM
      FUN(7) = 4.0D0*XIP*ETAM* (XI-ETA-1.0D0)
      FUN(8) = 32.0D0*XIM*XIP*ETAM
C
      END
C
      SUBROUTINE QWDG6(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae for a 6-point quadrature
C      rule for evaluating the integral of a 3d function over
C      a pentahedral region
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0   6 Oct 1980 (CG)
C      Commented    21 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp(=6))
C      IABSS   first dimension array ABSS (.ge.3)
C      JABSS   second dimension of array ABSS (.ge.nqp(=6))
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of length iwght.  contains weights of
C              quadrature rule
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of quadrature points
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qwdg6(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,WGHT
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QWDG6'/
C
      NQP = 6
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.3 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1000 I = 1,6
         WGHT(I) = 1.0D0/4.0D0*DSQRT(3.0D0)
 1000 CONTINUE
C
      ABSS(1,1) = 0.0D0
      ABSS(2,1) = 0.0D0
      ABSS(3,1) = -1.0D0
      ABSS(1,2) = -0.5D0
      ABSS(2,2) = -DSQRT(3.0D0)/2.0D0
      ABSS(3,2) = -1.0D0
      ABSS(1,3) = -0.5D0
      ABSS(2,3) = DSQRT(3.0D0)/2.0D0
      ABSS(3,3) = -1.0D0
      ABSS(1,4) = 0.0D0
      ABSS(2,4) = 0.0D0
      ABSS(3,4) = 1.0D0
      ABSS(1,5) = -0.5D0
      ABSS(2,5) = -DSQRT(3.0D0)/2.0D0
      ABSS(3,5) = 1.0D0
      ABSS(1,6) = -0.5D0
      ABSS(2,6) = DSQRT(3.0D0)/2.0D0
      ABSS(3,6) = 1.0D0
C
      END
C
      SUBROUTINE QWDG8(WGHT,IWGHT,ABSS,IABSS,JABSS,NQP,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns weights and abscissae for a 8-point quadrature
C      rule for evaluating the integral of a 3d function over
C      a pentahedral region
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0   6 Oct 1980 (CG)
C      Commented    21 Oct 1980 (KR)
C
C ARGUMENTS in
C      IWGHT   dimension of vector WGHT (.ge.nqp(=8))
C      IABSS   first dimension array ABSS (.ge.3)
C      JABSS   second dimension of array ABSS (.ge.nqp(=8))
C      ITEST   error checking option
C
C ARGUMENTS out
C      WGHT    vector of length iwght.  contains weights of
C              quadrature rule
C      ABSS    array of dimension (iabss,jabss).  contains
C              abscissae of quadrature points
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE qwdg8(wght, IWGHT, ABSS, IABSS, JABSS, NQP, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IABSS,IERROR,ITEST,IWGHT,JABSS,NQP
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ABSS,W,WGHT
      DIMENSION ABSS(IABSS,JABSS),WGHT(IWGHT)
      DATA SRNAME/'QWDG8'/
C
      NQP = 8
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IWGHT.LT.NQP) IERROR = 1
         IF (IABSS.LT.3 .OR. JABSS.LT.NQP) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      W = (3.D0*DSQRT(3.D0))/2.D0
      WGHT(1) = (3.0D0/8.0D0)*W
      WGHT(2) = (3.0D0/8.0D0)*W
      DO 1000 I = 3,8
         WGHT(I) = (1.0D0/24.0D0)*W
 1000 CONTINUE
C
      ABSS(1,1) = 0.0D0
      ABSS(2,1) = 0.0D0
      ABSS(3,1) = 1.0D0
      ABSS(1,2) = 0.0D0
      ABSS(2,2) = 0.0D0
      ABSS(3,2) = -1.0D0
      ABSS(1,3) = 1.0D0
      ABSS(2,3) = 0.0D0
      ABSS(3,3) = -1.0D0
      ABSS(1,4) = -0.5D0
      ABSS(2,4) = DSQRT(3.0D0)/2.0D0
      ABSS(3,4) = -1.0D0
      ABSS(1,5) = -0.5D0
      ABSS(2,5) = -ABSS(2,4)
      ABSS(3,5) = -1.0D0
      ABSS(1,6) = 1.0D0
      ABSS(2,6) = 0.0D0
      ABSS(3,6) = 1.0D0
      ABSS(1,7) = -0.5D0
      ABSS(2,7) = ABSS(2,4)
      ABSS(3,7) = 1.0D0
      ABSS(1,8) = -0.5D0
      ABSS(2,8) = ABSS(2,5)
      ABSS(3,8) = 1.0D0
C
      END
C
      SUBROUTINE RASRHS(RHS,IRHS,VALUE,IVALUE,STEER,ISTEER,DOFEL,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      the routine adds into the right-hand side of a system
C      the values contianed in an element vector, thus forming
C      the right-hand side VALUE is real, RHS is complex.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0   1 Jul 1985 (crie)
C      Commented     1 Nov 1985 (CG)
C
C ARGUMENTS in
C      RHS     the right-hand side of the system
C              complex ( ordered pairs )
C      IRHS    dimension of array rsh
C      VALUE   the element vector of the current element to
C              be added into the right-hand side
C      ivale   dimension of array VALUE
C      STEER   the steering vector containing the freedom
C              numbers of the freedoms associated with the
C              current element in the local order
C      ISTEER  dimension of array STEER
C      DOFEL   the maximum number of degrees of freedom on
C              an element of the current type
C      ITEST   error checking option
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE rasrhs(rhs,irhs,value,ivalue,steer,isteer,
C    *     dofel,itest)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFEL,ERRMES,IERROR,IRHS,ISTEER,ITEST,IVALUE,K,L,STEER,
     *        JTEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION RHS,VALUE
      DIMENSION RHS(2,IRHS),STEER(ISTEER),VALUE(IVALUE)
      DATA SRNAME/'RASRHS'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 3
         IF (IVALUE.LT.DOFEL) IERROR = 2
         IF (DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1000 K = 1,DOFEL
         IF (STEER(K).NE.0) THEN
            L = STEER(K)
            IF (JTEST.NE.-1) THEN
               IERROR = 0
               IF (L.GT.IRHS) IERROR = 4
               ITEST = ERRMES(ITEST,IERROR,SRNAME)
               IF (ITEST.NE.0) RETURN
            END IF
            RHS(1,L) = RHS(1,L) + VALUE(K)
         END IF
 1000 CONTINUE
C
      END
C
      SUBROUTINE RASSYM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
     *                  HBAND,DOFEL,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      for real symmetric system matrix, adds the contribution
C      from an element matrix into real part of a comple SYSK
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1984 (crie)
C      Commented     7 Feb 1985 (CG)
C
C ARGUMENTS in
C      SYSK    contains system matrix prior to addition of
C              current element matrix contribution
C              where SYSK is complex ( as ordered pairs )
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. HBAND)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL)
C      JELK    second dimension of ELK (.GE. DOFEL)
C      STEER   contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTEER  first dimension of STEER (.GE. DOFEL)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL   maximum degrees of freedom associated with
C              element type
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    system matrix - ordered pairs
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE rassym(sysk, ISYSK, JSYSK, ELK, IELK, JELK,
C    *     STEER, ISTEER, HBAND, DOFEL, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER CD,DOFEL,ERRMES,HBAND,I,IELK,IERROR,ISTEER,ISYSK,ITEST,J,
     *        JELK,JSYSK,STEER,STEERI,JTEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STEER(ISTEER),SYSK(2,ISYSK,JSYSK)
      DATA SRNAME/'RASSYM'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 4
         IF (IELK.LT.DOFEL .OR. JELK.LT.DOFEL) IERROR = 3
         IF (JSYSK.LT.HBAND) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1010 I = 1,DOFEL
         IF (STEER(I).NE.0) THEN
            DO 1000 J = 1,DOFEL
               IF (STEER(J).NE.0) THEN
                  CD = STEER(J) - STEER(I) + HBAND
                  IF (CD.LE.HBAND) THEN
                     STEERI = STEER(I)
                     IF (JTEST.NE.-1) THEN
                        IERROR = 0
                        IF (ISYSK.LT.STEERI) IERROR = 4
                        ITEST = ERRMES(ITEST,IERROR,SRNAME)
                        IF (ITEST.NE.0) RETURN
                     END IF
                     SYSK(1,STEERI,CD) = SYSK(1,STEERI,CD) + ELK(I,J)
                  END IF
               END IF
 1000       CONTINUE
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE RASUSM(SYSK,ISYSK,JSYSK,ELK,IELK,JELK,STEER,ISTEER,
     *                  HBAND,DOFEL,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      for complex unsymmetric system matrix, assembles
C      contribution from a real element matrix into the
C      real part of a complex system matrix
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1985 (CG)
C
C ARGUMENTS in
C      SYSK    contains system matrix into which contributions
C              from current element matrix are to be assembled
C      ISYSK   first dimension of SYSK (.GE. total number of
C              unconstrained degrees of freedom)
C      JSYSK   second dimension of SYSK (.GE. 2*hband-1)
C      ELK     element matrix
C      IELK    first dimension of ELK (.GE. DOFEL)
C      JELK    second dimension of ELK (.GE. DOFEL)
C      STEER   contains freedom numbers associated with element
C              matrix contributions to system matrix
C      ISTEER  first dimension of STEER (.GE. DOFEL)
C      HBAND   semi-bandwidth of system matrix, including
C              diagonal
C      DOFEL   maximum number of degrees of freedom associated
C              with this element type
C      ITEST   error checking option
C
C ARGUMENTS out
C      SYSK    complex system matrix (stored as ordered pairs)
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE rasusm(sysk, ISYSK, JSYSK, ELK, IELK, JELK,
C    *      STEER, ISTEER, HBAND, DOFEL, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DOFEL,ERRMES,HBAND,I,IELK,IERROR,ISTEER,ISYSK,ITEST,J,
     *        JELK,JSYSK,JTEST,OFFSET,STEER,STEERI,STEERJ
      CHARACTER*6 SRNAME
      DOUBLE PRECISION ELK,SYSK
      DIMENSION ELK(IELK,JELK),STEER(ISTEER),SYSK(2,ISYSK,JSYSK)
      DATA SRNAME/'RASUSM'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.DOFEL) IERROR = 4
         IF (IELK.LT.DOFEL .OR. JELK.LT.DOFEL) IERROR = 3
         IF (JSYSK.LT.2*HBAND-1) IERROR = 2
         IF (HBAND.LE.0 .OR. DOFEL.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1010 I = 1,DOFEL
         STEERI = STEER(I)
         IF (STEERI.GT.0) THEN
            DO 1000 J = 1,DOFEL
               STEERJ = STEER(J)
               IF (STEERJ.GT.0) THEN
                  OFFSET = STEERJ - STEERI + HBAND
C
C     Range checking on STEERI and STEERJ
C
                  IF (JTEST.NE.-1) THEN
                     IERROR = 0
                     IF (ISYSK.LT.STEERI .OR.
     *                   JSYSK.LT.OFFSET) IERROR = 5
                     ITEST = ERRMES(JTEST,IERROR,SRNAME)
                     IF (ITEST.NE.0) RETURN
                  END IF
C
                  SYSK(1,STEERI,OFFSET) = SYSK(1,STEERI,OFFSET) +
     *                                    ELK(I,J)
               END IF
 1000       CONTINUE
C
         END IF
 1010 CONTINUE
C
      END
C
      SUBROUTINE ROD2(FUN,IFUN,DER,IDER,XI,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of the shape functions and their
C      derivatives at a specified point for a 2-noded c0
C      continuous line element.  only the function will be
C      continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    26 Feb 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of the vector FUN (.GE. 2)
C      IDER    dimension of the vector DER (.GE. 2)
C      XI      specifies the value of the local coordinate at
C              which the function and its derivative are
C              required
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     fun(i) contains the value of the i'th shape
C              function at XI
C      DER     der(i) contains the value of the derivative of
C              the i'th shape function at XI
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE rod2(fun, IFUN, DER, IDER, XI, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,FUN,VEPS,XI,XMAX
      DIMENSION DER(IDER),FUN(IFUN)
      DATA SRNAME/'ROD2'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.2 .OR. IDER.LT.2) IERROR = 1
         XMAX = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.XMAX) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      FUN(1) = 0.5D0* (1.0D0-XI)
      FUN(2) = 0.5D0* (1.0D0+XI)
      DER(1) = -0.5D0
      DER(2) = 0.5D0
C
      END
C
      SUBROUTINE ROD3(FUN,IFUN,DER,IDER,XI,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of the shape function and its
C      derivative at a specified point for a 3-noded c0
C      continuous line element.  function continuous across
C      element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    11 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.3)
C      IDER    dimension of vector DER (.ge.3)
C      XI      value of local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of length ifun.  fun(i) contains the
C              value of the i'th shape function at the point XI
C      DER     vector of length ider.  der(i) contains the
C              value of the derivative of the i'th shape
C              function at the point XI
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE rod3(fun, IFUN, DER, IDER, XI, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,FUN,VEPS,XI,XMAX
      DIMENSION DER(IDER),FUN(IFUN)
      DATA SRNAME/'ROD3'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.3 .OR. IDER.LT.3) IERROR = 1
         XMAX = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.XMAX) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      FUN(1) = 0.5D0*XI* (XI-1.0D0)
      FUN(2) = 1.0D0 - XI*XI
      FUN(3) = 0.5D0*XI* (XI+1.0D0)
C
      DER(1) = 0.5D0* (2.0D0*XI-1.0D0)
      DER(2) = -2.0D0*XI
      DER(3) = 0.5D0* (2.0D0*XI+1.0D0)
C
      END
C
      SUBROUTINE ROD4(FUN,IFUN,DER,IDER,XI,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of the shape functions and their
C      derivatives at a specified point for a 4-noded c0
C      continuous element.  function continuous across element
C      boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    11 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.4)
C      IDER    dimension of vector DER (.ge.4)
C      XI      value of local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of dimension ifun.  fun(i) contains the
C              value of the i'th shape function at XI
C      DER     vector of dimension ider.  der(i) contains the
C              value of the derivative of the i'th shape
C              function at XI
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE ROD4 (fun, IFUN, DER, IDER, XI, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,FUN,VEPS,XI,XMAX
      DIMENSION DER(IDER),FUN(IFUN)
      DATA SRNAME/'ROD4'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.4 .OR. IDER.LT.4) IERROR = 1
         XMAX = 1.0D0 + VEPS(DUMMY)
         IF (DABS(XI).GT.XMAX) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      FUN(1) = 1.0D0/16.0D0* (1.0D0-XI)* (9.0D0*XI*XI-1.0D0)
      FUN(2) = 9.0D0/16.0D0* (XI*XI-1.0D0)* (3.0D0*XI-1.0D0)
      FUN(3) = 9.0D0/16.0D0* (1.0D0-XI*XI)* (3.0D0*XI+1.0D0)
      FUN(4) = 1.0D0/16.0D0* (XI+1.0D0)* (9.0D0*XI*XI-1.0D0)
C
      DER(1) = -1.0D0/16.0D0* (-1.0D0-18.0D0*XI+27.0D0*XI*XI)
      DER(2) = 9.0D0/16.0D0* (9.0D0*XI*XI-2.0D0*XI-3.0D0)
      DER(3) = 9.0D0/16.0D0* (3.0D0-2.0D0*XI-9.0D0*XI*XI)
      DER(4) = 1.0D0/16.0D0* (27.0D0*XI*XI+18.0D0*XI-1.0D0)
C
      END
C
      SUBROUTINE SCAPRD(V,IV,W,IW,N,PRODCT,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      forms the scalar product of two vectors V and W, storing
C      the result in PRODCT
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    22 Oct 1980 (KR)
C
C ARGUMENTS in
C      V       vector of length IV
C      IV      dimension of V (.ge.n)
C      W       vector of length IW
C      IW      dimension of W (.ge.n)
C      N       number of elements of V (and W) to be used in
C              forming scalar product
C      ITEST   error checking option
C
C ARGUMENTS out
C      PRODCT  contains: sigma I = 1 to N of (v(i)*w(i))
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE scaprd(v, IV, W, IW, N, PRODCT, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IV,IW,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION PRODCT,V,W
      DIMENSION V(IV),W(IW)
      DATA SRNAME/'SCAPRD'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IW) IERROR = 3
         IF (N.GT.IV) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (IERROR.NE.0) RETURN
      END IF
C
C     Main body
C
      PRODCT = 0.0D0
      DO 1000 I = 1,N
         PRODCT = PRODCT + V(I)*W(I)
 1000 CONTINUE
C
      END
C
      SUBROUTINE SELECT(V,IV,STEER,ISTEER,N,W,IW,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      to construct an element value vector from a full system
C      vector using the steering vector
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Oct 1985 (CG)
C
C ARGUMENTS in
C      V       vector of system values
C      IV      first dimension of vector V
C      STEER   element steering vector - contains freedom nos.
C      ISTEER  first dimension of vector STEER (.ge.n)
C      N       number of freedoms to be assembled
C      IW      first dimension of vector W (.ge.n)
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of element values
C
C ROUTINES called
C      ERRMES
C
C      SUBROUTINE select(v,iv,steer,isteer,n,w,iw,itest)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ISTEER,ITEST,IV,IW,J,N,STEER,JTEST
      CHARACTER*6 SRNAME
      DOUBLE PRECISION V,W
      DIMENSION STEER(ISTEER),V(IV),W(IW)
C
      DATA SRNAME/'SELECT'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (ISTEER.LT.N .OR. IW.LT.N) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main loops
C
      DO 1000 I = 1,N
         W(I) = 0.D0
         J = IABS(STEER(I))
         IF (J.NE.0) THEN
C
            IF (JTEST.NE.-1) THEN
               IERROR = 0
               IF (J.GT.IV) IERROR = 3
               ITEST = ERRMES(JTEST,IERROR,SRNAME)
               IF (ITEST.NE.0) RETURN
            END IF
C
            W(I) = V(J)
         END IF
 1000 CONTINUE
C
      END
C
      SUBROUTINE SHAPFN(N,IN,JN,FUN,IFUN,NODEL,NDE,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      constructs the shape function matrix N for a system of coupled
C      differential equations.  this routine is most frequently used
C      IN forming the consistent element and system mass matrices
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    22 Oct 1980 (KR)
C
C ARGUMENTS IN
C      IN      first dimension of array N (.ge.nde)
C      JN      second dimension of N (.ge.nodel*nde)
C      FUN     vector of length ifun.  contains values of the
C              shape functions at the point where shape
C              function matrix required
C      IFUN    length of vector FUN (.ge.nodel)
C      NODEL   number of shape functions to be used IN
C              constructing shape function matrix N (usually
C              number of nodes IN element under consideration)
C      NDE     number of coupled equations being considered
C      ITEST   error checking option
C
C ARGUMENTS out
C      N       array of dimension (in,jn).  contains the
C              values of the shape function matrix
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE shapfn(n, IN, JN, FUN, IFUN, NODEL, NDE ,itest)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,IFUN,IJ,IN,ITEST,J,JN,NDE,NODEL
      CHARACTER*6 SRNAME
      DOUBLE PRECISION FUN,N
      DIMENSION FUN(IFUN),N(IN,JN)
      DATA SRNAME/'SHAPFN'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (NODEL.LE.0 .OR. NDE.LE.0) IERROR = 1
         IF (IN.LT.NDE .OR. JN.LT.NODEL*NDE) IERROR = 2
         IF (IFUN.LT.NODEL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      CALL MATNUL(N,IN,JN,NDE,NODEL*NDE,ITEST)
C
      DO 1010 J = 1,NODEL
         DO 1000 I = 1,NDE
            IJ = (J-1)*NDE + I
            N(I,IJ) = FUN(J)
 1000    CONTINUE
 1010 CONTINUE
C
      END
C
      SUBROUTINE SIDENO(TOTELS,ELTOP,IELTOP,JELTOP,M,BDCND,IBDCND,
     *                  JBDCND,NUMSID,BLIST,IBLIST,JBLIST,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      the routine generates a list of element and side
C      numbers from a list of boundary nodes. the node list
C      must be a continuous sequence of node in the same
C      sense as the local node ordering.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  Jan 1982 (CG)
C
C ARGUMENTS in
C      TOTELS  the total number of elements in the mesh
C      ELTOP   the element topology array containing element
C              type number, number of nodes on element and
C              topology list
C      IELTOP  first dimension of ELTOP
C      JELTOP  second dimension of ELTOP
C      M       boundary condition list number
C      BDCND   boundary condition array containing boundary
C              condition type, number of nodes on element side
C              number of nodes in list and node list.
C      IBDCND  first dimension of BDCND array
C      JBDCND  second dimension of BDCND array
C      IBLIST  first dimension BLIST
C      JBLIST  second dimension of BLIST
C      ITEST   error checking option
C
C ARGUMENTS out
C      NUMSID  number of element sides generated from the
C              current boundary node list
C      BLIST   array containing element number and side number
C
C ROUTINES called
C      ERRMES
C
C
C
C     SUBROUTINE sideno(totels, ELTOP, IELTOP, JELTOP, M, BDCND,
C    *     IBDCND, JBDCND, NUMSID, BLIST, IBLIST, JBLIST, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER BDCND,BLIST,BNUM1,ELTOP,ERRMES,I,IBDCND,IBLIST,IELTOP,
     *        IERROR,IK,ITEST,J,JBDCND,JBLIST,JELTOP,JTEST,K,L,M,N,N1,
     *        NB,NELE,NODEL,NSIDE1,NUMSID,TOTELS
      CHARACTER*6 SRNAME
      DIMENSION BDCND(IBDCND,JBDCND),BLIST(IBLIST,JBLIST),
     *          ELTOP(IELTOP,JELTOP)
      DATA SRNAME/'SIDENO'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (JBLIST.LT.2) IERROR = 4
         IF (IBDCND.LT.M) IERROR = 3
         IF (IELTOP.LT.TOTELS) IERROR = 2
         IF (TOTELS.LE.0 .OR. M.LE.0) IERROR = 1
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      NSIDE1 = BDCND(M,3) - 1
      BNUM1 = BDCND(M,2) - NSIDE1
      N = 0
      DO 1050 I = 1,BNUM1,NSIDE1
C
C     Range checking on I
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF (I.GT.JBDCND) IERROR = 6
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
         NB = BDCND(M,I+3)
         DO 1030 J = 1,TOTELS
            NODEL = ELTOP(J,2)
            DO 1000 K = 1,NODEL
C
C     Range checking on K
C
               IF (JTEST.NE.-1) THEN
                  IERROR = 0
                  IF (K+2.GT.JELTOP) IERROR = 5
                  ITEST = ERRMES(JTEST,IERROR,SRNAME)
                  IF (ITEST.NE.0) RETURN
               END IF
C
               IF (NB.EQ.ELTOP(J,K+2)) GO TO 1010
 1000       CONTINUE
            GO TO 1030
C
 1010       CONTINUE
            NELE = J
            IF (NODEL.EQ.10) NODEL = NODEL - 1
            N1 = K
            DO 1020 K = 1,NSIDE1
               L = MOD(N1+K-1,NODEL) + 3
               IK = I + K + 3
C
C     Range checking on L
C
               IF (JTEST.NE.-1) THEN
                  IERROR = 0
                  IF (L.GT.JELTOP) IERROR = 5
                  ITEST = ERRMES(JTEST,IERROR,SRNAME)
                  IF (ITEST.NE.0) RETURN
               END IF
C
               IF (BDCND(M,IK).NE.ELTOP(J,L)) GO TO 1030
 1020       CONTINUE
            GO TO 1040
 1030    CONTINUE
         GO TO 1050
C
 1040    CONTINUE
         N = N + 1
C
C     Range checking on N
C
         IF (JTEST.NE.-1) THEN
            IERROR = 0
            IF (N.GT.IBLIST) IERROR = 7
            ITEST = ERRMES(JTEST,IERROR,SRNAME)
            IF (ITEST.NE.0) RETURN
         END IF
C
         BLIST(N,1) = NELE
         BLIST(N,2) = (N1-1)/NSIDE1 + 1
 1050 CONTINUE
C
      NUMSID = N
C
      END
C
      SUBROUTINE SURBRK(XI,ETA,ZETA,GEOM,IGEOM,JGEOM,NODEL,FACNUM,UAREA,
     *                  ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      calculates a unit of area on the face of a
C      brick element (8, 20 or 32 noded)
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1  Feb 1981 (CG)
C      Commented    24 Jul 1981 (CG)
C
C ARGUMENTS in
C      XI      local coordinate of point at which area is
C              required
C      ETA     local coordinate of point at which area is
C              required
C      ZETA    local coordinate of point at which area is
C              required
C      GEOM    local coordinate array containing the global
C              coordiantes of each node on an element in the
C              local order
C      IGEOM   first dimension of array GEOM (.ge.nodel)
C      JGEOM   second dimension of array GEOM (.ge.3)
C      NODEL   number of nodes on the element
C      FACNUM  the face number of the face of the element to
C              be used in calculating the area (.le.6)
C      ITEST   error checking option
C
C ARGUMENTS out
C      UAREA    the unit of area at the specified point
C
C ROUTINES called
C      ERRMES  BRK8  BRK20  BRK32  MATMUL
C
C
C     SUBROUTINE surbrk(xi, ETA, ZETA, GEOM, IGEOM, JGEOM, NODEL,
C    *     FACNUM, UAREA, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER DIMEN,ERRMES,FACNUM,I,IDER,IERROR,IFUN,IGEOM,IJAC,ITEST,J,
     *        JDER,JGEOM,JJAC,JTEST,N,NODEL
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,ETA,FUN,G1,G2,G3,GEOM,JAC,UAREA,XI,ZETA
      DIMENSION DER(3,32),FUN(32),GEOM(IGEOM,JGEOM),JAC(3,3)
      DATA DIMEN/3/,IDER/3/,IFUN/32/,IJAC/3/,JDER/32/,JJAC/3/
      DATA SRNAME/'SURBRK'/
C
C     Parameter checking
C
      JTEST = ITEST
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF ((NODEL.LE.0) .OR. (FACNUM.LE.0)) IERROR = 1
         IF (IGEOM.LT.NODEL .OR. JGEOM.LT.3) IERROR = 2
         IF (FACNUM.LT.1 .OR. FACNUM.GT.6) IERROR = 3
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      N = NODEL/8
C
C     Range checking on N
C
      IF (JTEST.NE.-1) THEN
         IERROR = 0
         IF (N.LE.0 .OR. N.GE.4) IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Get shape function derivatives
C
      GO TO (1020,1000,1010) N
      IF (JTEST.EQ.-1) THEN
         GO TO 1020
      ELSE
         IERROR = 4
         ITEST = ERRMES(JTEST,IERROR,SRNAME)
         RETURN
      END IF
 1000 CONTINUE
      CALL BRK20(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
      GO TO 1030
 1010 CONTINUE
      CALL BRK32(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
      GO TO 1030
C
 1020 CONTINUE
      CALL BRK8(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
C
C     Calculate global derivatives
C
 1030 CONTINUE
      CALL MATMUL(DER,IDER,JDER,GEOM,IGEOM,JGEOM,JAC,IJAC,JJAC,DIMEN,
     *            NODEL,DIMEN,ITEST)
C
      GO TO (1040,1040,1050,1060,1050,1060) FACNUM
      GO TO 1050
C
C     ZETA = constant
C
 1040 CONTINUE
      I = 1
      J = 2
      GO TO 1070
C
C     XI = constant
C
 1050 CONTINUE
      I = 2
      J = 3
      GO TO 1070
C
C     ETA = constant
C
 1060 CONTINUE
      I = 1
      J = 3
C
 1070 CONTINUE
      G1 = JAC(I,2)*JAC(J,3) - JAC(I,3)*JAC(J,2)
      G2 = JAC(I,3)*JAC(J,1) - JAC(I,1)*JAC(J,3)
      G3 = JAC(I,1)*JAC(J,2) - JAC(I,2)*JAC(J,1)
      UAREA = DSQRT(G1**2+G2**2+G3**2)
C
      END
C
      SUBROUTINE TET10(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and derivatives
C      at a specified point for an 10-noded tetrahedral element.
C      the function is continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.10)
C      IDER    first dimension of array DER (.ge.3)
C      JDER    second dimension of array DER (.ge.10)
C      XI      value of local coordinate at which function and
C              derivative values required
C      ETA     value of second local coordinate
C      ZETA    value of third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     real vector of dimension ifun.  fun(i) contains
C              value of i'th shape function at (xi,eta,zeta)
C      DER     real array of dimensions (ider,jder).  der(i,j)
C              contains the derivative of the j'th shape
C              function with respect to the i'th coordinate at
C              the point (xi,eta,zeta)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE tet10(fun, IFUN, DER, IDER, JDER, XI, ETA, ZETA,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DL1X,DL1Y,DL1Z,DL2X,DL2Y,DL2Z,DL3X,DL3Y,DL3Z,
     *                 DL4X,DL4Y,DL4Z,DNSL,DNVL,ETA,FUN,L1,L2,L3,L4,LA,
     *                 LB,NS,NV,XI,ZETA
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'TET10'/
C
C     Statement functions
C
      NV(LA) = (2.D0*LA-1.D0)*LA
      NS(LA,LB) = 4.D0*LA*LB
      DNVL(LA) = 4.D0*LA - 1.D0
      DNSL(LA,LB) = 4.D0*LB
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.10) IERROR = 1
         IF (IDER.LT.3 .OR. JDER.LT.10) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      L1 = 1.D0/12.D0* (3.D0+8.D0*XI-2.D0*DSQRT(2.D0)*ZETA)
      L2 = 1.D0/12.D0* (3.D0-4.D0* (XI+DSQRT(3.D0)*ETA)-
     *     2.D0*DSQRT(2.D0)*ZETA)
      L3 = 1.D0/12.D0* (3.D0-4.D0* (XI-DSQRT(3.D0)*ETA)-
     *     2.D0*DSQRT(2.D0)*ZETA)
      L4 = 1.D0/4.D0* (1.D0+2.D0*DSQRT(2.D0)*ZETA)
C
      DL1X = 2.D0/3.D0
      DL1Y = 0.D0
      DL1Z = -1.D0/ (3.D0*DSQRT(2.D0))
      DL2X = -1.D0/3.D0
      DL2Y = -1.D0/DSQRT(3.D0)
      DL2Z = -1.D0/ (3.D0*DSQRT(2.D0))
      DL3X = -1.D0/3.D0
      DL3Y = 1.D0/DSQRT(3.D0)
      DL3Z = -1.D0/ (3.D0*DSQRT(2.D0))
      DL4X = 0.D0
      DL4Y = 0.D0
      DL4Z = 1.D0/DSQRT(2.D0)
C
C     Shape functions
C
      FUN(1) = NV(L1)
      FUN(2) = NS(L1,L2)
      FUN(3) = NV(L2)
      FUN(4) = NS(L2,L3)
      FUN(5) = NV(L3)
      FUN(6) = NS(L3,L1)
      FUN(7) = NS(L1,L4)
      FUN(8) = NS(L2,L4)
      FUN(9) = NS(L3,L4)
      FUN(10) = NV(L4)
C
C     Derivatives
C
      DER(1,1) = DNVL(L1)*DL1X
      DER(2,1) = DNVL(L1)*DL1Y
      DER(3,1) = DNVL(L1)*DL1Z
      DER(1,2) = DNSL(L1,L2)*DL1X + DNSL(L2,L1)*DL2X
      DER(2,2) = DNSL(L1,L2)*DL1Y + DNSL(L2,L1)*DL2Y
      DER(3,2) = DNSL(L1,L2)*DL1Z + DNSL(L2,L1)*DL2Z
      DER(1,3) = DNVL(L2)*DL2X
      DER(2,3) = DNVL(L2)*DL2Y
      DER(3,3) = DNVL(L2)*DL2Z
      DER(1,4) = DNSL(L2,L3)*DL2X + DNSL(L3,L2)*DL3X
      DER(2,4) = DNSL(L2,L3)*DL2Y + DNSL(L3,L2)*DL3Y
      DER(3,4) = DNSL(L2,L3)*DL2Z + DNSL(L3,L2)*DL3Z
      DER(1,5) = DNVL(L3)*DL3X
      DER(2,5) = DNVL(L3)*DL3Y
      DER(3,5) = DNVL(L3)*DL3Z
      DER(1,6) = DNSL(L3,L1)*DL3X + DNSL(L1,L3)*DL1X
      DER(2,6) = DNSL(L3,L1)*DL3Y + DNSL(L1,L3)*DL1Y
      DER(3,6) = DNSL(L3,L1)*DL3Z + DNSL(L1,L3)*DL1Z
      DER(1,7) = DNSL(L1,L4)*DL1X + DNSL(L4,L1)*DL4X
      DER(2,7) = DNSL(L1,L4)*DL1Y + DNSL(L4,L1)*DL4Y
      DER(3,7) = DNSL(L1,L4)*DL1Z + DNSL(L4,L1)*DL4Z
      DER(1,8) = DNSL(L2,L4)*DL2X + DNSL(L4,L2)*DL4X
      DER(2,8) = DNSL(L2,L4)*DL2Y + DNSL(L4,L2)*DL4Y
      DER(3,8) = DNSL(L2,L4)*DL2Z + DNSL(L4,L2)*DL4Z
      DER(1,9) = DNSL(L3,L4)*DL3X + DNSL(L4,L3)*DL4X
      DER(2,9) = DNSL(L3,L4)*DL3Y + DNSL(L4,L3)*DL4Y
      DER(3,9) = DNSL(L3,L4)*DL3Z + DNSL(L4,L3)*DL4Z
      DER(1,10) = DNVL(L4)*DL4X
      DER(2,10) = DNVL(L4)*DL4Y
      DER(3,10) = DNVL(L4)*DL4Z
C
      END
C
      SUBROUTINE TET20(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and derivatives
C      at a specified point for an 20-noded tetrahedral element.
C      the function is continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.20)
C      IDER    first dimension of array DER (.ge.3)
C      JDER    second dimension of array DER (.ge.20)
C      XI      value of local coordinate at which function and
C              derivative values required
C      ETA     value of second local coordinate
C      ZETA    value of third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     real vector of dimension ifun.  fun(i) contains
C              value of i'th shape function at (xi,eta,zeta)
C      DER     real array of dimensions (ider,jder).  der(i,j)
C              contains the derivative of the j'th shape
C              function with respect to the i'th coordinate at
C              the point (xi,eta,zeta)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE tet20(fun, IFUN, DER, IDER, JDER, XI, ETA, ZETA,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DL1X,DL1Y,DL1Z,DL2X,DL2Y,DL2Z,DL3X,DL3Y,DL3Z,
     *                 DL4X,DL4Y,DL4Z,DNMFL,DNMSLD,DNMSLS,DNVL,ETA,FUN,
     *                 L1,L2,L3,L4,LA,LB,LC,NMF,NMS,NV,XI,ZETA
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'TET20'/
C
C     Statement functions
C
      NV(LA) = 1.D0/2.D0* (3.D0*LA-1.D0)* (3.D0*LA-2.D0)*LA
      NMF(LA,LB,LC) = 27.D0*LA*LB*LC
      NMS(LA,LB) = 9.D0/2.D0*LA*LB* (3.D0*LA-1.D0)
      DNVL(LA) = 1.D0/2.D0* (27.D0*LA*LA-18.D0*LA+2.D0)
      DNMFL(LA,LB,LC) = 27.D0*LB*LC
      DNMSLS(LA,LB) = 9.D0/2.D0*LB* (6.D0*LA-1.D0)
      DNMSLD(LA,LB) = 9.D0/2.D0*LA* (3.D0*LA-1.D0)
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.20) IERROR = 1
         IF (IDER.LT.3 .OR. JDER.LT.20) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      L1 = 1.D0/12.D0* (3.D0+8.D0*XI-2.D0*DSQRT(2.D0)*ZETA)
      L2 = 1.D0/12.D0* (3.D0-4.D0* (XI+DSQRT(3.D0)*ETA)-
     *     2.D0*DSQRT(2.D0)*ZETA)
      L3 = 1.D0/12.D0* (3.D0-4.D0* (XI-DSQRT(3.D0)*ETA)-
     *     2.D0*DSQRT(2.D0)*ZETA)
      L4 = 1.D0/4.D0* (1.D0+2.D0*DSQRT(2.D0)*ZETA)
C
      DL1X = 2.D0/3.D0
      DL1Y = 0.D0
      DL1Z = -1.D0/ (3.D0*DSQRT(2.D0))
      DL2X = -1.D0/3.D0
      DL2Y = -1.D0/DSQRT(3.D0)
      DL2Z = -1.D0/ (3.D0*DSQRT(2.D0))
      DL3X = -1.D0/3.D0
      DL3Y = 1.D0/DSQRT(3.D0)
      DL3Z = -1.D0/ (3.D0*DSQRT(2.D0))
      DL4X = 0.D0
      DL4Y = 0.D0
      DL4Z = 1.D0/DSQRT(2.D0)
C
C     Shape functions
C
      FUN(1) = NV(L1)
      FUN(2) = NMS(L1,L2)
      FUN(3) = NMS(L2,L1)
      FUN(4) = NV(L2)
      FUN(5) = NMS(L2,L3)
      FUN(6) = NMS(L3,L2)
      FUN(7) = NV(L3)
      FUN(8) = NMS(L3,L1)
      FUN(9) = NMS(L1,L3)
      FUN(10) = NMF(L1,L2,L3)
      FUN(11) = NMS(L1,L4)
      FUN(12) = NMF(L4,L1,L2)
      FUN(13) = NMS(L2,L4)
      FUN(14) = NMF(L2,L3,L4)
      FUN(15) = NMS(L3,L4)
      FUN(16) = NMF(L3,L4,L1)
      FUN(17) = NMS(L4,L1)
      FUN(18) = NMS(L4,L2)
      FUN(19) = NMS(L4,L3)
      FUN(20) = NV(L4)
C
C     Derivatives
C
      DER(1,1) = DNVL(L1)*DL1X
      DER(2,1) = DNVL(L1)*DL1Y
      DER(3,1) = DNVL(L1)*DL1Z
      DER(1,2) = DNMSLS(L1,L2)*DL1X + DNMSLD(L1,L2)*DL2X
      DER(2,2) = DNMSLS(L1,L2)*DL1Y + DNMSLD(L1,L2)*DL2Y
      DER(3,2) = DNMSLS(L1,L2)*DL1Z + DNMSLD(L1,L2)*DL2Z
      DER(1,3) = DNMSLD(L2,L1)*DL1X + DNMSLS(L2,L1)*DL2X
      DER(2,3) = DNMSLD(L2,L1)*DL1Y + DNMSLS(L2,L1)*DL2Y
      DER(3,3) = DNMSLD(L2,L1)*DL1Z + DNMSLS(L2,L1)*DL2Z
      DER(1,4) = DNVL(L2)*DL2X
      DER(2,4) = DNVL(L2)*DL2Y
      DER(3,4) = DNVL(L2)*DL2Z
      DER(1,5) = DNMSLS(L2,L3)*DL2X + DNMSLD(L2,L3)*DL3X
      DER(2,5) = DNMSLS(L2,L3)*DL2Y + DNMSLD(L2,L3)*DL3Y
      DER(3,5) = DNMSLS(L2,L3)*DL2Z + DNMSLD(L2,L3)*DL3Z
      DER(1,6) = DNMSLD(L3,L2)*DL2X + DNMSLS(L3,L2)*DL3X
      DER(2,6) = DNMSLD(L3,L2)*DL2Y + DNMSLS(L3,L2)*DL3Y
      DER(3,6) = DNMSLD(L3,L2)*DL2Z + DNMSLS(L3,L2)*DL3Z
      DER(1,7) = DNVL(L3)*DL3X
      DER(2,7) = DNVL(L3)*DL3Y
      DER(3,7) = DNVL(L3)*DL3Z
      DER(1,8) = DNMSLS(L3,L1)*DL3X + DNMSLD(L3,L1)*DL1X
      DER(2,8) = DNMSLS(L3,L1)*DL3Y + DNMSLD(L3,L1)*DL1Y
      DER(3,8) = DNMSLS(L3,L1)*DL3Z + DNMSLD(L3,L1)*DL1Z
      DER(1,9) = DNMSLD(L1,L3)*DL3X + DNMSLS(L1,L3)*DL1X
      DER(2,9) = DNMSLD(L1,L3)*DL3Y + DNMSLS(L1,L3)*DL1Y
      DER(3,9) = DNMSLD(L1,L3)*DL3Z + DNMSLS(L1,L3)*DL1Z
      DER(1,10) = DNMFL(L1,L2,L3)*DL1X + DNMFL(L2,L3,L1)*DL2X +
     *            DNMFL(L3,L1,L2)*DL3X
      DER(2,10) = DNMFL(L1,L2,L3)*DL1Y + DNMFL(L2,L3,L1)*DL2Y +
     *            DNMFL(L3,L1,L2)*DL3Y
      DER(3,10) = DNMFL(L1,L2,L3)*DL1Z + DNMFL(L2,L3,L1)*DL2Z +
     *            DNMFL(L3,L1,L2)*DL3Z
      DER(1,11) = DNMSLS(L1,L4)*DL1X + DNMSLD(L1,L4)*DL4X
      DER(2,11) = DNMSLS(L1,L4)*DL1Y + DNMSLD(L1,L4)*DL4Y
      DER(3,11) = DNMSLS(L1,L4)*DL1Z + DNMSLD(L1,L4)*DL4Z
      DER(1,12) = DNMFL(L1,L2,L4)*DL1X + DNMFL(L2,L1,L4)*DL2X +
     *            DNMFL(L4,L1,L2)*DL4X
      DER(2,12) = DNMFL(L1,L2,L4)*DL1Y + DNMFL(L2,L1,L4)*DL2Y +
     *            DNMFL(L4,L1,L2)*DL4Y
      DER(3,12) = DNMFL(L1,L2,L4)*DL1Z + DNMFL(L2,L1,L4)*DL2Z +
     *            DNMFL(L4,L1,L2)*DL4Z
      DER(1,13) = DNMSLS(L2,L4)*DL2X + DNMSLD(L2,L4)*DL4X
      DER(2,13) = DNMSLS(L2,L4)*DL2Y + DNMSLD(L2,L4)*DL4Y
      DER(3,13) = DNMSLS(L2,L4)*DL2Z + DNMSLD(L2,L4)*DL4Z
      DER(1,14) = DNMFL(L2,L3,L4)*DL2X + DNMFL(L3,L2,L4)*DL3X +
     *            DNMFL(L4,L2,L3)*DL4X
      DER(2,14) = DNMFL(L2,L3,L4)*DL2Y + DNMFL(L3,L2,L4)*DL3Y +
     *            DNMFL(L4,L2,L3)*DL4Y
      DER(3,14) = DNMFL(L2,L3,L4)*DL2Z + DNMFL(L3,L2,L4)*DL3Z +
     *            DNMFL(L4,L2,L3)*DL4Z
      DER(1,15) = DNMSLS(L3,L4)*DL3X + DNMSLD(L3,L4)*DL4X
      DER(2,15) = DNMSLS(L3,L4)*DL3Y + DNMSLD(L3,L4)*DL4Y
      DER(3,15) = DNMSLS(L3,L4)*DL3Z + DNMSLD(L3,L4)*DL4Z
      DER(1,16) = DNMFL(L1,L3,L4)*DL1X + DNMFL(L3,L1,L4)*DL3X +
     *            DNMFL(L4,L1,L3)*DL4X
      DER(2,16) = DNMFL(L1,L3,L4)*DL1Y + DNMFL(L3,L1,L4)*DL3Y +
     *            DNMFL(L4,L1,L3)*DL4Y
      DER(3,16) = DNMFL(L1,L3,L4)*DL1Z + DNMFL(L3,L1,L4)*DL3Z +
     *            DNMFL(L4,L1,L3)*DL4Z
      DER(1,17) = DNMSLD(L4,L1)*DL1X + DNMSLS(L4,L1)*DL4X
      DER(2,17) = DNMSLD(L4,L1)*DL1Y + DNMSLS(L4,L1)*DL4Y
      DER(3,17) = DNMSLD(L4,L1)*DL1Z + DNMSLS(L4,L1)*DL4Z
      DER(1,18) = DNMSLD(L4,L2)*DL2X + DNMSLS(L4,L2)*DL4X
      DER(2,18) = DNMSLD(L4,L2)*DL2Y + DNMSLS(L4,L2)*DL4Y
      DER(3,18) = DNMSLD(L4,L2)*DL2Z + DNMSLS(L4,L2)*DL4Z
      DER(1,19) = DNMSLD(L4,L3)*DL3X + DNMSLS(L4,L3)*DL4X
      DER(2,19) = DNMSLD(L4,L3)*DL3Y + DNMSLS(L4,L3)*DL4Y
      DER(3,19) = DNMSLD(L4,L3)*DL3Z + DNMSLS(L4,L3)*DL4Z
      DER(1,20) = DNVL(L4)*DL4X
      DER(2,20) = DNVL(L4)*DL4Y
      DER(3,20) = DNVL(L4)*DL4Z
C
      END
C
      SUBROUTINE TET4(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and derivatives
C      at a specified point for an 10-noded tetrahedral element.
C      the function is continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.4)
C      IDER    first dimension of array DER (.ge.3)
C      JDER    second dimension of array DER (.ge.4)
C      XI      value of local coordinate at which function and
C              derivative values required
C      ETA     value of second local coordinate
C      ZETA    value of third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     real vector of dimension ifun.  fun(i) contains
C              value of i'th shape function at (xi,eta,zeta)
C      DER     real array of dimensions (ider,jder).  der(i,j)
C              contains the derivative of the j'th shape
C              function with respect to the i'th coordinate at
C              the point (xi,eta,zeta)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE tet4(fun, IFUN, DER, IDER, JDER, XI, ETA, ZETA,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,ETA,FUN,XI,ZETA
      DIMENSION DER(IDER,JDER),FUN(IFUN)
      DATA SRNAME/'TET4'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.4) IERROR = 1
         IF (IDER.LT.3 .OR. JDER.LT.4) IERROR = 2
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      FUN(1) = 1.D0/12.D0* (3.D0+8.D0*XI-2.D0*DSQRT(2.D0)*ZETA)
      FUN(2) = 1.D0/12.D0* (3.D0-4.D0* (XI+DSQRT(3.D0)*ETA)-
     *         2.D0*DSQRT(2.D0)*ZETA)
      FUN(3) = 1.D0/12.D0* (3.D0-4.D0* (XI-DSQRT(3.D0)*ETA)-
     *         2.D0*DSQRT(2.D0)*ZETA)
      FUN(4) = 1.D0/4.D0* (1.D0+2.D0*DSQRT(2.D0)*ZETA)
C
      DER(1,1) = 2.D0/3.D0
      DER(1,2) = 0.D0
      DER(1,3) = -DSQRT(2.D0)/6.D0
      DER(2,1) = -1.D0/3.D0
      DER(2,2) = -DSQRT(3.D0)/3.D0
      DER(2,3) = -DSQRT(2.D0)/6.D0
      DER(3,1) = -1.D0/3.D0
      DER(3,2) = +DSQRT(2.D0)/3.D0
      DER(3,3) = -DSQRT(2.D0)/6.D0
      DER(4,1) = 0.D0
      DER(4,2) = 0.D0
      DER(4,3) = DSQRT(2.D0)/2.D0
C
      END
C
      SUBROUTINE TRIM10(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of the shape functions and their
C      derivatives at a specified point for a 10-noded c0
C      continuous triangular element.  approximated function
C      continuous across element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    22 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    length of vector FUN (.ge.10)
C      IDER    first dimension of array DER (.ge.2)
C      JDER    second dimension of array DER (.ge.10)
C      XI      first local coordinate
C      ETA     second local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of length ifun.  fun(i) contains the
C              value of the i'th shape function at the point
C              (xi,eta), for i=1(1)10
C      DER     array of dimension (ider,jder).  der(i,j)
C              contains the value of the derivative of the j'th
C              shape function with respect to the i'th local
C              coordinate, for i=1(1)2 and j=1(1)10
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE trim10(fun, IFUN, DER, IDER, JDER, XI, ETA, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DLX,DLY,DNS1,DNS2,DNVL,DUMMY,ETA,FUN,L1,L2,
     *                 L3,LA,LB,NS,NV,VEPS,XI,XMAX,XMIN,YMAX,YMIN
      DIMENSION DER(IDER,JDER),DLX(3),DLY(3),FUN(IFUN)
C
      DATA SRNAME/'TRIM10'/
C
C     Statement functions
C
      NV(LA) = 1.D0/2.D0* (3.D0*LA-1.D0)* (3.D0*LA-2.D0)*LA
      NS(LA,LB) = 9.D0/2.D0*LA*LB* (3.D0*LA-1.D0)
      DNVL(LA) = 1.D0/2.D0* (27.D0*LA*LA-18.D0*LA+2.D0)
      DNS1(LA,LB) = 9.D0/2.D0*LB* (6.D0*LA-1.D0)
      DNS2(LA,LB) = 9.D0/2.D0*LA* (3.D0*LA-1.D0)
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.10) IERROR = 1
         IF (IDER.LT.2 .OR. JDER.LT.10) IERROR = 2
         YMIN = 1.0D0/DSQRT(3.0D0)* (XI-1.0D0) - VEPS(DUMMY)
         YMAX = 1.0D0/DSQRT(3.0D0)* (1.0D0-XI) + VEPS(DUMMY)
         XMIN = - (0.5D0+VEPS(DUMMY))
         XMAX = 1.0D0 + VEPS(DUMMY)
         IF ((XI.LT.XMIN.OR.XI.GT.XMAX) .OR.
     *       (ETA.LT.YMIN.OR.ETA.GT.YMAX)) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      L1 = 1.0D0/3.0D0* (1.0D0+2.0D0*XI)
      L2 = 1.0D0/3.0D0* (1.0D0-XI-DSQRT(3.0D0)*ETA)
      L3 = 1.0D0/3.0D0* (1.0D0-XI+DSQRT(3.0D0)*ETA)
      DLX(1) = 2.D0/3.D0
      DLY(1) = 0.D0
      DLX(2) = -1.D0/3.D0
      DLY(2) = -1.D0/DSQRT(3.D0)
      DLX(3) = -1.D0/3.D0
      DLY(3) = 1.D0/DSQRT(3.D0)
C
C     Shape functions
C
      FUN(1) = NV(L1)
      FUN(2) = NS(L1,L2)
      FUN(3) = NS(L2,L1)
      FUN(4) = NV(L2)
      FUN(5) = NS(L2,L3)
      FUN(6) = NS(L3,L2)
      FUN(7) = NV(L3)
      FUN(8) = NS(L3,L1)
      FUN(9) = NS(L1,L3)
      FUN(10) = 27.D0*L1*L2*L3
C
C     Derivatives
C
      DER(1,1) = DNVL(L1)*DLX(1)
      DER(2,1) = DNVL(L1)*DLY(1)
      DER(1,2) = DNS1(L1,L2)*DLX(1) + DNS2(L1,L2)*DLX(2)
      DER(2,2) = DNS1(L1,L2)*DLY(1) + DNS2(L1,L2)*DLY(2)
      DER(1,3) = DNS1(L2,L1)*DLX(2) + DNS2(L2,L1)*DLX(1)
      DER(2,3) = DNS1(L2,L1)*DLY(2) + DNS2(L2,L1)*DLY(1)
      DER(1,4) = DNVL(L2)*DLX(2)
      DER(2,4) = DNVL(L2)*DLY(2)
      DER(1,5) = DNS1(L2,L3)*DLX(2) + DNS2(L2,L3)*DLX(3)
      DER(2,5) = DNS1(L2,L3)*DLY(2) + DNS2(L2,L3)*DLY(3)
      DER(1,6) = DNS1(L3,L2)*DLX(3) + DNS2(L3,L2)*DLX(2)
      DER(2,6) = DNS1(L3,L2)*DLY(3) + DNS2(L3,L2)*DLY(2)
      DER(1,7) = DNVL(L3)*DLX(3)
      DER(2,7) = DNVL(L3)*DLY(3)
      DER(1,8) = DNS1(L3,L1)*DLX(3) + DNS2(L3,L1)*DLX(1)
      DER(2,8) = DNS1(L3,L1)*DLY(3) + DNS2(L3,L1)*DLY(1)
      DER(1,9) = DNS1(L1,L3)*DLX(1) + DNS2(L1,L3)*DLX(3)
      DER(2,9) = DNS1(L1,L3)*DLY(1) + DNS2(L1,L3)*DLY(3)
      DER(1,10) = 27.D0* (DLX(1)*L2*L3+L1*DLX(2)*L3+L1*L2*DLX(3))
      DER(2,10) = 27.D0* (DLY(1)*L2*L3+L1*DLY(2)*L3+L1*L2*DLY(3))
C
      END
C
      SUBROUTINE TRIM3(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of the shape functions and their
C      derivatives at a specified point for a three-noded c0
C      continuous triangular element.  approximated function
C      continuous across element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    22 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    length of vector FUN (.ge.3)
C      IDER    first dimension of array DER (.ge.2)
C      JDER    second dimension of array DER (.ge.3)
C      XI      first local coordinate
C      ETA     second local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of length ifun.  fun(i) contains the
C              value of the i'th shape function at the point
C              (xi,eta), for i=1(1)3
C      DER     array of dimension (ider,jder).  der(i,j)
C              contains the derivative of the j'th shape
C              function with respect to the i'th coordinate for
C              i=1(1)2 and j=1(1)3
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE trim3(fun, IFUN, DER, IDER, JDER, XI, ETA, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,ETA,FUN,VEPS,XI,XMAX,XMIN,YMAX,YMIN
      DIMENSION DER(IDER,JDER),FUN(IFUN)
C
      DATA SRNAME/'TRIM3'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.3) IERROR = 1
         IF (IDER.LT.2 .OR. JDER.LT.3) IERROR = 2
         YMIN = 1.0D0/DSQRT(3.0D0)* (XI-1.0D0) - VEPS(DUMMY)
         YMAX = 1.0D0/DSQRT(3.0D0)* (1.0D0-XI) + VEPS(DUMMY)
         XMIN = - (0.5D0+VEPS(DUMMY))
         XMAX = 1.0D0 + VEPS(DUMMY)
         IF ((XI.LT.XMIN.OR.XI.GT.XMAX) .OR.
     *       (ETA.LT.YMIN.OR.ETA.GT.YMAX)) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      FUN(1) = 1.0D0/3.0D0* (1.0D0+2.0D0*XI)
      FUN(2) = 1.0D0/3.0D0* (1.0D0-XI-DSQRT(3.0D0)*ETA)
      FUN(3) = 1.0D0/3.0D0* (1.0D0-XI+DSQRT(3.0D0)*ETA)
C
C     Derivatives
C
      DER(1,1) = 2.0D0/3.0D0
      DER(1,2) = -1.0D0/3.0D0
      DER(1,3) = -1.0D0/3.0D0
      DER(2,1) = 0.0D0
      DER(2,2) = -1.0D0/DSQRT(3.0D0)
      DER(2,3) = +1.0D0/DSQRT(3.0D0)
C
      END
C
      SUBROUTINE TRIM6(FUN,IFUN,DER,IDER,JDER,XI,ETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of the shape functions and their
C      derivatives at a specified point for a 6-noded c0
C      continuous triangular element.  approximated function
C      continuous across element boundaries
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    22 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    length of vector FUN (.ge.6)
C      IDER    first dimension of array DER (.ge.2)
C      JDER    second dimension of array DER (.ge.6)
C      XI      first local coordinate
C      ETA     second local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     vector of length ifun.  fun(i) contains the
C              value of the i'th shape function at the point
C              (xi,eta), for i=1(1)6
C      DER     array of dimension (ider,jder).  der(i,j)
C              contains the value of the derivative of the j'th
C              shape function with respect to the i'th local
C              coordinate at the point (xi,eta), for i=1(1)2
C              and j=1(1)6
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE trim6(fun, IFUN, DER, IDER, JDER, XI, ETA, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,ETA,FUN,L1,L2,L3,VEPS,XI,XMAX,XMIN,
     *                 YMAX,YMIN
      DIMENSION DER(IDER,JDER),FUN(IFUN)
C
      DATA SRNAME/'TRIM6'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.6) IERROR = 1
         IF (IDER.LT.2 .OR. JDER.LT.6) IERROR = 2
         YMIN = 1.0D0/DSQRT(3.0D0)* (XI-1.0D0) - VEPS(DUMMY)
         YMAX = 1.0D0/DSQRT(3.0D0)* (1.0D0-XI) + VEPS(DUMMY)
         XMIN = - (0.5D0+VEPS(DUMMY))
         XMAX = 1.0D0 + VEPS(DUMMY)
         IF ((XI.LT.XMIN.OR.XI.GT.XMAX) .OR.
     *       (ETA.LT.YMIN.OR.ETA.GT.YMAX)) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      L1 = 1.0D0/3.0D0* (1.0D0+2.0D0*XI)
      L2 = 1.0D0/3.0D0* (1.0D0-XI-DSQRT(3.0D0)*ETA)
      L3 = 1.0D0/3.0D0* (1.0D0-XI+DSQRT(3.0D0)*ETA)
C
C     Shape functions
C
      FUN(1) = (2.0D0*L1-1.0D0)*L1
      FUN(2) = 4.0D0*L1*L2
      FUN(3) = (2.0D0*L2-1.0D0)*L2
      FUN(4) = 4.0D0*L2*L3
      FUN(5) = (2.0D0*L3-1.0D0)*L3
      FUN(6) = 4.0D0*L3*L1
C
C     Derivatives
C
      DER(1,1) = 2.0D0/3.0D0* (4.0D0*L1-1.0D0)
      DER(1,2) = 4.0D0/3.0D0* (2.0D0*L2-L1)
      DER(1,3) = -1.0D0/3.0D0* (4.0D0*L2-1.0D0)
      DER(1,4) = -4.0D0/3.0D0* (L2+L3)
      DER(1,5) = -1.0D0/3.0D0* (4.0D0*L3-1.0D0)
      DER(1,6) = 4.0D0/3.0D0* (2.0D0*L3-L1)
      DER(2,1) = 0.0D0
      DER(2,2) = -4.0D0/DSQRT(3.0D0)*L1
      DER(2,3) = -1.0D0/DSQRT(3.0D0)* (4.0D0*L2-1.0D0)
      DER(2,4) = 4.0D0/DSQRT(3.0D0)* (L2-L3)
      DER(2,5) = 1.0D0/DSQRT(3.0D0)* (4.0D0*L3-1.0D0)
      DER(2,6) = 4.0D0/DSQRT(3.0D0)*L1
C
      END
C
      SUBROUTINE UPDATE(PHI,IPHI,RHS,IRHS,TOTNOD,DOFNOD,TOTDOF,NF,INF,
     *                  JNF,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      this routine takes a full solution vector and a set of
C      updates and updates the solution vector
C
C method
C      the routine assumes that the solution vector is full
C      and that the UPDATE vector is imcomplete. the UPDATE
C      is performed using the nodal freedom array to direct
C      UPDATE to freedom mapping
C
C HISTORY
C
C      Copyright (C) 1984 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 3.0  29 Jun 1986 (cjh,cg)
C
C ARGUMENTS in
C      PHI     solution vector
C      IPHI    dimension of vector PHI (iphi.ge.totnod*dofnod)
C      RHS     vector of updates
C      IRHS    dimension of vector RHS (irhs.ge.totdof)
C      TOTNOD  the number of nodes in the problem
C      DOFNOD  the maximum number of nodes per node
C      TOTDOF  the number of freedoms in RHS
C      NF      the nodal freedom array
C      INF     first dimension of NF (inf.ge.totnod)
C      JNF     second dimension of NF (jnf.ge.dofnod)
C      ITEST   error checking option
C
C ARGUMENTS out
C      PHI     the updated solution vector
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE update(phi, IPHI, RHS, IRHS, TOTNOD, DOFNOD,
C    *     TOTDOF, NF, INF, JNF, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,DOFNOD,I,IERROR,INF,IPHI,IRHS,ITEST,J,JNF,K,L,NF,
     *        TOTDOF,TOTNOD
      CHARACTER*6 SRNAME
      DOUBLE PRECISION PHI,RHS
      DIMENSION NF(INF,JNF),PHI(IPHI),RHS(IRHS)
      DATA SRNAME/'UPDATE'/
C
C     Check array bounds
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IPHI.LT.TOTNOD*DOFNOD) IERROR = 1
         IF (IRHS.LT.TOTDOF) IERROR = 2
         IF (INF.LT.TOTNOD) IERROR = 3
         IF (JNF.LT.DOFNOD) IERROR = 4
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
      DO 1010 I = 1,TOTNOD
C
         DO 1000 J = 1,DOFNOD
C
            K = NF(I,J)
C
C     Don't UPDATE restrained variables
C
            IF (K.NE.0) THEN
C
               L = I + J - 1
C
C     UPDATE solution vector
C
               PHI(L) = PHI(L) + RHS(K)
            END IF
 1000    CONTINUE
C
 1010 CONTINUE
C
      END
C
      SUBROUTINE VECADD(V,IV,W,IW,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      adds the vector V to the vector W, storing the result
C      in V
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    23 Oct 1980 (KR)
C
C ARGUMENTS in
C      V       vector of length iv.  on entry, contains the
C              values of one of the vectors to be added
C              in elements 1 to N
C      IV      length of vector V (.ge.n)
C      W       vector of length iw.  contains the values of the
C              second vector to be added in elements 1 to N
C      IW      length of vector W (.ge.n)
C      N       number of elements of V and W to be added
C      ITEST   error checking option
C
C ARGUMENTS out
C      V       vector of length iv.  on exit, v(i) contains
C              the sum of v(i) and w(i) for i=1(1)n
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE vecadd(v, IV, W, IW, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IV,IW,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION V,W
      DIMENSION V(IV),W(IW)
C
      DATA SRNAME/'VECADD'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IW) IERROR = 3
         IF (N.GT.IV) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1000 I = 1,N
         V(I) = V(I) + W(I)
 1000 CONTINUE
C
      END
C
      SUBROUTINE VECCOP(V,IV,W,IW,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      copies first N elements of the vector V into the vector W
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    23 Oct 1980 (KR)
C
C ARGUMENTS in
C      V       vector of length IV to be copied
C      IV      length of vector V (.ge.n)
C      IW      length of vector W
C      N       number of elements of V to be copied
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of length iw; w(i)is set to v(i) for
C              i=1(1)n
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE veccop(v, IV, W, IW, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IV,IW,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION V,W
      DIMENSION V(IV),W(IW)
C
      DATA SRNAME/'VECCOP'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IW) IERROR = 3
         IF (N.GT.IV) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1000 I = 1,N
         W(I) = V(I)
 1000 CONTINUE
C
      END
C
      SUBROUTINE VECMAT(V,IV,A,IA,JA,M,N,W,IW,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      pre-multiplies the matrix A by the vector V, storing
C      the result in the vector W
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 2.0  1 Feb 1981 (CG) --- SERC Copyright
C      Commented    1 Feb 1981 (CG)
C
C ARGUMENTS in
C      V       vector of dimension IV
C      IV      dimension of V (.ge.m)
C      A       array of dimension (ia,ja)
C      IA      first dimension of A (.ge.m)
C      JA      second dimension of A (.ge.n)
C      M       number of rows of A to be used in the
C              multiplication
C      N       number of columns of A and the number of
C              elemenets of V to be used in the multiplication
C      IW      dimension of vector W (.ge.n)
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of dimension iw; contains the result of
C              the operation w=v*a
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE vecmat(a, IA, JA, V, IV, M, N, W, IW, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IA,IERROR,ITEST,IV,IW,J,JA,M,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W,X
      DIMENSION A(IA,JA),V(IV),W(IW)
C
      DATA SRNAME/'VECMAT'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IW) IERROR = 4
         IF (M.GT.IV) IERROR = 3
         IF (M.GT.IA .OR. N.GT.JA) IERROR = 2
         IF (M.LE.0 .OR. N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1010 I = 1,N
         X = 0.0D0
         DO 1000 J = 1,M
            X = X + A(J,I)*V(J)
 1000    CONTINUE
         W(I) = X
 1010 CONTINUE
C
      END
C
      SUBROUTINE VECNUL(VEC,IVEC,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      sets the first N elements of a vector to zero
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    23 Oct 1980 (KR)
C
C ARGUMENTS in
C      iv      length of vector v (.ge.n)
C      N       number of elements to be set to zero
C      ITEST   error checking option
C
C ARGUMENTS out
C      v       vector of length iv.  v(i)=0.0d0 for i=1(1)n
C
C ROUTINES called
C      ERRMES
C
C     SUBROUTINE vecnul(vec, IVEC, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IVEC,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION VEC
      DIMENSION VEC(IVEC)
C
      DATA SRNAME/'VECNUL'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IVEC) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1000 I = 1,N
         VEC(I) = 0.0D0
 1000 CONTINUE
C
      END
C
      SUBROUTINE VECSUB(V,IV,W,IW,N,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      subtracts the vector W from vector V, storing the
C      result in V
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (ims)
C      Commented    23 Oct 1980 (KR)
C
C ARGUMENTS in
C      V       vector of length iv.  on entry, v(i), i=1(1)n,
C              contains values from which corresponding values
C              w(i) are to be subtracted
C      IV      length of V (.ge.n)
C      W       vector of length iw.  the elements w(i), i=1(1)n
C              are to be subtracted from the corresponding
C              elements of V
C      IW      length of W (.ge.n)
C      N       number of elements of V and W to be operated on
C      ITEST   error checking option
C
C ARGUMENTS out
C      V       vector of length iv.  on exit, v(i) is set to
C              v(i)-w(i) for i=1(1)n
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE vecsub(v, IV, W, IW, N, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,I,IERROR,ITEST,IV,IW,N
      CHARACTER*6 SRNAME
      DOUBLE PRECISION V,W
      DIMENSION V(IV),W(IW)
C
      DATA SRNAME/'VECSUB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (N.GT.IW) IERROR = 3
         IF (N.GT.IV) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1000 I = 1,N
         V(I) = V(I) - W(I)
 1000 CONTINUE
C
      END
C
      SUBROUTINE VMSYB(V,IV,A,IA,JA,W,IW,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      pre-multiplies A real unsymmetric banded matrix stored as
C      A rectangular array by A vector
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      V       vector of dimension IV
C      IV      dimension of vector V (.ge.n)
C      A       array of dimension (ia,ja).  contains the
C              elements of the real unsymmetric band matrix
C              of order N and semi-bandwidth HBAND
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.hband)
C      IW      dimension of vector W (.ge.n)
C      N       order of the real unsymmetric band matrix
C      HBAND   semi-bandwidth of the real unsymmetric band matrix
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of dimension iw.  contains the result of
C              the operation w=a*v
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE vmsyb(v, IV, A, IA, JA, W, IW, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,HBAND,I,IERROR,IJ,ITEST,IV,IW,J,JI,N,IA,JA
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W,X
      DIMENSION A(IA,JA),V(IV),W(IW)
C
      DATA SRNAME/'VMSYB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IW.LT.N) IERROR = 4
         IF (IV.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.HBAND) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      DO 1020 I = 1,N
         X = 0.0D0
         J = HBAND
 1000    CONTINUE
         IF (I+J.GT.HBAND) THEN
            IJ = I + J - HBAND
            X = X + A(I,J)*V(IJ)
         END IF
         J = J - 1
         IF (J.NE.0) GO TO 1000
         J = HBAND - 1
 1010    CONTINUE
         IF (I-J.LT.N-HBAND+1) THEN
            JI = I - J + HBAND
            X = X + A(JI,J)*V(JI)
         END IF
         J = J - 1
         IF (J.NE.0) GO TO 1010
         W(I) = X
 1020 CONTINUE
C
      END
C
      SUBROUTINE VMUSB(V,IV,A,IA,JA,W,IW,N,HBAND,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      pre-multiplies A real unsymmetric banded matrix stored as
C      A rectangular array by A vector
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    14 Oct 1980 (KR)
C
C ARGUMENTS in
C      V       vector of dimension IV
C      IV      dimension of vector V (.ge.n)
C      A       array of dimension (ia,ja).  contains the
C              elements of the real unsymmetric BAND matrix
C              of order N and semi-bandwidth HBAND
C      IA      first dimension of A (.ge.n)
C      JA      second dimension of A (.ge.2*hband-1)
C      IW      dimension of vector W (.ge.n)
C      N       order of the real unsymmetric BAND matrix
C      HBAND   semi-bandwidth of the real unsymmetric BAND matrix
C      ITEST   error checking option
C
C ARGUMENTS out
C      W       vector of dimension iw.  contains the result of
C              the operation w=v*a
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE vmsyb(v, IV, A, IA, JA, W, IW, N, HBAND, ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER BAND,ERRMES,HBAND,I,IERROR,IJ,ITEST,IV,IW,J,JI,N,IA,JA
      CHARACTER*6 SRNAME
      DOUBLE PRECISION A,V,W,X
      DIMENSION A(IA,JA),V(IV),W(IW)
C
      DATA SRNAME/'VMUSB'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IW.LT.N) IERROR = 4
         IF (IV.LT.N) IERROR = 3
         IF (IA.LT.N .OR. JA.LT.2*HBAND-1) IERROR = 2
         IF (N.LE.0) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
      BAND = 2*HBAND - 1
C
C     Main body
C
      DO 1010 I = 1,N
         X = 0.0D0
         DO 1000 J = 1,BAND
            IJ = J - HBAND + I
            JI = BAND + 1 - J
            IF ((IJ.GE.1) .AND. (IJ.LE.N)) X = X + A(IJ,JI)*V(IJ)
 1000    CONTINUE
         W(I) = X
 1010 CONTINUE
C
      END
C
      SUBROUTINE WDG15(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and derivatives
C      at a specified point for an 6-noded pentahedral element.
C      the function is continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.15)
C      IDER    first dimension of array DER (.ge.3)
C      JDER    second dimension of array DER (.ge.15)
C      XI      value of local coordinate at which function and
C              derivative values required
C      ETA     value of second local coordinate
C      ZETA    value of third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     real vector of dimension ifun.  fun(i) contains
C              value of i'th shape function at (xi,eta,zeta)
C      DER     real array of dimensions (ider,jder).  der(i,j)
C              contains the derivative of the j'th shape
C              function with respect to the i'th coordinate at
C              the point (xi,eta,zeta)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE wdg15(fun, IFUN, DER, IDER, JDER, XI, ETA, ZETA,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DL1X,DL1Y,DL2X,DL2Y,DL3X,DL3Y,DNCL,DNCZ,
     *                 DNMQL,DNMQZ,DNMTL,DNMTZ,DUMMY,ETA,FUN,L1,L2,L3,
     *                 LA,LB,NC,NMQ,NMT,VEPS,XI,XMAX,XMIN,YMAX,YMIN,Z,
     *                 ZETA,ZM,ZP,ZVAL
      DIMENSION DER(IDER,JDER),FUN(IFUN)
C
      DATA SRNAME/'WDG15'/
C
C     Statement functions
C
      NC(LA,Z) = 1.D0/2.D0*LA* (2.D0*LA-1.D0)* (1.D0+Z*ZETA) -
     *           1.D0/2.D0*LA* (1.D0-ZETA*ZETA)
      NMT(LA,LB,Z) = 2.D0*LA*LB* (1.D0+Z*ZETA)
      NMQ(LA) = LA* (1.D0-ZETA*ZETA)
      DNCL(LA,Z) = 1.D0/2.D0* ((4.D0*LA-1.D0)* (1.D0+Z*ZETA)+ZETA*ZETA-
     *             1.D0)
      DNCZ(LA,Z) = 1.D0/2.D0*LA* (2.D0*ZETA+Z* (2.D0*LA-1.D0))
      DNMQL(LA) = 1.D0 - ZETA*ZETA
      DNMQZ(LA) = -2.D0*LA*ZETA
      DNMTL(LA,LB,Z) = 2.D0*LB* (1.D0+Z*ZETA)
      DNMTZ(LA,LB,Z) = 2.D0*LA*LB*Z
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         YMIN = 1.0D0/DSQRT(3.0D0)* (XI-1.0D0) - VEPS(DUMMY)
         YMAX = 1.0D0/DSQRT(3.0D0)* (1.0D0-XI) + VEPS(DUMMY)
         XMIN = - (0.5D0+VEPS(DUMMY))
         XMAX = 1.0D0 + VEPS(DUMMY)
         ZVAL = 1.0D0 + VEPS(DUMMY)
         IF ((XI.LT.XMIN.OR.XI.GT.XMAX) .OR.
     *       (ETA.LT.YMIN.OR.ETA.GT.YMAX) .OR.
     *       DABS(ZETA).GT.ZVAL) IERROR = 3
         IF (IDER.LT.3 .OR. JDER.LT.15) IERROR = 2
         IF (IFUN.LT.15) IERROR = 1
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      L1 = 1.D0/3.D0* (1.D0+2.D0*XI)
      L2 = 1.D0/3.D0* (1.D0-XI-DSQRT(3.D0)*ETA)
      L3 = 1.D0/3.D0* (1.D0-XI+DSQRT(3.D0)*ETA)
      DL1X = 2.D0/3.D0
      DL1Y = 0.D0
      DL2X = -1.D0/3.D0
      DL2Y = -1.D0/DSQRT(3.D0)
      DL3X = -1.D0/3.D0
      DL3Y = 1.D0/DSQRT(3.D0)
      ZP = 1.D0
      ZM = -1.D0
C
C     Shape functions
C
      FUN(1) = NC(L1,ZM)
      FUN(2) = NMT(L1,L2,ZM)
      FUN(3) = NC(L2,ZM)
      FUN(4) = NMT(L2,L3,ZM)
      FUN(5) = NC(L3,ZM)
      FUN(6) = NMT(L3,L1,ZM)
      FUN(7) = NMQ(L1)
      FUN(8) = NMQ(L2)
      FUN(9) = NMQ(L3)
      FUN(10) = NC(L1,ZP)
      FUN(11) = NMT(L1,L2,ZP)
      FUN(12) = NC(L2,ZP)
      FUN(13) = NMT(L2,L3,ZP)
      FUN(14) = NC(L3,ZP)
      FUN(15) = NMT(L3,L1,ZP)
C
C     Derivatives
C
      DER(1,1) = DNCL(L1,ZM)*DL1X
      DER(2,1) = DNCL(L1,ZM)*DL1Y
      DER(3,1) = DNCZ(L1,ZM)
      DER(1,2) = DNMTL(L1,L2,ZM)*DL1X + DNMTL(L2,L1,ZM)*DL2X
      DER(2,2) = DNMTL(L1,L2,ZM)*DL1Y + DNMTL(L2,L1,ZM)*DL2Y
      DER(3,2) = DNMTZ(L1,L2,ZM)
      DER(1,3) = DNCL(L2,ZM)*DL2X
      DER(2,3) = DNCL(L2,ZM)*DL2Y
      DER(3,3) = DNCZ(L2,ZM)
      DER(1,4) = DNMTL(L2,L3,ZM)*DL2X + DNMTL(L3,L2,ZM)*DL3X
      DER(2,4) = DNMTL(L2,L3,ZM)*DL2Y + DNMTL(L3,L2,ZM)*DL3Y
      DER(3,4) = DNMTZ(L2,L3,ZM)
      DER(1,5) = DNCL(L3,ZM)*DL3X
      DER(2,5) = DNCL(L3,ZM)*DL3Y
      DER(3,5) = DNCZ(L3,ZM)
      DER(1,6) = DNMTL(L3,L1,ZM)*DL3X + DNMTL(L1,L3,ZM)*DL1X
      DER(2,6) = DNMTL(L3,L1,ZM)*DL3Y + DNMTL(L1,L3,ZM)*DL1Y
      DER(3,6) = DNMTZ(L3,L1,ZM)
      DER(1,7) = DNMQL(L1)*DL1X
      DER(2,7) = DNMQL(L1)*DL1Y
      DER(3,7) = DNMQZ(L1)
      DER(1,8) = DNMQL(L2)*DL2X
      DER(2,8) = DNMQL(L2)*DL2Y
      DER(3,8) = DNMQZ(L2)
      DER(1,9) = DNMQL(L3)*DL3X
      DER(2,9) = DNMQL(L3)*DL3Y
      DER(3,9) = DNMQZ(L3)
      DER(1,10) = DNCL(L1,ZP)*DL1X
      DER(2,10) = DNCL(L1,ZP)*DL1Y
      DER(3,10) = DNCZ(L1,ZP)
      DER(1,11) = DNMTL(L1,L2,ZP)*DL1X + DNMTL(L2,L1,ZP)*DL2X
      DER(2,11) = DNMTL(L1,L2,ZP)*DL1Y + DNMTL(L2,L1,ZP)*DL2Y
      DER(3,11) = DNMTZ(L1,L2,ZP)
      DER(1,12) = DNCL(L2,ZP)*DL2X
      DER(2,12) = DNCL(L2,ZP)*DL2Y
      DER(3,12) = DNCZ(L2,ZP)
      DER(1,13) = DNMTL(L2,L3,ZP)*DL2X + DNMTL(L3,L2,ZP)*DL3X
      DER(2,13) = DNMTL(L2,L3,ZP)*DL2Y + DNMTL(L3,L2,ZP)*DL3Y
      DER(3,13) = DNMTZ(L2,L3,ZP)
      DER(1,14) = DNCL(L3,ZP)*DL3X
      DER(2,14) = DNCL(L3,ZP)*DL3Y
      DER(3,14) = DNCZ(L3,ZP)
      DER(1,15) = DNMTL(L3,L1,ZP)*DL3X + DNMTL(L1,L3,ZP)*DL1X
      DER(2,15) = DNMTL(L3,L1,ZP)*DL3Y + DNMTL(L1,L3,ZP)*DL1Y
      DER(3,15) = DNMTZ(L3,L1,ZP)
C
      END
C
      SUBROUTINE WDG6(FUN,IFUN,DER,IDER,JDER,XI,ETA,ZETA,ITEST)
*$pl$ cmmode=verbatim
C-----------------------------------------------------------------------
C PURPOSE
C      returns the values of shape functions and derivatives
C      at a specified point for an 6-noded pentahedral element.
C      the function is continuous across element boundaries.
C
C HISTORY
C
C      Copyright (C) 1985 : SERC, Rutherford Appleton Laboratory
C                           Chilton, Didcot, Oxfordshire OX11 0QX
C
C      Release 1.1  29 Oct 1979 (CG)
C      Commented    10 Oct 1980 (KR)
C
C ARGUMENTS in
C      IFUN    dimension of vector FUN (.ge.6)
C      IDER    first dimension of array DER (.ge.3)
C      JDER    second dimension of array DER (.ge.6)
C      XI      value of local coordinate at which function and
C              derivative values required
C      ETA     value of second local coordinate
C      ZETA    value of third local coordinate
C      ITEST   error checking option
C
C ARGUMENTS out
C      FUN     real vector of dimension ifun.  fun(i) contains
C              value of i'th shape function at (xi,eta,zeta)
C      DER     real array of dimensions (ider,jder).  der(i,j)
C              contains the derivative of the j'th shape
C              function with respect to the i'th coordinate at
C              the point (xi,eta,zeta)
C
C ROUTINES called
C      ERRMES
C
C
C     SUBROUTINE wdg6(fun, IFUN, DER, IDER, JDER, XI, ETA, ZETA,
C    *     ITEST)
C***********************************************************************
*     $pl$ cmmode=skip_leading_blanks
C
      INTEGER ERRMES,IDER,IERROR,IFUN,ITEST,JDER
      CHARACTER*6 SRNAME
      DOUBLE PRECISION DER,DUMMY,ETA,FUN,L1,L2,L3,VEPS,XI,XMAX,XMIN,
     *                 YMAX,YMIN,ZETA,ZETAM,ZETAP,ZVAL
      DIMENSION DER(IDER,JDER),FUN(IFUN)
C
      DATA SRNAME/'WDG6'/
C
C     Parameter checking
C
      IF (ITEST.NE.-1) THEN
         IERROR = 0
         IF (IFUN.LT.6) IERROR = 1
         IF (IDER.LT.3 .OR. JDER.LT.6) IERROR = 2
         YMIN = 1.0D0/DSQRT(3.0D0)* (XI-1.0D0) - VEPS(DUMMY)
         YMAX = 1.0D0/DSQRT(3.0D0)* (1.0D0-XI) + VEPS(DUMMY)
         XMIN = - (0.5D0+VEPS(DUMMY))
         XMAX = 1.0D0 + VEPS(DUMMY)
         ZVAL = 1.0D0 + VEPS(DUMMY)
         IF ((XI.LT.XMIN.OR.XI.GT.XMAX) .OR.
     *       (ETA.LT.YMIN.OR.ETA.GT.YMAX) .OR.
     *       DABS(ZETA).GT.ZVAL) IERROR = 3
         ITEST = ERRMES(ITEST,IERROR,SRNAME)
         IF (ITEST.NE.0) RETURN
      END IF
C
C     Main body
C
      L1 = 1.D0/6.D0* (1.D0+2.D0*XI)
      L2 = 1.D0/6.D0* (1.D0-XI-DSQRT(3.D0)*ETA)
      L3 = 1.D0/6.D0* (1.D0-XI+DSQRT(3.D0)*ETA)
      ZETAM = (1.D0-ZETA)
      ZETAP = (1.D0+ZETA)
C
C     Shape functions
C
      FUN(1) = L1*ZETAM
      FUN(2) = L2*ZETAM
      FUN(3) = L3*ZETAM
      FUN(4) = L1*ZETAP
      FUN(5) = L2*ZETAP
      FUN(6) = L3*ZETAP
C
C     Derivatives
C
      DER(1,1) = 1.D0/3.D0*ZETAM
      DER(2,1) = 0.D0
      DER(3,1) = -L1
      DER(1,2) = -1.D0/6.D0*ZETAM
      DER(2,2) = -1.D0/ (2.D0*DSQRT(3.D0))*ZETAM
      DER(3,2) = -L2
      DER(1,3) = -1.D0/6.D0*ZETAM
      DER(2,3) = 1.D0/ (2.D0*DSQRT(3.D0))*ZETAM
      DER(3,3) = -L3
      DER(1,4) = 1.D0/3.D0*ZETAP
      DER(2,4) = 0.D0
      DER(3,4) = L1
      DER(1,5) = -1.D0/6.D0*ZETAP
      DER(2,5) = -1.D0/ (2.D0*DSQRT(3.D0))*ZETAP
      DER(3,5) = L2
      DER(1,6) = -1.D0/6.D0*ZETAP
      DER(2,6) = 1.D0/ (2.D0*DSQRT(3.D0))*ZETAP
      DER(3,6) = L3
C
      END
